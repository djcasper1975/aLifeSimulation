<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A-Life Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Consolas', 'Monaco', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom styles for the grid visualization */
        #worldCanvas {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #0d1117; /* Dark background for console feel */
            border-radius: 0.5rem;
            /* CRITICAL: Ensures characters are drawn without interpolation/blurring */
            image-rendering: pixelated; 
            
            /* Ensure the canvas size defined by JS is respected and centered */
            display: block; 
            margin: 0 auto; 
        }

        #statsPanel {
            overflow-y: visible; /* Ensure it expands naturally */
        }

        body, html {
            height: 100%;
            margin: 0;
            background-color: #1f2937;
        }

        #canvasWrapper {
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }

        @media (min-width: 1024px) {
            #canvasWrapper {
                width: 100%;
                margin: 0;
            }
        }
        
        /* NEW: Settings Modal Styles */
        .modal {
            background-color: rgba(0, 0, 0, 0.6);
        }
        
        .modal-content {
            max-height: 90vh;
        }
        
        .hidden {
            display: none;
        }
        
        /* Style for number inputs in the modal */
        #settingsForm input[type="number"] {
            background-color: #374151; /* bg-gray-700 */
            border: 1px solid #4b5563; /* border-gray-600 */
            color: white;
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.5rem 0.75rem; /* px-3 py-2 */
            width: 100%;
        }
        
        #settingsForm label {
            display: block;
            margin-bottom: 0.5rem; /* mb-2 */
            font-weight: 500; /* font-medium */
            color: #d1d5db; /* text-gray-300 */
        }
        
        #settingsForm fieldset {
            border: 1px solid #4b5563; /* border-gray-600 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem; /* p-4 */
            margin-bottom: 1.5rem; /* mb-6 */
        }
        
        #settingsForm legend {
            padding: 0 0.5rem; /* px-2 */
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: #60a5fa; /* text-blue-400 */
        }
        
    </style>
</head>
<body class="p-4 sm:p-8 bg-gray-800 text-white min-h-screen">

    <div id="settingsModal" class="modal hidden fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="modal-content bg-gray-800 border border-gray-700 rounded-lg shadow-2xl w-full max-w-3xl flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h2 class="text-2xl font-bold text-white">Simulation Settings</h2>
                <button id="closeSettingsBtn" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            
            <form id="settingsForm" class="p-6 overflow-y-auto flex-1 min-h-0">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6">
                    
                    <div>
                        <fieldset>
                            <legend>Age & Love</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="ADULT_AGE">Adult Age</label>
                                    <input type="number" id="ADULT_AGE" name="ADULT_AGE" step="1">
                                </div>
                                <div>
                                    <label for="OLD_AGE">Old Age</label>
                                    <input type="number" id="OLD_AGE" name="OLD_AGE" step="1">
                                </div>
                                <div>
                                    <label for="MAX_AGE">Max Age</label>
                                    <input type="number" id="MAX_AGE" name="MAX_AGE" step="1">
                                </div>
                                <div>
                                    <label for="STARTING_LOVE">Starting Love</label>
                                    <input type="number" id="STARTING_LOVE" name="STARTING_LOVE" step="0.1">
                                </div>
                                <div>
                                    <label for="LOVE_GAIN_EAT">Love Gain (Eat)</label>
                                    <input type="number" id="LOVE_GAIN_EAT" name="LOVE_GAIN_EAT" step="0.1">
                                </div>
                                <div>
                                    <label for="LOVE_GAIN_SOCIAL">Love Gain (Social)</label>
                                    <input type="number" id="LOVE_GAIN_SOCIAL" name="LOVE_GAIN_SOCIAL" step="0.1">
                                </div>
                                <div>
                                    <label for="LOVE_GAIN_REST">Love Gain (Rest)</label>
                                    <input type="number" id="LOVE_GAIN_REST" name="LOVE_GAIN_REST" step="0.1">
                                </div>
                                <div>
                                    <label for="LOVE_LOSS_STRUGGLE">Love Loss (Struggle)</label>
                                    <input type="number" id="LOVE_LOSS_STRUGGLE" name="LOVE_LOSS_STRUGGLE" step="0.1">
                                </div>
                                <div>
                                    <label for="PASSIVE_LOVE_GAIN">Passive Love Gain</label>
                                    <input type="number" id="PASSIVE_LOVE_GAIN" name="PASSIVE_LOVE_GAIN" step="0.01">
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset>
                            <legend>Pause & Apathy</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="PAUSE_ENERGY_THRESHOLD">Pause Energy</label>
                                    <input type="number" id="PAUSE_ENERGY_THRESHOLD" name="PAUSE_ENERGY_THRESHOLD" step="1">
                                </div>
                                <div>
                                    <label for="PAUSE_SOCIAL_THRESHOLD">Pause Social</label>
                                    <input type="number" id="PAUSE_SOCIAL_THRESHOLD" name="PAUSE_SOCIAL_THRESHOLD" step="1">
                                </div>
                                <div>
                                    <label for="APATHY_DURATION">Apathy Duration</label>
                                    <input type="number" id="APATHY_DURATION" name="APATHY_DURATION" step="1">
                                </div>
                                <div>
                                    <label for="APATHY_METABOLISM_PENALTY">Apathy Metabolism</label>
                                    <input type="number" id="APATHY_METABOLISM_PENALTY" name="APATHY_METABOLISM_PENALTY" step="0.1">
                                </div>
                                <div>
                                    <label for="APATHY_SOCIAL_LOSS_MULTIPLIER">Apathy Social Loss</label>
                                    <input type="number" id="APATHY_SOCIAL_LOSS_MULTIPLIER" name="APATHY_SOCIAL_LOSS_MULTIPLIER" step="0.1">
                                </div>
                            </div>
                        </fieldset>

                        <fieldset>
                            <legend>Environment</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="ENV_HEALTH_MAX">Env. Health Max</label>
                                    <input type="number" id="ENV_HEALTH_MAX" name="ENV_HEALTH_MAX" step="0.1">
                                </div>
                                <div>
                                    <label for="ENV_PASSIVE_RECOVERY_RATE">Env. Recovery</label>
                                    <input type="number" id="ENV_PASSIVE_RECOVERY_RATE" name="ENV_PASSIVE_RECOVERY_RATE" step="0.01">
                                </div>
                                <div>
                                    <label for="ENV_DECAY_FOOD_GATHER">Env. Decay (Food)</label>
                                    <input type="number" id="ENV_DECAY_FOOD_GATHER" name="ENV_DECAY_FOOD_GATHER" step="0.01">
                                </div>
                                <div>
                                    <label for="ENV_DECAY_WOOD_GATHER">Env. Decay (Wood)</label>
                                    <input type="number" id="ENV_DECAY_WOOD_GATHER" name="ENV_DECAY_WOOD_GATHER" step="0.01">
                                </div>
                                <div>
                                    <label for="ENV_HEAL_PLANT_BASE">Env. Heal (Plant)</label>
                                    <input type="number" id="ENV_HEAL_PLANT_BASE" name="ENV_HEAL_PLANT_BASE" step="0.1">
                                </div>
                            </div>
                        </fieldset>
                    </div>
                    
                    <div>
                        <fieldset>
                            <legend>Simulation & World</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="SIM_SPEED">Sim Speed (ms)</label>
                                    <input type="number" id="SIM_SPEED" name="SIM_SPEED" step="1">
                                </div>
                                <div>
                                    <label for="WORLD_WIDTH">World Width</label>
                                    <input type="number" id="WORLD_WIDTH" name="WORLD_WIDTH" step="1">
                                </div>
                                <div>
                                    <label for="WORLD_HEIGHT">World Height</label>
                                    <input type="number" id="WORLD_HEIGHT" name="WORLD_HEIGHT" step="1">
                                </div>
                                <div>
                                    <label for="STARTING_AGENTS">Starting Agents</label>
                                    <input type="number" id="STARTING_AGENTS" name="STARTING_AGENTS" step="1">
                                </div>
                                <div>
                                    <label for="STARTING_FOOD">Starting Food</label>
                                    <input type="number" id="STARTING_FOOD" name="STARTING_FOOD" step="1">
                                </div>
                                <div>
                                    <label for="STARTING_WOOD">Starting Wood</label>
                                    <input type="number" id="STARTING_WOOD" name="STARTING_WOOD" step="1">
                                </div>
                                <div>
                                    <label for="MIN_POPULATION_TARGET">Min. Pop. Target</label>
                                    <input type="number" id="MIN_POPULATION_TARGET" name="MIN_POPULATION_TARGET" step="1">
                                </div>
                                <div>
                                    <label for="CRITICAL_FOOD_COUNT">Critical Food</label>
                                    <input type="number" id="CRITICAL_FOOD_COUNT" name="CRITICAL_FOOD_COUNT" step="1">
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset>
                            <legend>Resources & Farming</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="FOOD_SPAWN_RATE">Food Spawn Rate</label>
                                    <input type="number" id="FOOD_SPAWN_RATE" name="FOOD_SPAWN_RATE" step="1">
                                </div>
                                <div>
                                    <label for="WOOD_SPAWN_RATE">Wood Spawn Rate</label>
                                    <input type="number" id="WOOD_SPAWN_RATE" name="WOOD_SPAWN_RATE" step="1">
                                </div>
                                <div>
                                    <label for="FOOD_FRESHNESS">Food Freshness</label>
                                    <input type="number" id="FOOD_FRESHNESS" name="FOOD_FRESHNESS" step="1">
                                </div>
                                <div>
                                    <label for="GROW_TIME">Grow Time (Food)</label>
                                    <input type="number" id="GROW_TIME" name="GROW_TIME" step="1">
                                </div>
                                <div>
                                    <label for="TREE_GROW_TIME">Grow Time (Tree)</label>
                                    <input type="number" id="TREE_GROW_TIME" name="TREE_GROW_TIME" step="1">
                                </div>
                                <div>
                                    <label for="WOOD_SEED_CHANCE">Wood Seed Chance</label>
                                    <input type="number" id="WOOD_SEED_CHANCE" name="WOOD_SEED_CHANCE" step="0.01">
                                </div>
                                <div>
                                    <label for="FOOD_SEED_BASE_CHANCE">Food Seed Chance</label>
                                    <input type="number" id="FOOD_SEED_BASE_CHANCE" name="FOOD_SEED_BASE_CHANCE" step="0.01">
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset>
                            <legend>Structures</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="CAMPFIRE_BURN_TIME">Campfire Burn Time</label>
                                    <input type="number" id="CAMPFIRE_BURN_TIME" name="CAMPFIRE_BURN_TIME" step="1">
                                </div>
                                <div>
                                    <label for="CAMPFIRE_WOOD_COST">Campfire Wood Cost</label>
                                    <input type="number" id="CAMPFIRE_WOOD_COST" name="CAMPFIRE_WOOD_COST" step="1">
                                </div>
                                <div>
                                    <label for="CAMPFIRE_REFUEL_THRESHOLD">Campfire Refuel</label>
                                    <input type="number" id="CAMPFIRE_REFUEL_THRESHOLD" name="CAMPFIRE_REFUEL_THRESHOLD" step="1">
                                </div>
                                <div>
                                    <label for="HOME_DURABILITY_START">Home Durability</label>
                                    <input type="number" id="HOME_DURABILITY_START" name="HOME_DURABILITY_START" step="1">
                                </div>
                                <div>
                                    <label for="HOME_DECAY_RATE">Home Decay Rate</label>
                                    <input type="number" id="HOME_DECAY_RATE" name="HOME_DECAY_RATE" step="1">
                                </div>
                            </div>
                        </fieldset>
                    </div>
                    
                </div>
            </form>
            
            <div class="flex justify-end items-center p-4 bg-gray-900 border-t border-gray-700 rounded-b-lg space-x-4">
                <button id="resetSettingsBtn" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg shadow-md">
                    Reset to Default
                </button>
                <button id="saveSettingsBtn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow-md">
                    Save & Restart
                </button>
            </div>
        </div>
    </div>
    <div class="w-full">
        <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-4">
            <div>
                <h1 class="text-4xl font-bold text-cyan-400">A-Life: Web Simulation</h1>
                <p class="text-gray-400 mb-6">A JavaScript implementation of the Python Life Simulation. See evolution in action!</p>
            </div>
            <button id="openSettingsBtn" class="mb-4 sm:mb-0 px-5 py-2.5 bg-gray-700 hover:bg-gray-600 text-white font-medium rounded-lg shadow-md">
                Settings
            </button>
        </div>

        <div class="flex flex-col lg:grid lg:grid-cols-3 lg:gap-6">

            <div class="order-1 lg:col-span-2 min-w-0"> 
                <div id="canvasWrapper" class="bg-gray-900 p-2 rounded-lg shadow-2xl">
                    <canvas id="worldCanvas"></canvas>
                </div>
            </div>

            <div id="statsPanel" class="mt-6 lg:mt-0 lg:col-span-1 lg:row-start-1 lg:row-span-2 order-2 bg-gray-900 p-6 rounded-lg shadow-2xl font-mono text-xs">
                <div class="mb-4">
                    <p class="text-yellow-400 text-sm">Turn: <span id="turnCounter" class="font-bold text-base">0</span></p>
                    <p class="text-yellow-400 text-sm">Generation: <span id="generationCounter" class="font-bold text-base">0</span></p>
                </div>

                <div class="space-y-4">
                    <h2 class="text-base font-semibold text-cyan-400">Overview</h2>
                    <p>Population: <span id="statPopulation" class="text-white">0</span> | Homes: <span id="statHomes" class="text-white">0</span> | Fires: <span id="statFires" class="text-white">0</span></p>
                    <p class="text-yellow-400 text-sm">Environmental Health: <span id="statEnvHealth" class="font-bold text-base text-green-400">100.0%</span></p>

                    <h2 class="text-base font-semibold text-cyan-400">Average Genes (Evolution)</h2>
                    <div id="geneStats"></div>

                    <h2 class="text-base font-semibold text-cyan-400">Average Skills (Learning)</h2>
                    <div id="skillStats"></div>

                    <h2 class="text-base font-semibold text-cyan-400">Global Knowledge Library</h2>
                    <div id="knowledgeStats"></div>

                    <h2 class="text-base font-semibold text-cyan-400">Death Analysis</h2>
                    <div id="deathStats"></div>
                </div>
            </div>

            <div class="mt-4 p-4 bg-gray-900 rounded-lg text-sm font-mono order-3 lg:col-span-2 lg:mt-0">
                <h2 class="text-lg font-semibold mb-2 text-yellow-300">Legend</h2>
                <div id="legend" class="flex flex-wrap gap-x-6 gap-y-1">
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- CONSTANTS MAPPING FROM PYTHON ---
        // NEW: Refactored constants into objects for settings management
        
        const SETTINGS_STORAGE_KEY = 'aLifeSimSettings';

        // These are the hard-coded defaults
        const defaultSimSettings = {
            ADULT_AGE: 100,
            OLD_AGE: 1500,
            MAX_AGE: 2000,
            
            // Love Parameters
            STARTING_LOVE: 10, 
            LOVE_GAIN_EAT: 2.5,
            LOVE_GAIN_SOCIAL: 5, 
            LOVE_GAIN_REST: 0.5,
            LOVE_LOSS_STRUGGLE: 2.5, 
            PASSIVE_LOVE_GAIN: 0.0,

            // PAUSE THRESHOLDS
            PAUSE_ENERGY_THRESHOLD: 100,
            PAUSE_SOCIAL_THRESHOLD: 80, 

            // Environmental Degradation Constants
            ENV_HEALTH_MAX: 100.0,
            ENV_PASSIVE_RECOVERY_RATE: 0.05,
            ENV_DECAY_FOOD_GATHER: 0.1,   
            ENV_DECAY_WOOD_GATHER: 0.2,   
            ENV_HEAL_PLANT_BASE: 1.0,    

            // Apathy System Constants
            APATHY_DURATION: 50, 
            APATHY_METABOLISM_PENALTY: 0.5,
            APATHY_SOCIAL_LOSS_MULTIPLIER: 2.0,

            // Critical Survival Thresholds
            MIN_POPULATION_TARGET: 16, 
            CRITICAL_FOOD_COUNT: 60, 

            // Simulation Parameters
            WORLD_WIDTH: 70,
            WORLD_HEIGHT: 30,
            STARTING_AGENTS: 15,
            STARTING_FOOD: 120,  
            STARTING_WOOD: 80,  
            SIM_SPEED: 150, // Milliseconds for simulation tick

            // Resources spawn every N turns
            FOOD_SPAWN_RATE: 25, 
            WOOD_SPAWN_RATE: 60, 

            // Farming Parameters
            FOOD_FRESHNESS: 185, 
            GROW_TIME: 10, 

            // Tree Parameters
            TREE_GROW_TIME: 10, 
            WOOD_SEED_CHANCE: 0.5,
            FOOD_SEED_BASE_CHANCE: 0.1, 

            // Campfire Parameters
            CAMPFIRE_BURN_TIME: 300, 
            CAMPFIRE_WOOD_COST: 3, 
            CAMPFIRE_REFUEL_THRESHOLD: 100, 

            // Home Durability
            HOME_DURABILITY_START: 3,
            HOME_DECAY_RATE: 400, 
        };
        
        // This 'let' variable will hold the active settings (either default or loaded from storage)
        let simSettings = {};

        // --- STATIC CONSTANTS (Not configurable by user) ---
        // NEW: Added CRITICAL_ENERGY_THRESHOLD
        const CRITICAL_ENERGY_THRESHOLD = 20;
        
        const PERSONALITY_COOPERATIVE = 1;
        const PERSONALITY_ISOLATED = 2;
        const PERSONALITY_JUDGMENTAL = 3; 
        const PERSONALITY_AGGRESSIVE_COOPERATOR = 4;
        
        // --- NEW: Added PERSONALITY_CONFLICTS ---
        const PERSONALITY_CONFLICTS = {
            [PERSONALITY_JUDGMENTAL]: [PERSONALITY_ISOLATED],
            [PERSONALITY_AGGRESSIVE_COOPERATOR]: [PERSONALITY_JUDGMENTAL]
        };

        const GENE_RANGES = {
            'vision': [3, 10, 0.1],
            'speed': [1, 3, 0.1],
            'metabolism': [0.5, 2.0, 0.1],
            'aggression': [0.0, 0.5, 0.1],
            'builder': [0.0, 1.0, 0.1],
            'mating_drive': [60, 130, 5.0],
            'sociability': [0.0, 1.0, 0.1],
            'farming': [0.0, 1.0, 0.1],
            'personality': [1.0, 4.0, 0.5] 
        };

        const COLORS = {
            CYAN_BRIGHT: '#22d3ee', // A
            CYAN_NORMAL: '#06b6d4', // f
            MAGENTA_BRIGHT: '#d946ef', // m, L (Seek Library)
            MAGENTA_DIM: '#a855f7', // s
            WHITE_BRIGHT: '#ffffff', // T, g, wellbeing
            WHITE_NORMAL: '#f3f4f6', // t
            YELLOW_BRIGHT: '#fcd34d', // b, W
            YELLOW_NORMAL: '#f59e0b', // w, E
            RED_BRIGHT: '#f87171', // X, r, V, R, C
            RED_NORMAL: '#ef4444', // c
            BLUE_BRIGHT: '#60a5fa', // H, C, k
            BLUE_NORMAL: '#3b82f6', // B, h
            BLUE_DIM: '#1d4ed8', // S(remote spot), .
            GREEN_BRIGHT: '#4ade80', // F, G
            GREEN_NORMAL: '#10b981', // p, P
            GREEN_DIM: '#059669', // T (Tree)
            LIBRARY: '#a855f7', // L (Structure)
        };
        
        const CHAR_MAP = {
            'WANDERING': { char: 'A', color: COLORS.CYAN_BRIGHT, dim: false },
            'FORAGING': { char: 'f', color: COLORS.CYAN_NORMAL, dim: false },
            'BUILDING': { char: 'b', color: COLORS.YELLOW_BRIGHT, dim: false },
            'WANDERING_TO_BUILD': { char: 'B', color: COLORS.BLUE_NORMAL, dim: false },
            'SEEKING_COMMUNITY': { char: 'C', color: COLORS.BLUE_BRIGHT, dim: false },
            'SEEKING_REMOTE_SPOT': { char: 'S', color: COLORS.BLUE_DIM, dim: true },
            'GETTING_WOOD': { char: 'w', color: COLORS.YELLOW_NORMAL, dim: false },
            'PLANTING': { char: 'p', color: COLORS.GREEN_NORMAL, dim: false },
            'PLANTING_WOOD': { char: 'p', color: COLORS.GREEN_NORMAL, dim: false },
            'GOING_HOME_TO_FARM': { char: 'G', color: COLORS.GREEN_BRIGHT, dim: false },
            'GOING_HOME_TO_PLANT_WOOD': { char: 'G', color: COLORS.GREEN_BRIGHT, dim: false },
            'SHARING': { char: 'g', color: COLORS.WHITE_BRIGHT, dim: false },
            'BUILDING_CAMPFIRE': { char: 'c', color: COLORS.RED_NORMAL, dim: false },
            'REPAIRING_HOME': { char: 'E', color: COLORS.YELLOW_NORMAL, dim: false },
            'CLAIMING_HOME': { char: 'k', color: COLORS.BLUE_BRIGHT, dim: false },
            'REFUELING_CAMPFIRE': { char: 'R', color: COLORS.RED_BRIGHT, dim: false },
            'MATING': { char: 'm', color: COLORS.MAGENTA_BRIGHT, dim: false },
            'ATTACKING': { char: 'X', color: COLORS.RED_BRIGHT, dim: false },
            'FLEEING_FOR_FOOD': { char: 'f', color: COLORS.RED_BRIGHT, dim: false }, // <-- NEW
            'RETALIATING': { char: 'r', color: COLORS.RED_BRIGHT, dim: false },
            'AVENGING': { char: 'V', color: COLORS.RED_BRIGHT, dim: false },
            'SEEKING_SOCIAL': { char: 't', color: COLORS.WHITE_NORMAL, dim: false },
            'COMMUNICATING': { char: 'T', color: COLORS.WHITE_BRIGHT, dim: false },
            'SEEKING_LIBRARY': { char: 'L', color: COLORS.MAGENTA_BRIGHT, dim: false },
            'SOCIAL_SAD': { char: 's', color: COLORS.MAGENTA_DIM, dim: true },
            'SOCIAL_HAPPY': { char: 'o', color: COLORS.MAGENTA_BRIGHT, dim: false },
        };

        // --- HELPERS ---

        function clamp(value, minVal, maxVal) {
            return Math.max(minVal, Math.min(value, maxVal));
        }

        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }
        
        function arrayToKey(arr) {
            return `${arr[0]},${arr[1]}`;
        }
        
        function keyToArray(key) {
            return key.split(',').map(Number);
        }

        // --- AGENT CLASS ---

        class Agent {
            constructor(x, y, world, genes = null) {
                this.world = world;
                this.x = x;
                this.y = y;
                this.char = 'A';
                this.id = this.world.getNextAgentId();
                this.energy = 150;
                this.wood_carried = 0;
                this.food_carried = 0;
                this.mate_cooldown = 0;
                this.seeds_carried = Math.floor(Math.random() * 3);
                this.wood_seeds_carried = Math.floor(Math.random() * 2);
                this.social = Math.random() * (80.0 - 30.0) + 30.0;
                this.home_location = null;
                this.campfire_location = null;
                this.social_buff_timer = 0;
                this.contentment_buff_timer = 0;
                this.apathy_timer = 0; 
                this.state = "WANDERING";
                this.exploration_vector = [0, 0];
                this.memory = { 'food': new Set(), 'wood': new Set() };
                this.struggle_timer = 0;
                this.was_attacked_by = null;
                
                this.avenging_target_id = null; 
                this.unpleasant_agents = new Set(); // <-- NEW
                
                this.age = 0;
                this.children_ids = new Set();
                
                this.parent_ids = new Set(); 
                
                this.love = simSettings.STARTING_LOVE;
                this.skills = {
                    'foraging': 0.0, 'social': 0.0, 'building': 0.0,
                    'navigation': 0.0, 'combat': 0.0, 'farming': 0.0
                };

                if (genes) {
                    this.genes = genes;
                } else {
                    this.genes = this.createRandomGenes(this.world.agents.length < simSettings.STARTING_AGENTS);
                }
            }

            createRandomGenes(stabilize = false) {
                const genes = {};
                for (const gene in GENE_RANGES) {
                    const [minVal, maxVal] = GENE_RANGES[gene];
                    if (stabilize) {
                        if (gene === 'metabolism') {
                            genes[gene] = Math.random() * (0.8 - 0.5) + 0.5;
                        } else if (gene === 'speed') {
                            genes[gene] = Math.random() * (3.0 - 1.0) + 1.0;
                        } else if (gene === 'personality') {
                            if (Math.random() < 0.8) {
                                genes[gene] = Math.floor(Math.random() * (PERSONALITY_ISOLATED - PERSONALITY_COOPERATIVE + 1)) + PERSONALITY_COOPERATIVE;
                            } else {
                                genes[gene] = Math.floor(Math.random() * (PERSONALITY_AGGRESSIVE_COOPERATOR - PERSONALITY_JUDGMENTAL + 1)) + PERSONALITY_JUDGMENTAL;
                            }
                        } else {
                            genes[gene] = Math.random() * (maxVal - minVal) + minVal;
                        }
                    } else {
                        genes[gene] = Math.random() * (maxVal - minVal) + minVal;
                    }
                }
                return genes;
            }

            getPersonality() {
                return Math.floor(clamp(this.genes.personality || 1, 1, 4));
            }

            update() {
                this.age += 1;
                
                if (this.age >= simSettings.OLD_AGE && this.energy < 100) { 
                    this.die('NATURAL_DEATH_OLD');
                    return;
                }
                
                if (this.age >= simSettings.MAX_AGE) {
                    this.die('MAX_AGE');
                    return;
                }

                let metabolismCost = this.genes['metabolism'];
                let livingChildrenUnderAge = 0;

                for (const childId of Array.from(this.children_ids)) {
                    const child = this.world.getAgentById(childId);
                    if (child) {
                        if (child.age < simSettings.ADULT_AGE) {
                            livingChildrenUnderAge++;
                        } else {
                            this.children_ids.delete(childId);
                        }
                    } else {
                        this.children_ids.delete(childId);
                    }
                }

                const parentalCost = livingChildrenUnderAge * 0.2;

                if (this.age < simSettings.ADULT_AGE) {
                    metabolismCost = parentalCost;
                    if (this.energy < 50) { 
                        this.die('STARVATION_CHILD');
                        return;
                    }
                } else {
                    metabolismCost += parentalCost;
                }

                const currentPosKey = arrayToKey([this.x, this.y]);
                if (this.world.homes[currentPosKey]) {
                    const homeData = this.world.homes[currentPosKey];
                    const ownerId = homeData.owner_id;
                    const isOwner = (this.id === ownerId);
                    let isFamily = false;

                    if (ownerId !== null) {
                        const ownerAgent = this.world.getAgentById(ownerId);
                        if (ownerAgent && ownerAgent.children_ids.has(this.id)) {
                            isFamily = true;
                        }
                    }

                    if (isOwner || isFamily) {
                        metabolismCost *= 0.5;
                        if (this.energy < 150) {
                            this.energy = clamp(this.energy + 2.0, 0, 150);
                        }
                        this.social = clamp(this.social + 0.5, 0, 100);
                    }
                }

                if (this.campfire_location && !this.world.campfires[this.campfire_location]) {
                    this.campfire_location = null;
                }

                const nearbyCampfirePosKey = this.world.getNearest(this.x, this.y, 2, this.world.campfires);
                if (nearbyCampfirePosKey) {
                    metabolismCost *= 0.9;
                    this.social = clamp(this.social + 0.5, 0, 100);
                }

                if (this.social_buff_timer > 0) {
                    metabolismCost *= 0.8;
                    this.social_buff_timer--;
                }
                
                if (this.apathy_timer > 0) {
                    metabolismCost += simSettings.APATHY_METABOLISM_PENALTY; 
                    this.apathy_timer--;
                }

                this.energy -= metabolismCost;
                if (this.mate_cooldown > 0) {
                    this.mate_cooldown--;
                }
                
                let socialLossMultiplier = 1.0;
                if (this.apathy_timer > 0) {
                    socialLossMultiplier = simSettings.APATHY_SOCIAL_LOSS_MULTIPLIER; 
                }

                if (this.contentment_buff_timer > 0) {
                    this.contentment_buff_timer--;
                } else {
                    const visionRadius = Math.floor(this.genes['vision']);
                    const nearbyAgents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                    if (nearbyAgents.length === 0 && !nearbyCampfirePosKey) { 
                        this.social -= this.genes['sociability'] * 0.5 * socialLossMultiplier;
                    } else {
                        this.social += 0.1;
                    }
                    this.social = clamp(this.social, 0, 100);
                }

                if (this.energy < 30 || this.social < 20) {
                    this.struggle_timer++;
                    this.love = clamp(this.love - simSettings.LOVE_LOSS_STRUGGLE, 0, simSettings.STARTING_LOVE);
                } else {
                    this.struggle_timer = 0;
                }

                if (this.love <= 0 && this.apathy_timer === 0) {
                    this.apathy_timer = simSettings.APATHY_DURATION;
                }
                
                for (const skillKey in this.skills) {
                    const globalValue = this.world.globalSkillKnowledge[skillKey] || 0.0;
                    const currentSkill = this.skills[skillKey];
                    if (currentSkill < globalValue) {
                        this.skills[skillKey] = clamp(currentSkill + 0.0001, 0, 10.0); 
                    }
                }

                if (this.energy <= 0) {
                    this.die('STARVATION_ADULT');
                    return;
                }

                this.decideState();
                this.executeAction();
            }

            // --- THIS FUNCTION HAS BEEN MODIFIED ---
            decideState() {
                const visionRadius = Math.floor(this.genes['vision']);
                const foodInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.food);
                
                // --- NEW: CRITICAL SELF-PRESERVATION TRIAGE ---
                if (this.energy < CRITICAL_ENERGY_THRESHOLD) {
                    if (this.food_carried > 0) {
                        this.state = "FORAGING"; // Will consume food
                        return;
                    }
                    
                    if (foodInSight.length > 0) {
                        this.state = "FLEEING_FOR_FOOD";
                        return;
                    } else if (this.memory.food.size > 0) {
                        this.state = "FLEEING_FOR_FOOD";
                        return;
                    } else {
                        this.state = "SOCIAL_SAD"; // Hopeless
                        return;
                    }
                }
                // --- END NEW ---
                
                const conserveEnergy = this.genes['metabolism'] < 0.8 && this.energy < 100;

                const globalFoodCrisis = Object.keys(this.world.food).length < simSettings.CRITICAL_FOOD_COUNT;
                const populationLow = this.world.agents.length < simSettings.MIN_POPULATION_TARGET;
                
                if (this.avenging_target_id !== null) {
                    const target = this.world.getAgentById(this.avenging_target_id);
                    if (target) {
                        this.state = "AVENGING";
                        return;
                    } else {
                        this.avenging_target_id = null;
                    }
                }
                
                if (this.was_attacked_by !== null) {
                    this.state = "RETALIATING"; 
                    return;
                }

                if ((this.energy < 20 || this.social < 10) && foodInSight.length === 0 && this.memory.food.size === 0) {
                    this.state = "SOCIAL_SAD"; 
                    return;
                }
                
                // Mandate 1: Plant if Food Crisis or Low Population, AND I have seeds
                if ((globalFoodCrisis || populationLow) && this.seeds_carried > 0) {
                    if (this.home_location) {
                        const [hx, hy] = keyToArray(this.home_location);
                        const dist = getDistance(this.x, this.y, hx, hy);
                        if (dist > 5) { 
                            this.state = "GOING_HOME_TO_FARM"; 
                        } else {
                            this.state = "PLANTING"; 
                        }
                    } else {
                        this.state = "PLANTING"; 
                    }
                    return;
                }

                // Mandate 2: Share if others are desperately needy
                if (this.energy > 100 && this.social > 50 && (this.wood_carried > 3 || this.food_carried >= 1)) {
                    const nearbyAgents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                    const needyAgents = nearbyAgents.filter(a => a.energy < 40 && a.food_carried < 1); 
                    if (needyAgents.length > 0) {
                        this.state = "SHARING"; 
                        return;
                    }
                }

                // Priority 1: Survival (Energy)
                let forageThreshold = 70;
                if (this.age < simSettings.ADULT_AGE) forageThreshold = 100;

                if (this.energy < forageThreshold || (this.food_carried > 0 && this.energy < 150)) {
                    this.state = "FORAGING";
                    return;
                }
                
                // Priority 1.5: Campfire Refuel
                const nearbyCampfirePosKey = this.world.getNearest(this.x, this.y, visionRadius, this.world.campfires);
                if (nearbyCampfirePosKey) {
                    const campfireTimer = this.world.campfires[nearbyCampfirePosKey];
                    if (campfireTimer < simSettings.CAMPFIRE_REFUEL_THRESHOLD) {
                        if (this.wood_carried < 1) {
                            this.state = "GETTING_WOOD";
                            return;
                        } else {
                            this.state = "REFUELING_CAMPFIRE";
                            return;
                        }
                    }
                }

                // Priority 2: Home Repair
                if (this.home_location) {
                    const homeData = this.world.homes[this.home_location];
                    const isOwner = homeData && homeData.owner_id === this.id;
                    if (homeData && homeData.durability < simSettings.HOME_DURABILITY_START && isOwner) { 
                        if (this.wood_carried < 1) {
                            this.state = "GETTING_WOOD";
                            return;
                        } else {
                            this.state = "REPAIRING_HOME";
                            return;
                        }
                    }
                }
                
                // Priority 3: Social Need
                if (this.social < 60 && this.genes['sociability'] > 0.2) {
                    this.state = "SEEKING_SOCIAL"; 
                    return;
                }
                
                // Priority 4: Claim or Build Home
                if (this.home_location === null) {
                    const emptyHomePos = this.world.getEmptyHome();
                    if (emptyHomePos) {
                        this.state = "CLAIMING_HOME";
                        return;
                    }
                    
                    if ((Object.keys(this.world.homes).length < this.world.agents.length) && (this.genes['builder'] > Math.random())) {
                        if (conserveEnergy) {
                            this.state = "FORAGING";
                            return;
                        }
                        
                        let woodCostNeeded = Math.max(1, simSettings.CAMPFIRE_WOOD_COST - Math.floor(this.skills['building'] * 0.5));
                        
                        if (this.wood_carried < woodCostNeeded) {
                            this.state = "GETTING_WOOD";
                            return;
                        }

                        const communityRadius = visionRadius + 5; 
                        const nearbyHomes = this.world.getNearestInSet(this.x, this.y, communityRadius, this.world.homes);
                        const isSocial = this.genes['sociability'] > 0.5;
                        
                        if (this.isClearTile(this.x, this.y)) {
                            if (isSocial) {
                                if (nearbyHomes.length > 0 || Object.keys(this.world.homes).length === 0) {
                                    this.state = "BUILDING";
                                } else {
                                    this.state = "SEEKING_COMMUNITY";
                                }
                            } else {
                                if (nearbyHomes.length === 0) {
                                    this.state = "BUILDING";
                                } else {
                                    this.state = "SEEKING_REMOTE_SPOT";
                                }
                            }
                        } else {
                            if (isSocial) {
                                if (nearbyHomes.length > 0 || Object.keys(this.world.homes).length === 0) {
                                    this.state = "WANDERING_TO_BUILD"; 
                                } else {
                                    this.state = "SEEKING_COMMUNITY"; 
                                }
                            } else {
                                if (nearbyHomes.length === 0) {
                                    this.state = "WANDERING_TO_BUILD";
                                } else {
                                    this.state = "SEEKING_REMOTE_SPOT"; 
                                }
                            }
                        }
                        return;
                    }
                }
                
                // Priority 5: Farming (Food Seeds) - Normal Planting
                if (this.seeds_carried > 0 && this.energy > 80 && this.genes['farming'] > Math.random()) {
                    if (this.home_location) {
                        const [hx, hy] = keyToArray(this.home_location);
                        const dist = getDistance(this.x, this.y, hx, hy);
                        if (dist > 5) { 
                            this.state = "GOING_HOME_TO_FARM"; 
                        } else {
                            this.state = "PLANTING"; 
                        }
                    } else {
                        this.state = "PLANTING"; 
                    }
                    return;
                }

                // Priority 5.5: Planting Trees
                if (this.wood_seeds_carried > 0 && this.energy > 80 &&
                    (Object.keys(this.world.wood).length < simSettings.STARTING_WOOD) && (this.genes['builder'] > Math.random())) { 
                    
                    if (this.home_location) {
                        const [hx, hy] = keyToArray(this.home_location);
                        const dist = getDistance(this.x, this.y, hx, hy);
                        if (dist > 5) {
                            this.state = "GOING_HOME_TO_PLANT_WOOD"; 
                        } else {
                            this.state = "PLANTING_WOOD";
                        }
                    } else {
                        this.state = "PLANTING_WOOD";
                    }
                    return;
                }
                    
                // Priority 6: Build Campfire
                const nearbyActiveFire = this.world.getNearest(this.x, this.y, 5, this.world.campfires);

                if (this.energy > 120 && this.social > 50 && 
                    this.genes['builder'] > 0.5 && 
                    nearbyActiveFire === null) { 
                    if (conserveEnergy) {
                        this.state = "FORAGING";
                        return;
                    }

                    let woodCostNeeded = Math.max(1, simSettings.CAMPFIRE_WOOD_COST - Math.floor(this.skills['building'] * 0.5));
                    
                    if (this.wood_carried >= woodCostNeeded) {
                         this.state = "BUILDING_CAMPFIRE";
                         return;
                    } else if (this.wood_carried < woodCostNeeded) {
                         this.state = "GETTING_WOOD";
                         return;
                    }
                }
                
                // Priority 7: Share Resources (Standard)
                if (this.energy > 100 && this.social > 50 && (this.wood_carried > 3 || this.food_carried >= 1)) {
                    const nearbyAgents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                    const needyAgents = nearbyAgents.filter(a => a.energy < 70 && a.food_carried < 1); 
                    if (needyAgents.length > 0) {
                        this.state = "SHARING"; 
                        return;
                    }
                }
                
                // Priority 8: Default
                this.state = "WANDERING";
            }

            // --- THIS FUNCTION HAS BEEN MODIFIED ---
            executeAction() {
                const visionRadius = Math.floor(this.genes['vision']);
                const foodInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.food);
                const woodInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.wood);
                const agents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);

                const bestFoodTarget = this.getClosestCombinedTarget('food', foodInSight);
                const bestWoodTarget = this.getClosestCombinedTarget('wood', woodInSight);

                const agentsOnTile = this.world.agents.filter(a => a.x === this.x && a.y === this.y && a !== this);
                if (agentsOnTile.length > 0) {
                    const target = agentsOnTile[Math.floor(Math.random() * agentsOnTile.length)];
                    
                    const baseAggression = this.genes['aggression'];
                    const struggleBonus = Math.min(this.struggle_timer * 0.0005, 0.5); 
                    const dynamicAggression = baseAggression + struggleBonus;
                    
                    if (this.love <= 0 && this.energy > 80 && Math.random() < dynamicAggression) {
                        this.attack(target);
                        return; 
                    }
                }
                
                switch (this.state) {
                    case "FORAGING":
                        const currentPosKey = arrayToKey([this.x, this.y]);
                        if (this.food_carried > 0 && this.energy < 150) { 
                            
                            const needyNeighbors = agents.filter(a => a.energy < 40 && a.food_carried < 1);
                            
                            if (needyNeighbors.length === 0) {
                                this.consumeFood();
                            } else {
                                this.state = "SHARING";
                                return;
                            }
                            
                        } else if (this.world.food[currentPosKey] && this.food_carried < 2) { 
                            this.pickupFood();
                        } else if (bestFoodTarget) { 
                            this.moveTowards(bestFoodTarget[0], bestFoodTarget[1]);
                            if (getDistance(this.x, this.y, bestFoodTarget[0], bestFoodTarget[1]) < 2.0 && !this.world.food[arrayToKey(bestFoodTarget)]) {
                                this.memory.food.delete(arrayToKey(bestFoodTarget));
                            }
                        } else {
                            this.moveExploring(); 
                        }
                        break;
                    
                    // --- NEW CASE ---
                    case "FLEEING_FOR_FOOD":
                        const currentFoodPosKey_Flee = arrayToKey([this.x, this.y]);
                        if (this.world.food[currentFoodPosKey_Flee] && this.food_carried < 2) {
                            this.pickupFood();
                        } else if (bestFoodTarget) {
                            this.moveTowards(bestFoodTarget[0], bestFoodTarget[1]);
                            if (getDistance(this.x, this.y, bestFoodTarget[0], bestFoodTarget[1]) < 2.0 && !this.world.food[arrayToKey(bestFoodTarget)]) {
                                this.memory.food.delete(arrayToKey(bestFoodTarget));
                            }
                        } else {
                            this.moveExploring(); // Panic search
                        }
                        break;
                    // --- END NEW CASE ---

                    case "GETTING_WOOD":
                        const currentWoodPosKey = arrayToKey([this.x, this.y]);
                        if (this.wood_carried >= 3) { 
                            this.state = "WANDERING";
                            return;
                        }
                        if (this.world.wood[currentWoodPosKey] && this.wood_carried < 3) {
                            this.takeWood();
                        } else if (bestWoodTarget) { 
                            this.moveTowards(bestWoodTarget[0], bestWoodTarget[1]);
                            if (getDistance(this.x, this.y, bestWoodTarget[0], bestWoodTarget[1]) < 2.0 && !this.world.wood[arrayToKey(bestWoodTarget)]) {
                                this.memory.wood.delete(arrayToKey(bestWoodTarget));
                            }
                        } else {
                            this.moveExploring();
                        }
                        break;

                    case "BUILDING":
                        this.buildHome();
                        break;

                    case "REPAIRING_HOME":
                        if (this.home_location) {
                            const [hx, hy] = keyToArray(this.home_location);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist < 2.0) {
                                if (this.wood_carried > 0) {
                                    this.world.homes[this.home_location].durability = simSettings.HOME_DURABILITY_START;
                                    this.wood_carried--;
                                    this.skills.building = clamp(this.skills.building + 0.2, 0, 4.0);
                                    this.state = "WANDERING";
                                } else {
                                    this.state = "GETTING_WOOD";
                                }
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "REFUELING_CAMPFIRE":
                        const nearbyCampfireKey = this.world.getNearest(this.x, this.y, visionRadius, this.world.campfires);
                        if (nearbyCampfireKey) {
                            const [cx, cy] = keyToArray(nearbyCampfireKey);
                            const dist = getDistance(this.x, this.y, cx, cy);
                            if (dist < 2.0) {
                                if (this.wood_carried > 0) {
                                    this.world.campfires[nearbyCampfireKey] = simSettings.CAMPFIRE_BURN_TIME;
                                    this.wood_carried--;
                                    this.state = "WANDERING";
                                } else {
                                    this.state = "GETTING_WOOD";
                                }
                            } else {
                                this.moveTowards(cx, cy);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "CLAIMING_HOME":
                        const emptyHomePos = this.world.getEmptyHome();
                        if (emptyHomePos) {
                            const [hx, hy] = keyToArray(emptyHomePos);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist < 2.0) {
                                this.world.homes[emptyHomePos].owner_id = this.id;
                                this.home_location = emptyHomePos;
                                this.state = "WANDERING";
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "WANDERING_TO_BUILD":
                        this.moveRandomly(0.5, 0.0);
                        break;

                    case "SEEKING_COMMUNITY":
                        const allHomes = this.world.getNearestInSet(this.x, this.y, 999, this.world.homes); 
                        if (allHomes.length > 0) {
                            const [hx, hy] = keyToArray(allHomes[0]);
                            this.moveTowards(hx, hy);
                        } else {
                            this.moveExploring();
                        }
                        break;

                    case "SEEKING_REMOTE_SPOT":
                        this.moveExploring();
                        break;
                    
                    case "GOING_HOME_TO_FARM":
                        if (this.home_location) {
                            const [hx, hy] = keyToArray(this.home_location);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist <= 5.0) {
                                this.state = "PLANTING";
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "PLANTING";
                        }
                        break;

                    case "PLANTING":
                        if (this.isClearTile(this.x, this.y)) {
                            this.plantSeed();
                        } else {
                            this.moveRandomly(0.5, 0.0);
                        }
                        break;

                    case "GOING_HOME_TO_PLANT_WOOD":
                        if (this.home_location) {
                            const [hx, hy] = keyToArray(this.home_location);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist <= 5.0) {
                                this.state = "PLANTING_WOOD";
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "PLANTING_WOOD";
                        }
                        break;

                    case "PLANTING_WOOD":
                        if (this.isClearTile(this.x, this.y)) {
                            this.plantTree();
                        } else {
                            this.moveRandomly(0.5, 0.0);
                        }
                        break;
                        
                    case "BUILDING_CAMPFIRE":
                        if (this.isClearTile(this.x, this.y)) {
                            this.buildCampfire();
                        } else {
                            this.moveRandomly(0.5, 0.0);
                        }
                        break;

                    case "SHARING":
                        const nearbyAgents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                        let needyAgents = nearbyAgents.filter(a => a.energy < 40 && a.food_carried < 1); 
                        
                        if (needyAgents.length === 0) {
                             needyAgents = nearbyAgents.filter(a => a.energy < 70 && a.food_carried < 1); 
                        }

                        if (needyAgents.length > 0) {
                            const target = needyAgents[0];
                            if (getDistance(this.x, this.y, target.x, target.y) < 2.0) {
                                if (this.food_carried >= 1) {
                                    this.food_carried--;
                                    target.food_carried++;
                                    this.state = "WANDERING"; 
                                } else if (this.wood_carried >= 1) {
                                    this.wood_carried--;
                                    target.wood_carried++;
                                    this.state = "WANDERING";
                                } else {
                                     this.state = "WANDERING";
                                }
                            } else {
                                this.moveTowards(target.x, target.y);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "RETALIATING":
                        // --- NEW ---
                        if (this.energy < CRITICAL_ENERGY_THRESHOLD) {
                            this.state = "FORAGING";
                            this.was_attacked_by = null;
                            return;
                        }
                        // --- END NEW ---
                    
                        const attacker = this.world.getAgentById(this.was_attacked_by);
                        if (attacker) {
                            const dist = getDistance(this.x, this.y, attacker.x, attacker.y);
                            if (dist < 2.0) {
                                this.attack(attacker);
                                this.was_attacked_by = null;
                            } else {
                                this.moveTowards(attacker.x, attacker.y);
                            }
                        } else {
                            this.was_attacked_by = null;
                            this.state = "WANDERING";
                        }
                        break;
                    
                    case "AVENGING":
                        // --- NEW ---
                        if (this.energy < CRITICAL_ENERGY_THRESHOLD) {
                            this.state = "FORAGING"; // Vengeance can wait
                            return; // Don't clear target, will resume when healthy
                        }
                        // --- END NEW ---
                    
                        const targetParent = this.world.getAgentById(this.avenging_target_id);
                        if (targetParent) {
                            const dist = getDistance(this.x, this.y, targetParent.x, targetParent.y);
                            if (dist < 2.0) {
                                this.attack(targetParent);
                            } else {
                                this.moveTowards(targetParent.x, targetParent.y);
                            }
                        } else {
                            this.avenging_target_id = null;
                            this.state = "WANDERING";
                        }
                        break;
                    
                    case "SEEKING_SOCIAL":
                        const nearbyCampfire = this.world.getNearest(this.x, this.y, visionRadius, this.world.campfires);
                        
                        let targetAgent = null;
                        
                        // --- NEW: Filter unpleasant agents ---
                        const pleasant_agents = agents.filter(a => !this.unpleasant_agents.has(a.id));
                        // --- END NEW ---
                        
                        const happyAgents = this.world.getNearestAgents(this.x, this.y, 3, this);
                        const happyAndPausing = happyAgents.filter(
                            a => a.energy > simSettings.PAUSE_ENERGY_THRESHOLD && a.social > simSettings.PAUSE_SOCIAL_THRESHOLD
                        );
                        
                        if (happyAndPausing.length > 0) {
                            happyAndPausing.sort((a, b) => b.social - a.social);
                            targetAgent = happyAndPausing[0];
                        }
                        // --- MODIFIED: Use pleasant_agents ---
                        else if (pleasant_agents.length > 0) {
                            targetAgent = pleasant_agents[0];
                        }
                        // --- END MODIFIED ---
                            
                        if (targetAgent) {
                            if (getDistance(this.x, this.y, targetAgent.x, targetAgent.y) < 2.0) {
                                this.communicate(targetAgent);
                            } else {
                                this.moveTowards(targetAgent.x, targetAgent.y);
                            }
                        } else if (nearbyCampfire) {
                            const [cx, cy] = keyToArray(nearbyCampfire);
                            this.moveTowards(cx, cy);
                        } else {
                            this.moveExploring(); 
                        }
                        break;
                    
                    case "SOCIAL_HAPPY": 
                        if (this.energy > simSettings.PAUSE_ENERGY_THRESHOLD && this.social > simSettings.PAUSE_SOCIAL_THRESHOLD) {
                            
                            if (Math.random() < 0.2) { 
                                const [lx, ly] = this.world.libraryLocation;
                                if (getDistance(this.x, this.y, lx, ly) > 5.0) {
                                    this.moveTowards(lx, ly);
                                    this.state = "SEEKING_LIBRARY"; 
                                    return;
                                }
                            }
                        } else {
                            this.moveRandomly(0.5, 0.0); 
                        }
                        break; 
                    
                    case "SEEKING_LIBRARY":
                        this.skills.navigation = clamp(this.skills.navigation + 0.01, 0, 5.0); 
                        
                        const [lx, ly] = this.world.libraryLocation;
                        if (getDistance(this.x, this.y, lx, ly) < 2.0) {
                            this.skills.social = clamp(this.skills.social + 0.1, 0, 10.0);
                            this.state = "WANDERING";
                        } else {
                            this.moveTowards(lx, ly);
                        }
                        break;

                    case "SOCIAL_SAD":
                        this.love = clamp(this.love + simSettings.LOVE_GAIN_REST, 0, simSettings.STARTING_LOVE);
                        if (this.energy < 20 && bestFoodTarget) {
                            this.moveTowards(bestFoodTarget[0], bestFoodTarget[1]);
                        } else if (this.social < 10) {
                            const nearestCampfireSad = this.world.getNearest(this.x, this.y, visionRadius, this.world.campfires);
                            if (agents.length > 0) {
                                this.moveTowards(agents[0].x, agents[0].y);
                            } else if (nearestCampfireSad) {
                                const [cx, cy] = keyToArray(nearestCampfireSad);
                                this.moveTowards(cx, cy);
                            } else {
                                this.moveExploring();
                            }
                        } else {
                            this.moveExploring();
                        }
                        break;

                    case "WANDERING":
                        if (this.energy > simSettings.PAUSE_ENERGY_THRESHOLD && this.social > simSettings.PAUSE_SOCIAL_THRESHOLD) {
                            
                            const [lx, ly] = this.world.libraryLocation;
                            if (Math.random() < 0.2 && getDistance(this.x, this.y, lx, ly) > 5.0) { 
                                this.state = "SEEKING_LIBRARY"; 
                                return;
                            }
                        } else {
                            foodInSight.forEach(posKey => this.memory.food.add(posKey));
                            woodInSight.forEach(posKey => this.memory.wood.add(posKey));
                            this.moveExploring();
                        }
                        
                        // --- NEW: Opportunistic Gathering ---
                        const currentPosKey_Wander = arrayToKey([this.x, this.y]);
                        if (this.world.food[currentPosKey_Wander] && this.food_carried < 2) {
                            this.pickupFood();
                        } else if (this.world.wood[currentPosKey_Wander] && this.wood_carried < 3) {
                            this.takeWood();
                        }
                        // --- END NEW ---
                        break;
                    
                    case "MATING":
                    case "COMMUNICATING":
                        break;
                }
            }

            isClearTile(x, y) {
                const posKey = arrayToKey([x, y]);
                if (posKey === arrayToKey(this.world.libraryLocation)) {
                    return false;
                }
                if (this.world.homes[posKey]) return false;
                if (this.world.food[posKey]) return false;
                if (this.world.wood[posKey]) return false;
                if (this.world.growingPlants[posKey]) return false;
                if (this.world.growingTrees[posKey]) return false;
                if (this.world.campfires[posKey]) return false;
                return true;
            }

            moveTowards(targetX, targetY) {
                this.exploration_vector = [0, 0];
                let steps = Math.floor(this.genes['speed']);
                if (steps < 1) steps = 1;
                
                for (let i = 0; i < steps; i++) {
                    let dx = 0, dy = 0;
                    if (this.x < targetX) dx = 1;
                    else if (this.x > targetX) dx = -1;
                    if (this.y < targetY) dy = 1;
                    else if (this.y > targetY) dy = -1;
                    
                    this.x = clamp(this.x + dx, 0, this.world.width - 1);
                    this.y = clamp(this.y + dy, 0, this.world.height - 1);
                    
                    this.skills.navigation = clamp(this.skills.navigation + 0.01, 0, 5.0); 
                    const costMultiplier = 1.0 - (this.skills.navigation * 0.15); 
                    const finalMultiplier = Math.max(0.25, costMultiplier);
                    
                    this.energy -= (0.05) * finalMultiplier; 
                }
            }

            moveRandomly(speedFactor, persistentChance) {
                let steps = Math.floor(this.genes['speed'] * speedFactor);
                if (steps < 1) steps = 1;

                for (let i = 0; i < steps; i++) {
                    let stuck = false;
                    if (this.exploration_vector[0] !== 0 || this.exploration_vector[1] !== 0) {
                        const newX = clamp(this.x + this.exploration_vector[0], 0, this.world.width - 1);
                        const newY = clamp(this.y + this.exploration_vector[1], 0, this.world.height - 1);
                        if (newX === this.x && newY === this.y) {
                            stuck = true; 
                        }
                    }

                    if (this.exploration_vector[0] === 0 && this.exploration_vector[1] === 0 || stuck || Math.random() > persistentChance) {
                        while (true) { 
                            this.exploration_vector = [Math.floor(Math.random() * 3) - 1, Math.floor(Math.random() * 3) - 1];
                            if (this.exploration_vector[0] !== 0 || this.exploration_vector[1] !== 0) {
                                break;
                            }
                        }
                    }
                    
                    const [dx, dy] = this.exploration_vector;
                    this.x = clamp(this.x + dx, 0, this.world.width - 1);
                    this.y = clamp(this.y + dy, 0, this.world.height - 1);
                    
                    this.skills.navigation = clamp(this.skills.navigation + 0.01, 0, 5.0); 
                    const costMultiplier = 1.0 - (this.skills.navigation * 0.15); 
                    const finalMultiplier = Math.max(0.25, costMultiplier);
                    
                    this.energy -= (0.05) * finalMultiplier;
                }
            }

            moveExploring() {
                this.moveRandomly(1.0, 0.8);
            }

            getClosestCombinedTarget(resourceType, visibleResources) {
                const possibleTargets = new Set();
                
                visibleResources.forEach(posKey => possibleTargets.add(posKey));
                this.memory[resourceType].forEach(posKey => possibleTargets.add(posKey));
                
                if (possibleTargets.size === 0) return null;
                    
                let nearestItem = null;
                let minDist = Infinity;
                
                for (const posKey of possibleTargets) {
                    const [ix, iy] = keyToArray(posKey);
                    const dist = getDistance(this.x, this.y, ix, iy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestItem = [ix, iy];
                    }
                }
                return nearestItem;
            }

            consumeFood() {
                if (this.food_carried > 0) {
                    this.food_carried--;
                    this.skills.foraging = clamp(this.skills.foraging + 0.1, 0, 10.0); 
                    const energyGain = 120 + (this.skills.foraging * 20); 
                    this.energy += energyGain;
                    this.love = clamp(this.love + simSettings.LOVE_GAIN_EAT, 0, simSettings.STARTING_LOVE);
                    
                    const decayAmount = simSettings.ENV_DECAY_FOOD_GATHER * (1.0 - (this.skills.foraging / 10.0));
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth - decayAmount, 0, simSettings.ENV_HEALTH_MAX);

                    const foragingChance = simSettings.FOOD_SEED_BASE_CHANCE + (this.skills.foraging * 0.05);
                    if (Math.random() < foragingChance) {
                        this.seeds_carried++;
                    }

                    this.state = "WANDERING";
                }
            }

            pickupFood() {
                const posKey = arrayToKey([this.x, this.y]);
                if (this.world.food[posKey] && this.food_carried < 2) {
                    delete this.world.food[posKey];
                    delete this.world.foodFreshness[posKey];
                    this.food_carried++;
                    this.memory.food.delete(posKey);
                    this.state = "WANDERING";
                }
            }

            takeWood() {
                const posKey = arrayToKey([this.x, this.y]);
                if (this.world.wood[posKey] && this.wood_carried < 3) {
                    delete this.world.wood[posKey];
                    this.wood_carried++;
                    
                    const decayAmount = simSettings.ENV_DECAY_WOOD_GATHER * (1.0 - (this.skills.foraging / 10.0));
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth - decayAmount, 0, simSettings.ENV_HEALTH_MAX);
                    
                    if (Math.random() < simSettings.WOOD_SEED_CHANCE) {
                        this.wood_seeds_carried++;
                    }

                    this.memory.wood.delete(posKey);
                    this.state = "WANDERING";
                }
            }

            buildHome() {
                const posKey = arrayToKey([this.x, this.y]);
                let woodCost = Math.max(1, simSettings.CAMPFIRE_WOOD_COST - Math.floor(this.skills.building * 0.5));
                
                if (this.wood_carried >= woodCost) {
                    this.wood_carried -= woodCost;
                    this.world.homes[posKey] = { owner_id: this.id, durability: simSettings.HOME_DURABILITY_START };
                    this.home_location = posKey; 
                    this.state = "WANDERING";
                    this.skills.building = clamp(this.skills.building + 0.5, 0, 4.0); 
                }
            }
            
            buildCampfire() {
                const posKey = arrayToKey([this.x, this.y]);
                let woodCost = Math.max(1, simSettings.CAMPFIRE_WOOD_COST - Math.floor(this.skills.building * 0.5));
                
                if (this.wood_carried >= woodCost) {
                    this.wood_carried -= woodCost;
                    this.world.campfires[posKey] = simSettings.CAMPFIRE_BURN_TIME;
                    this.campfire_location = posKey; 
                    this.skills.building = clamp(this.skills.building + 0.2, 0, 4.0);
                    this.state = "WANDERING";
                }
            }
            
            attack(target) {
                let energyCost = Math.max(2, 10 - (this.skills.combat * 1.0));
                let damage = 15 + (this.skills.combat * 8); 
                
                this.state = "ATTACKING";
                this.energy -= energyCost;
                this.energy += 10; 
                
                target.energy -= damage;
                this.skills.combat = clamp(this.skills.combat + 0.2, 0, 10.0); 
                
                this.love = clamp(this.love - 5.0, 0, simSettings.STARTING_LOVE); 

                target.was_attacked_by = this.id;
            }
            
            mate(partner) {
                this.state = "MATING";
                partner.state = "MATING";
                
                this.energy -= 10;
                partner.energy -= 10;
                
                this.mate_cooldown = 65;
                partner.mate_cooldown = 65;
                
                let numChildren = Math.floor(Math.random() * 3) + 1; 
                if (Math.random() < 0.2) { 
                     numChildren = clamp(numChildren + 1, 1, 4); 
                }
                
                for (let i = 0; i < numChildren; i++) {
                    const newGenes = {};
                    for (const gene in this.genes) {
                        const [minVal, maxVal, mutRate] = GENE_RANGES[gene];
                        const avgGene = (this.genes[gene] + partner.genes[gene]) / 2;
                        const mutation = (Math.random() * 2 - 1) * mutRate * (maxVal - minVal);
                        newGenes[gene] = clamp(avgGene + mutation, minVal, maxVal);
                    }
                    
                    const newAgent = this.world.addAgent(this.x, this.y, newGenes);
                    if (newAgent) {
                        newAgent.skills = { 'foraging': 0.0, 'social': 0.0, 'building': 0.0, 'navigation': 0.0, 'combat': 0.0, 'farming': 0.0 };
                        newAgent.home_location = null;
                        
                        newAgent.parent_ids = new Set([this.id, partner.id]);
                        
                        this.children_ids.add(newAgent.id);
                        partner.children_ids.add(newAgent.id);
                    }
                }
                
                this.social = 100.0;
                this.contentment_buff_timer = 25; 
                partner.social = 100.0;
                partner.contentment_buff_timer = 25;
            }

            shareSkills(partner) {
                const skillsToShare = ['foraging', 'building', 'navigation', 'farming', 'combat'];
                const learningRate = 0.01; 
                
                for (const skill of skillsToShare) {
                    const selfSkill = this.skills[skill];
                    const partnerSkill = partner.skills[skill];
                    
                    if (selfSkill > partnerSkill) {
                        partner.skills[skill] = clamp(partnerSkill + learningRate, 0, 10.0);
                        if (selfSkill > 2.0) { 
                            this.world.globalSkillKnowledge[skill] = clamp((this.world.globalSkillKnowledge[skill] || 0.0) + 0.05, 0, 10.0);
                        }
                    } else if (partnerSkill > selfSkill) {
                        this.skills[skill] = clamp(selfSkill + learningRate, 0, 10.0);
                        if (partnerSkill > 2.0) {
                            this.world.globalSkillKnowledge[skill] = clamp((this.world.globalSkillKnowledge[skill] || 0.0) + 0.05, 0, 10.0);
                        }
                    }
                }
            }

            // --- THIS FUNCTION HAS BEEN MODIFIED ---
            communicate(partner) {
                this.state = "COMMUNICATING";
                partner.state = "COMMUNICATING";
                
                const selfPersonality = this.getPersonality();
                const partnerPersonality = partner.getPersonality();
                
                // --- NEW/REPLACED: Personality Conflict Check ---
                let conflictDetected = false;
                const selfConflicts = PERSONALITY_CONFLICTS[selfPersonality] || [];
                const partnerConflicts = PERSONALITY_CONFLICTS[partnerPersonality] || [];

                if (selfConflicts.includes(partnerPersonality)) {
                    conflictDetected = true;
                } else if (partnerConflicts.includes(selfPersonality)) {
                    conflictDetected = true;
                }
                    
                if (conflictDetected) {
                    // NEW: Remember the conflict
                    this.unpleasant_agents.add(partner.id);
                    partner.unpleasant_agents.add(this.id);
                    
                    let conflictChance = this.genes.aggression * 0.8;
                    if (selfPersonality === PERSONALITY_AGGRESSIVE_COOPERATOR) {
                         conflictChance = this.genes.aggression * 1.5;
                    }
                    
                    if (Math.random() < conflictChance) {
                        this.attack(partner); 
                        return;
                    }
                }
                // --- END NEW/REPLACED ---

                this.energy -= 1.0; 
                partner.energy -= 1.0;

                this.skills.social = clamp(this.skills.social + 0.2, 0, 10.0); 
                partner.skills.social = clamp(partner.skills.social + 0.2, 0, 10.0); 
                
                const socialGain = 50 + (this.skills.social * 10);
                const partnerSocialGain = 20 + (partner.skills.social * 5);
                
                this.social = clamp(this.social + socialGain, 0, 100);
                partner.social = clamp(partner.social + partnerSocialGain, 0, 100);
                
                this.social_buff_timer = 20; 
                partner.social_buff_timer = 20; 
                
                let loveGain = simSettings.LOVE_GAIN_SOCIAL;
                if (this.apathy_timer > 0) {
                    loveGain /= 2;
                }
                this.love = clamp(this.love + loveGain, 0, simSettings.STARTING_LOVE);
                    
                let loveGainPartner = simSettings.LOVE_GAIN_SOCIAL;
                if (partner.apathy_timer > 0) {
                    loveGainPartner /= 2;
                }
                partner.love = clamp(partner.love + loveGainPartner, 0, simSettings.STARTING_LOVE);
                
                this.shareSkills(partner);
                
                if (Object.keys(this.world.food).length < simSettings.STARTING_FOOD && this.seeds_carried >= 1 && partner.seeds_carried >= 1) {
                    const totalSeeds = this.seeds_carried + partner.seeds_carried;
                    if (totalSeeds >= 3) {
                        this.seeds_carried = 0;
                        partner.seeds_carried = 0;
                        
                        const [lx, ly] = this.world.libraryLocation;
                        let plantLocKey = arrayToKey([lx, ly]);
                        
                        if (!this.isClearTile(lx, ly)) {
                            plantLocKey = arrayToKey([this.x, this.y]);
                        }
                        
                        this.world.food[plantLocKey] = true;
                        this.world.foodFreshness[plantLocKey] = simSettings.FOOD_FRESHNESS;
                        
                        this.state = "FORAGING";
                        partner.state = "FORAGING";
                        return;
                    }
                }
                
                if (this.age >= simSettings.ADULT_AGE && this.energy > this.genes['mating_drive'] && this.mate_cooldown === 0 && 
                   partner.age >= simSettings.ADULT_AGE && partner.energy > partner.genes['mating_drive'] && partner.mate_cooldown === 0) {
                    this.mate(partner);
                }
            }

            plantSeed() {
                if (this.seeds_carried > 0) {
                    this.seeds_carried--;
                    this.energy -= 10;
                    
                    const posKey = arrayToKey([this.x, this.y]);
                    this.world.growingPlants[posKey] = simSettings.GROW_TIME;
                    
                    this.skills.farming = clamp(this.skills.farming + 0.2, 0, 10.0);
                    
                    const healAmount = simSettings.ENV_HEAL_PLANT_BASE * (this.skills.farming / 10.0);
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth + healAmount, 0, simSettings.ENV_HEALTH_MAX);

                    this.state = "WANDERING";
                }
            }

            plantTree() {
                if (this.wood_seeds_carried > 0) {
                    this.wood_seeds_carried--;
                    this.energy -= 10;
                    
                    const posKey = arrayToKey([this.x, this.y]);
                    this.world.growingTrees[posKey] = simSettings.TREE_GROW_TIME;
                    
                    this.skills.farming = clamp(this.skills.farming + 0.2, 0, 10.0);
                    
                    const healAmount = simSettings.ENV_HEAL_PLANT_BASE * (this.skills.farming / 10.0);
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth + healAmount, 0, simSettings.ENV_HEALTH_MAX);

                    this.state = "WANDERING";
                }
            }

            die(reason = 'UNKNOWN') {
                
                if (this.age < simSettings.ADULT_AGE && this.parent_ids.size > 0) {
                    const witnesses = [];
                    for (const agent of this.world.agents) {
                        if (agent.id === this.id || this.parent_ids.has(agent.id)) {
                            continue;
                        }
                        
                        const visionRadius = Math.floor(agent.genes['vision']);
                        const dist = getDistance(agent.x, agent.y, this.x, this.y);
                        
                        if (dist <= visionRadius) {
                            witnesses.push(agent);
                        }
                    }
                    
                    if (witnesses.length > 0) {
                        let closestParentAgent = null;
                        let minDistToParent = Infinity;
                        
                        for (const p_id of this.parent_ids) {
                            const parent = this.world.getAgentById(p_id);
                            if (parent) {
                                const dist = getDistance(this.x, this.y, parent.x, parent.y);
                                if (dist < minDistToParent) {
                                    minDistToParent = dist;
                                    closestParentAgent = parent;
                                }
                            }
                        }
                        
                        if (closestParentAgent) {
                            for (const witness of witnesses) {
                                witness.state = "AVENGING";
                                witness.avenging_target_id = closestParentAgent.id;
                            }
                        }
                    }
                }
                
                
                this.world.deathCauses[reason] = (this.world.deathCauses[reason] || 0) + 1;
                
                const deathLocationKey = arrayToKey([this.x, this.y]);
                
                for (let i = 0; i < this.wood_carried; i++) {
                    this.world.wood[deathLocationKey] = true;
                }
                
                for (let i = 0; i < this.food_carried; i++) {
                    this.world.food[deathLocationKey] = true;
                    this.world.foodFreshness[deathLocationKey] = simSettings.FOOD_FRESHNESS;
                }
                
                const dyingAgentId = this.id;
                for (const parent_id of this.parent_ids) {
                    const parent = this.world.getAgentById(parent_id);
                    if (parent && parent.children_ids.has(dyingAgentId)) {
                        parent.children_ids.delete(dyingAgentId);
                    }
                }
                
                this.world.agents = this.world.agents.filter(a => a.id !== this.id);
                
                if (this.home_location && this.world.homes[this.home_location]) {
                    this.world.homes[this.home_location].owner_id = null;
                }
                this.campfire_location = null;
            }
        }

        // --- WORLD CLASS ---

        class World {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.turn = 0;
                this.nextAgentId = 0;
                
                this.agents = [];
                this.food = {};
                this.wood = {};
                
                this.generationCount = 0;
                
                this.environmentalHealth = simSettings.ENV_HEALTH_MAX;

                this.deathCauses = { 'MAX_AGE': 0, 'STARVATION_ADULT': 0, 'STARVATION_CHILD': 0, 'COMBAT': 0, 'NATURAL_DEATH_OLD': 0, 'UNKNOWN': 0 };
                this.homes = {};
                this.growingPlants = {};
                this.growingTrees = {};
                this.foodFreshness = {};
                this.campfires = {};

                this.globalSkillKnowledge = {
                    'foraging': 0.0, 'social': 0.0, 'building': 5.0,
                    'navigation': 0.0, 'combat': 0.0, 'farming': 0.0
                };
                this.libraryLocation = [Math.floor(this.width / 2), Math.floor(this.height / 2)];

                this.stats = {};
            }

            getNextAgentId() {
                return ++this.nextAgentId;
            }

            getAgentById(agentId) {
                return this.agents.find(a => a.id === agentId);
            }

            getEmptyHome() {
                for (const pos in this.homes) {
                    if (this.homes[pos].owner_id === null) {
                        return pos;
                    }
                }
                return null;
            }

            addAgent(x = null, y = null, genes = null) {
                x = x === null ? Math.floor(Math.random() * this.width) : x;
                y = y === null ? Math.floor(Math.random() * this.height) : y;
                
                const agent = new Agent(x, y, this, genes);
                this.agents.push(agent);
                return agent;
            }

            spawnResources() {
                const foodYieldMultiplier = this.environmentalHealth / simSettings.ENV_HEALTH_MAX;
                const foodSpawnCount = Math.floor(5 * foodYieldMultiplier);
                const woodSpawnCount = Math.floor(3 * foodYieldMultiplier);

                if (this.turn % simSettings.FOOD_SPAWN_RATE === 0) {
                    for (let i = 0; i < foodSpawnCount; i++) { 
                        if (Object.keys(this.food).length < (this.width * this.height * 0.1)) {
                            const tile = this.getRandomEmptyTile();
                            if (tile) {
                                const posKey = arrayToKey(tile);
                                this.food[posKey] = true;
                                this.foodFreshness[posKey] = simSettings.FOOD_FRESHNESS;
                            }
                        }
                    }
                }

                if (this.turn % simSettings.WOOD_SPAWN_RATE === 0) {
                    for (let i = 0; i < woodSpawnCount; i++) { 
                        if (Object.keys(this.wood).length < (this.width * this.height * 0.05)) {
                            const tile = this.getRandomEmptyTile();
                            if (tile) {
                                this.wood[arrayToKey(tile)] = true;
                            }
                        }
                    }
                }
            }

            updateWorldObjects() {
                this.environmentalHealth = clamp(this.environmentalHealth + simSettings.ENV_PASSIVE_RECOVERY_RATE, 0, simSettings.ENV_HEALTH_MAX);
                
                for (const pos in this.growingPlants) {
                    this.growingPlants[pos]--;
                    if (this.growingPlants[pos] <= 0) {
                        delete this.growingPlants[pos];
                        if (!this.food[pos] && !this.homes[pos] && !this.wood[pos]) {
                            this.food[pos] = true;
                            this.foodFreshness[pos] = simSettings.FOOD_FRESHNESS;
                        }
                    }
                }
                
                for (const pos in this.growingTrees) {
                    this.growingTrees[pos]--;
                    if (this.growingTrees[pos] <= 0) {
                        delete this.growingTrees[pos];
                        if (!this.food[pos] && !this.homes[pos] && !this.wood[pos]) {
                            this.wood[pos] = true;
                        }
                    }
                }
                
                for (const posKey of Object.keys(this.foodFreshness)) {
                    this.foodFreshness[posKey]--;
                    if (this.foodFreshness[posKey] <= 0) {
                        delete this.foodFreshness[posKey];
                        delete this.food[posKey];         
                    }
                }
                
                for (const pos in this.campfires) {
                    this.campfires[pos]--;
                    if (this.campfires[pos] <= 0) {
                        delete this.campfires[pos];
                    }
                }
                
                if (this.turn % simSettings.HOME_DECAY_RATE === 0) {
                    for (const pos in this.homes) {
                        this.homes[pos].durability--;
                        if (this.homes[pos].durability <= 0) {
                            
                            for (let i = 0; i < 3; i++) {
                                this.wood[pos] = true;
                            }
                                
                            const ownerId = this.homes[pos].owner_id;
                            if (ownerId !== null) {
                                const agent = this.getAgentById(ownerId);
                                if (agent) {
                                    agent.home_location = null;
                                }
                            }
                            delete this.homes[pos];
                        }
                    }
                }
            }


            getRandomEmptyTile() {
                const attempts = 10;
                for (let i = 0; i < attempts; i++) {
                    const x = Math.floor(Math.random() * this.width);
                    const y = Math.floor(Math.random() * this.height);
                    const posKey = arrayToKey([x, y]);
                    
                    if (posKey === arrayToKey(this.libraryLocation)) {
                        continue;
                    }
                    
                    const occupied = this.agents.some(agent => agent.x === x && agent.y === y);
                        
                    if (!occupied && !this.food[posKey] && !this.wood[posKey] && !this.homes[posKey] && 
                        !this.growingPlants[posKey] && !this.growingTrees[posKey] && !this.campfires[posKey]) {
                        return [x, y];
                    }
                }
                return null; 
            }

            update() {
                this.turn++;
                
                if (this.turn % simSettings.MAX_AGE === 0) {
                    this.generationCount++;
                }
                
                for (let i = this.agents.length - 1; i >= 0; i--) {
                    const agent = this.agents[i];
                    if (this.agents.includes(agent)) {
                        agent.update();
                    }
                }
                
                this.spawnResources();
                this.updateWorldObjects();
                this.calculateStats();
            }

            calculateStats() {
                const adultAgents = this.agents.filter(agent => agent.age >= simSettings.ADULT_AGE);
                let agentsForStats = adultAgents.length > 0 ? adultAgents : this.agents;
                
                if (agentsForStats.length === 0) {
                    this.stats = { population: 0, homes_built: 0, active_campfires: 0 };
                    for (const gene in GENE_RANGES) {
                        this.stats[`avg_${gene}`] = 0;
                    }
                    const skillList = ['foraging', 'social', 'building', 'navigation', 'combat', 'farming'];
                    for (const skill of skillList) {
                        this.stats[`avg_${skill}_skill`] = 0;
                    }
                    const totalDeaths = Object.values(this.deathCauses).reduce((a, b) => a + b, 0);
                    this.deathCauses.TOTAL_DEATHS = totalDeaths;
                    return;
                }
                    
                const numAgents = agentsForStats.length;
                    
                this.stats.population = this.agents.length;
                this.stats.homes_built = Object.keys(this.homes).length;
                this.stats.active_campfires = Object.keys(this.campfires).length;
                
                for (const gene in GENE_RANGES) {
                    const avgKey = `avg_${gene}`;
                    const total = agentsForStats.reduce((sum, agent) => sum + agent.genes[gene], 0);
                    this.stats[avgKey] = total / numAgents;
                }
                    
                const skillList = ['foraging', 'social', 'building', 'navigation', 'combat', 'farming'];
                for (const skill of skillList) {
                    const avgKey = `avg_${skill}_skill`;
                    const total = agentsForStats.reduce((sum, agent) => sum + agent.skills[skill], 0);
                    this.stats[avgKey] = total / numAgents;
                }
                    
                const totalDeaths = Object.values(this.deathCauses).reduce((a, b) => a + b, 0);
                this.deathCauses.TOTAL_DEATHS = totalDeaths;
            }

            getNearest(x, y, radius, itemMap) {
                let nearestItemKey = null;
                let minDist = Infinity;
                
                for (const posKey in itemMap) {
                    const [ix, iy] = keyToArray(posKey);
                    const dist = getDistance(x, y, ix, iy);
                    if (dist <= radius && dist < minDist) {
                        minDist = dist;
                        nearestItemKey = posKey;
                    }
                }
                return nearestItemKey;
            }

            getNearestInSet(x, y, radius, itemMap) {
                const foundItemKeys = [];
                
                for (const posKey in itemMap) {
                    const [ix, iy] = keyToArray(posKey);
                    const dist = getDistance(x, y, ix, iy);
                    if (dist <= radius) {
                        foundItemKeys.push(posKey);
                    }
                }
                return foundItemKeys;
            }

            getNearestAgents(x, y, radius, excludeSelf = null) {
                const nearbyAgents = [];
                for (const agent of this.agents) {
                    if (agent === excludeSelf) continue;
                    const dist = getDistance(x, y, agent.x, agent.y);
                    if (dist <= radius) {
                        nearbyAgents.push(agent);
                    }
                }
                return nearbyAgents;
            }
        }


        // --- RENDERING AND MAIN LOOP ---

        class Renderer {
            constructor(world, canvasId) {
                this.world = world;
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

                this.cellSize = 20;
                
                this.resizeCanvas();
                let resizeTimer;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => this.resizeCanvas(), 100);
                });


                this.font = `${this.cellSize * 0.75}px Consolas, monospace`;
            }

            resizeCanvas() {
                const containerWidth = this.canvas.parentElement.clientWidth;
                if (containerWidth === 0) {
                    setTimeout(() => this.resizeCanvas(), 100); 
                    return;
                }
                let newCellSize = Math.floor(containerWidth / this.world.width);
                this.cellSize = Math.max(newCellSize, 8); 

                this.canvas.width = this.world.width * this.cellSize;
                this.canvas.height = this.world.height * this.cellSize;
                
                this.font = `${this.cellSize * 0.75}px Consolas, monospace`;
                this.render(); 
            }

            drawCell(x, y, char, color, isDim) {
                const ctx = this.ctx;
                const size = this.cellSize;
                const px = x * size + size / 2;
                const py = y * size + size / 2;

                ctx.fillStyle = color;
                if (isDim) {
                    ctx.globalAlpha = 0.5;
                } else {
                    ctx.globalAlpha = 1.0;
                }

                ctx.fillText(char, px, py);
            }

            render() {
                const ctx = this.ctx;
                const size = this.cellSize;

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                ctx.fillStyle = '#0d1117';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = this.font;

                const agentPositions = {};
                this.world.agents.forEach(agent => {
                    const posKey = arrayToKey([agent.x, agent.y]);
                    if (agent.home_location !== posKey) { 
                        agentPositions[posKey] = agent;
                    }
                });


                for(let y = 0; y < this.world.height; y++) {
                    for(let x = 0; x < this.world.width; x++) {
                        const posKey = arrayToKey([x, y]);
                        if (!agentPositions[posKey]) { 
                            this.drawCell(x, y, '.', COLORS.WHITE_NORMAL, true);
                        }
                    }
                }

                const resources = [
                    { map: this.world.growingPlants, char: 'P', color: COLORS.GREEN_NORMAL, dim: false },
                    { map: this.world.growingTrees, char: 'T', color: COLORS.GREEN_DIM, dim: false },
                    { map: this.world.food, char: 'F', color: COLORS.GREEN_BRIGHT, dim: false },
                    { map: this.world.wood, char: 'W', color: COLORS.YELLOW_BRIGHT, dim: false },
                    { map: this.world.campfires, char: 'C', color: COLORS.RED_BRIGHT, dim: false },
                ];

                resources.forEach(res => {
                    for (const posKey in res.map) {
                        if (!agentPositions[posKey]) { 
                            const [x, y] = keyToArray(posKey);
                            this.drawCell(x, y, res.char, res.color, res.dim);
                        }
                    }
                });

                for (const posKey in this.world.homes) {
                    const [x, y] = keyToArray(posKey);
                    const durability = this.world.homes[posKey].durability;
                    const char = durability < 2 ? 'h' : 'H';
                    const color = durability < 2 ? COLORS.BLUE_NORMAL : COLORS.BLUE_BRIGHT;
                    this.drawCell(x, y, char, color, false);
                }
                
                const [lx, ly] = this.world.libraryLocation;
                this.drawCell(lx, ly, 'L', COLORS.LIBRARY, false);


                const agentsAtHome = [];
                
                this.world.agents.forEach(agent => {
                    const isAtHome = agent.home_location !== null && agent.home_location === arrayToKey([agent.x, agent.y]);
                    if (isAtHome) {
                        agentsAtHome.push(agent);
                        return; 
                    }
                    
                    let charMapEntry = CHAR_MAP[agent.state] || CHAR_MAP['WANDERING'];
                    let char = charMapEntry.char;
                    let color = charMapEntry.color;
                    let isDim = charMapEntry.dim;

                    // Apathy override
                    if (agent.apathy_timer > 0) {
                        color = COLORS.MAGENTA_DIM;
                        char = 's';
                        isDim = true;
                    }
                    // Fleeing override (check after apathy)
                    else if (agent.state === 'FLEEING_FOR_FOOD') {
                        color = CHAR_MAP['FLEEING_FOR_FOOD'].color;
                        char = CHAR_MAP['FLEEING_FOR_FOOD'].char;
                        isDim = false;
                    }
                    // Social buff override
                    else if (agent.social_buff_timer > 0) {
                        color = COLORS.WHITE_BRIGHT; 
                        isDim = false;
                    }
                    
                    this.drawCell(agent.x, agent.y, char, color, isDim);
                });

                agentsAtHome.forEach(agent => {
                    const size = this.cellSize;
                    const px = agent.x * size + size / 2 + size * 0.15;
                    const py = agent.y * size + size / 2 + size * 0.15;
                    
                    let charMapEntry = CHAR_MAP[agent.state] || CHAR_MAP['WANDERING'];
                    let char = charMapEntry.char;
                    let color = charMapEntry.color;
                    let isDim = charMapEntry.dim;

                    if (agent.apathy_timer > 0) {
                        color = COLORS.MAGENTA_DIM;
                        char = 's';
                        isDim = true;
                    }
                    else if (agent.state === 'FLEEING_FOR_FOOD') {
                        color = CHAR_MAP['FLEEING_FOR_FOOD'].color;
                        char = CHAR_MAP['FLEEING_FOR_FOOD'].char;
                        isDim = false;
                    }
                    else if (agent.social_buff_timer > 0) {
                        color = COLORS.WHITE_BRIGHT; 
                        isDim = false;
                    }

                    ctx.font = `${this.cellSize * 0.4}px Consolas, monospace`; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = color;
                    if (isDim) {
                        ctx.globalAlpha = 0.5;
                    } else {
                        ctx.globalAlpha = 1.0;
                    }

                    ctx.fillText(char, px, py);
                    ctx.font = this.font;
                });

                ctx.globalAlpha = 1.0;
            }
        }

        // --- STATS RENDERING ---
        function updateStatsDisplay(world) {
            document.getElementById('turnCounter').textContent = world.turn;
            document.getElementById('generationCounter').textContent = world.generationCount;
            document.getElementById('statPopulation').textContent = world.stats.population || 0;
            document.getElementById('statHomes').textContent = world.stats.homes_built || 0;
            document.getElementById('statFires').textContent = world.stats.active_campfires || 0;

            const envHealth = world.environmentalHealth;
            let envColor = 'text-green-400';
            if (envHealth <= 70) envColor = 'text-yellow-400';
            if (envHealth <= 30) envColor = 'text-red-400';
            document.getElementById('statEnvHealth').innerHTML = `<span class="${envColor}">${envHealth.toFixed(1)}%</span>`;

            const geneStatsDiv = document.getElementById('geneStats');
            geneStatsDiv.innerHTML = '';
            for (const gene in GENE_RANGES) {
                const avg = world.stats[`avg_${gene}`] || 0;
                let color = 'text-cyan-400';
                if (gene === 'aggression') color = 'text-red-400';
                if (gene === 'metabolism') color = 'text-red-400';
                if (gene === 'builder') color = 'text-blue-400';
                if (gene === 'mating_drive') color = 'text-magenta-400';
                if (gene === 'sociability') color = 'text-white';
                if (gene === 'farming') color = 'text-green-400';
                if (gene === 'personality') color = 'text-magenta-400';
                
                const displayValue = gene === 'mating_drive' ? avg.toFixed(0) : avg.toFixed(2);
                
                geneStatsDiv.innerHTML += `<p><span class="${color}">${gene.padEnd(12, ' ')}</span>: ${displayValue}</p>`;
            }

            const skillStatsDiv = document.getElementById('skillStats');
            skillStatsDiv.innerHTML = '';
            const skillList = ['foraging', 'social', 'building', 'navigation', 'combat', 'farming'];
            for (const skill of skillList) {
                const avg = world.stats[`avg_${skill}_skill`] || 0;
                let color = 'text-green-400';
                if (skill === 'social') color = 'text-white';
                if (skill === 'building') color = 'text-blue-400';
                if (skill === 'navigation') color = 'text-cyan-400';
                if (skill === 'combat') color = 'text-red-400';
                
                skillStatsDiv.innerHTML += `<p><span class="${color}">${skill.padEnd(12, ' ')}</span>: ${avg.toFixed(2)}</p>`;
            }

            const knowledgeStatsDiv = document.getElementById('knowledgeStats');
            knowledgeStatsDiv.innerHTML = '';
            for (const skill in world.globalSkillKnowledge) {
                const val = world.globalSkillKnowledge[skill];
                knowledgeStatsDiv.innerHTML += `<p><span class="text-yellow-400">${skill.padEnd(12, ' ')}</span>: ${val.toFixed(2)}</p>`;
            }

            const deathStatsDiv = document.getElementById('deathStats');
            deathStatsDiv.innerHTML = '';
            const totalDeaths = world.deathCauses.TOTAL_DEATHS || 0;
            if (totalDeaths > 0) {
                const filteredDeaths = Object.entries(world.deathCauses).filter(([reason, count]) => 
                    reason !== 'UNKNOWN' && reason !== 'TOTAL_DEATHS' && count > 0
                );

                for (const [reason, count] of filteredDeaths) {
                    const percent = (count / totalDeaths) * 100;
                    deathStatsDiv.innerHTML += `<p><span class="text-red-500">${reason.padEnd(20, ' ')}</span>: ${count} (${percent.toFixed(1)}%)</p>`;
                }
            } else {
                deathStatsDiv.innerHTML = '<p>No deaths recorded yet.</p>';
            }
        }

        // --- THIS FUNCTION HAS BEEN MODIFIED ---
        function populateLegend() {
            const legendDiv = document.getElementById('legend');
            
            const groups = [
                {
                    title: 'Status & Interaction',
                    items: [
                        { char: 'A', color: COLORS.CYAN_BRIGHT, desc: 'Wander (Default)' },
                        { char: 'f', color: COLORS.CYAN_NORMAL, desc: 'Forage/Eat' },
                        { char: 'f', color: COLORS.RED_BRIGHT, desc: 'Fleeing for Food' }, // <-- NEW
                        { char: 's', color: COLORS.MAGENTA_DIM, desc: 'Sad/Crisis/Apathy' },
                        { char: 'o', color: COLORS.MAGENTA_BRIGHT, desc: 'Happy/Linger' },
                        { char: 'L', color: COLORS.MAGENTA_BRIGHT, desc: 'Seek Library' },
                        { char: 't', color: COLORS.WHITE_NORMAL, desc: 'Seek Social' },
                        { char: 'T', color: COLORS.WHITE_BRIGHT, desc: 'Communicate/Share Knowledge' },
                        { char: 'm', color: COLORS.MAGENTA_BRIGHT, desc: 'Mate' },
                        { char: 'X/r', color: COLORS.RED_BRIGHT, desc: 'Attack/Retaliate' },
                        { char: 'V', color: COLORS.RED_BRIGHT, desc: 'Avenge Child Death' },
                        { char: 'g', color: COLORS.WHITE_BRIGHT, desc: 'Share Resources' },
                    ]
                },
                {
                    title: 'Building & Wood',
                    items: [
                        { char: 'w', color: COLORS.YELLOW_NORMAL, desc: 'Get Wood' },
                        { char: 'b', color: COLORS.YELLOW_BRIGHT, desc: 'Build Home' },
                        { char: 'k', color: COLORS.BLUE_BRIGHT, desc: 'Claim Home' },
                        { char: 'E', color: COLORS.YELLOW_NORMAL, desc: 'Repair Home' },
                        { char: 'c', color: COLORS.RED_NORMAL, desc: 'Build Fire' },
                        { char: 'R', color: COLORS.RED_BRIGHT, desc: 'Refuel Fire' },
                    ]
                },
                {
                    title: 'Farming & Resources',
                    items: [
                        { char: 'p', color: COLORS.GREEN_NORMAL, desc: 'Plant Food/Tree' },
                        { char: 'G', color: COLORS.GREEN_BRIGHT, desc: 'Go Home to Plant' },
                        { char: 'F', color: COLORS.GREEN_BRIGHT, desc: 'Food (Ready to Eat)' },
                        { char: 'P', color: COLORS.GREEN_NORMAL, desc: 'Plant (Growing Food)' },
                        { char: 'W', color: COLORS.YELLOW_BRIGHT, desc: 'Wood (Lumber)' },
                        { char: 'T', color: COLORS.GREEN_DIM, desc: 'Tree (Growing Wood)' },
                    ]
                },
                {
                    title: 'Permanent Structures',
                    items: [
                        { char: 'H/h', color: COLORS.BLUE_BRIGHT, desc: 'Home (Healthy/Damaged)' },
                        { char: 'C', color: COLORS.RED_BRIGHT, desc: 'Active Campfire' },
                        { char: 'L', color: COLORS.LIBRARY, desc: 'Library Location' },
                        { char: 'Any', color: COLORS.WHITE_BRIGHT, desc: 'Agent with Wellbeing Buff' },
                    ]
                }
            ];
            
            let html = '';

            groups.forEach(group => {
                html += `<div class="w-full mt-2 mb-1 border-t border-gray-700 pt-2"><h3 class="font-semibold text-sm text-cyan-300">${group.title}</h3></div>`;
                group.items.forEach(item => {
                    html += `<p class="flex items-center min-w-[200px] lg:min-w-[250px]"><span style="color: ${item.color}; font-weight: bold; width: 30px;">${item.char}</span> ${item.desc}</p>`;
                });
            });

            legendDiv.innerHTML = html;
        }

        // --- NEW: Settings Management Functions ---

        function loadSettings() {
            try {
                const storedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);
                if (storedSettings) {
                    const parsedSettings = JSON.parse(storedSettings);
                    return { ...defaultSimSettings, ...parsedSettings };
                }
            } catch (e) {
                console.error("Failed to load settings from localStorage", e);
            }
            return { ...defaultSimSettings };
        }

        function saveSettings(settings) {
            try {
                localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
            } catch (e) {
                console.error("Failed to save settings to localStorage", e);
            }
        }
        
        function clearSettings() {
            try {
                localStorage.removeItem(SETTINGS_STORAGE_KEY);
            } catch (e) {
                console.error("Failed to clear settings from localStorage", e);
            }
        }

        function populateSettingsForm(settings) {
            for (const key in settings) {
                const input = document.getElementById(key);
                if (input) {
                    input.value = settings[key];
                }
            }
        }
        
        function getSettingsFromForm() {
            const newSettings = {};
            const form = document.getElementById('settingsForm');
            const inputs = form.querySelectorAll('input[type="number"]');
            
            inputs.forEach(input => {
                const value = parseFloat(input.value);
                if (!isNaN(value)) {
                    newSettings[input.id] = value;
                } else {
                    newSettings[input.id] = defaultSimSettings[input.id];
                }
            });
            return newSettings;
        }
        
        function setupModalControls() {
            const modal = document.getElementById('settingsModal');
            const openBtn = document.getElementById('openSettingsBtn');
            const closeBtn = document.getElementById('closeSettingsBtn');
            const saveBtn = document.getElementById('saveSettingsBtn');
            const resetBtn = document.getElementById('resetSettingsBtn');
            
            openBtn.onclick = () => modal.classList.remove('hidden');
            closeBtn.onclick = () => modal.classList.add('hidden');
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                }
            };
            
            resetBtn.onclick = () => {
                if (confirm('Are you sure you want to reset all settings to their defaults? This will clear your saved settings and restart the simulation.')) {
                    clearSettings(); 
                    modal.classList.add('hidden'); 
                    location.reload(); 
                }
            };
            
            saveBtn.onclick = () => {
                simSettings = getSettingsFromForm();
                saveSettings(simSettings);
                modal.classList.add('hidden');
                location.reload(); 
            };
        }


        // --- MAIN INITIALIZATION ---
        let world, renderer, interval;

        function initializeSimulation() {
            if (interval) clearInterval(interval);
            
            world = new World(simSettings.WORLD_WIDTH, simSettings.WORLD_HEIGHT);
            
            for (let i = 0; i < simSettings.STARTING_AGENTS; i++) {
                world.addAgent(); 
            }
            for (let i = 0; i < simSettings.STARTING_FOOD; i++) {
                const tile = world.getRandomEmptyTile();
                if (tile) {
                    const posKey = arrayToKey(tile);
                    world.food[posKey] = true;
                    world.foodFreshness[posKey] = simSettings.FOOD_FRESHNESS;
                }
            }
            for (let i = 0; i < simSettings.STARTING_WOOD; i++) {
                const tile = world.getRandomEmptyTile();
                if (tile) {
                    world.wood[arrayToKey(tile)] = true;
                }
            }
            
            renderer = new Renderer(world, 'worldCanvas');
            
            world.calculateStats();
            updateStatsDisplay(world);

            interval = setInterval(gameLoop, simSettings.SIM_SPEED);
            
            console.log("Simulation initialized. Starting loop.");
        }

        function gameLoop() {
            try {
                world.update();
                renderer.render();
                updateStatsDisplay(world);

                if (world.stats.population === 0 && world.turn > 100) {
                    console.log("--- SIMULATION END: All agents have died. ---");
                    clearInterval(interval);
                }
                if (world.agents.length > (simSettings.WORLD_WIDTH * simSettings.WORLD_HEIGHT * 0.5)) {
                    console.log("--- SIMULATION END: Overpopulation! ---");
                    clearInterval(interval);
                }
            } catch (e) {
                console.error("Error in game loop:", e);
                clearInterval(interval);
            }
        }

        window.onload = () => {
            simSettings = loadSettings();
            populateSettingsForm(simSettings);
            setupModalControls();
            populateLegend();
            initializeSimulation();
        };

    </script>
</body>
</html>