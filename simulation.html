<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A-Life Simulation</title>
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Consolas', 'Monaco', 'monospace'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom styles for the grid visualization */
        #worldCanvas {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #0d1117; /* Dark background for console feel */
            border-radius: 0.5rem;
            /* CRITICAL: Ensures characters are drawn without interpolation/blurring */
            image-rendering: pixelated; 
            
            /* Ensure the canvas size defined by JS is respected and centered */
            display: block; 
            margin: 0 auto; 
        }

        #statsPanel {
            overflow-y: visible; /* Ensure it expands naturally */
        }

        body, html {
            height: 100%;
            margin: 0;
            background-color: #1f2937;
        }

        #canvasWrapper {
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }

        @media (min-width: 1024px) {
            #canvasWrapper {
                width: 100%;
                margin: 0;
            }
        }
        
        /* NEW: Settings Modal Styles */
        .modal {
            background-color: rgba(0, 0, 0, 0.6);
        }
        
        .modal-content {
            max-height: 90vh;
        }
        
        .hidden {
            display: none;
        }
        
        /* Style for number inputs in the modal */
        #settingsForm input[type="number"] {
            background-color: #374151; /* bg-gray-700 */
            border: 1px solid #4b5563; /* border-gray-600 */
            color: white;
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.5rem 0.75rem; /* px-3 py-2 */
            width: 100%;
        }
        
        #settingsForm label {
            display: block;
            margin-bottom: 0.5rem; /* mb-2 */
            font-weight: 500; /* font-medium */
            color: #d1d5db; /* text-gray-300 */
        }
        
        #settingsForm fieldset {
            border: 1px solid #4b5563; /* border-gray-600 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem; /* p-4 */
            margin-bottom: 1.5rem; /* mb-6 */
        }
        
        #settingsForm legend {
            padding: 0 0.5rem; /* px-2 */
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: #60a5fa; /* text-blue-400 */
        }
        
    </style>
</head>
<body class="p-4 sm:p-8 bg-gray-800 text-white min-h-screen">

    <div id="settingsModal" class="modal hidden fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="modal-content bg-gray-800 border border-gray-700 rounded-lg shadow-2xl w-full max-w-3xl flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h2 class="text-2xl font-bold text-white">Simulation Settings</h2>
                <button id="closeSettingsBtn" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            
            <form id="settingsForm" class="p-6 overflow-y-auto flex-1 min-h-0">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6">
                    
                    <div>
                        <fieldset>
                            <legend>Age & Love</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="ADULT_AGE">Adult Age</label>
                                    <input type="number" id="ADULT_AGE" name="ADULT_AGE" step="1">
                                </div>
                                <div>
                                    <label for="OLD_AGE">Old Age</label>
                                    <input type="number" id="OLD_AGE" name="OLD_AGE" step="1">
                                </div>
                                <div>
                                    <label for="MAX_AGE">Max Age</label>
                                    <input type="number" id="MAX_AGE" name="MAX_AGE" step="1">
                                </div>
                                <div>
                                    <label for="STARTING_LOVE">Starting Love</label>
                                    <input type="number" id="STARTING_LOVE" name="STARTING_LOVE" step="0.1">
                                </div>
                                <div>
                                    <label for="LOVE_GAIN_EAT">Love Gain (Eat)</label>
                                    <input type="number" id="LOVE_GAIN_EAT" name="LOVE_GAIN_EAT" step="0.1">
                                </div>
                                <div>
                                    <label for="LOVE_GAIN_SOCIAL">Love Gain (Social)</label>
                                    <input type="number" id="LOVE_GAIN_SOCIAL" name="LOVE_GAIN_SOCIAL" step="0.1">
                                </div>
                                <div>
                                    <label for="LOVE_GAIN_REST">Love Gain (Rest)</label>
                                    <input type="number" id="LOVE_GAIN_REST" name="LOVE_GAIN_REST" step="0.1">
                                </div>
                                <div>
                                    <label for="LOVE_LOSS_STRUGGLE">Love Loss (Struggle)</label>
                                    <input type="number" id="LOVE_LOSS_STRUGGLE" name="LOVE_LOSS_STRUGGLE" step="0.1">
                                </div>
                                <div>
                                    <label for="PASSIVE_LOVE_GAIN">Passive Love Gain</label>
                                    <input type="number" id="PASSIVE_LOVE_GAIN" name="PASSIVE_LOVE_GAIN" step="0.01">
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset>
                            <legend>Pause & Apathy</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="PAUSE_ENERGY_THRESHOLD">Pause Energy</label>
                                    <input type="number" id="PAUSE_ENERGY_THRESHOLD" name="PAUSE_ENERGY_THRESHOLD" step="1">
                                </div>
                                <div>
                                    <label for="PAUSE_SOCIAL_THRESHOLD">Pause Social</label>
                                    <input type="number" id="PAUSE_SOCIAL_THRESHOLD" name="PAUSE_SOCIAL_THRESHOLD" step="1">
                                </div>
                                <div>
                                    <label for="APATHY_DURATION">Apathy Duration</label>
                                    <input type="number" id="APATHY_DURATION" name="APATHY_DURATION" step="1">
                                </div>
                                <div>
                                    <label for="APATHY_METABOLISM_PENALTY">Apathy Metabolism</label>
                                    <input type="number" id="APATHY_METABOLISM_PENALTY" name="APATHY_METABOLISM_PENALTY" step="0.1">
                                </div>
                                <div>
                                    <label for="APATHY_SOCIAL_LOSS_MULTIPLIER">Apathy Social Loss</label>
                                    <input type="number" id="APATHY_SOCIAL_LOSS_MULTIPLIER" name="APATHY_SOCIAL_LOSS_MULTIPLIER" step="0.1">
                                </div>
                            </div>
                        </fieldset>

                        <fieldset>
                            <legend>Environment</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="ENV_HEALTH_MAX">Env. Health Max</label>
                                    <input type="number" id="ENV_HEALTH_MAX" name="ENV_HEALTH_MAX" step="0.1">
                                </div>
                                <div>
                                    <label for="ENV_PASSIVE_RECOVERY_RATE">Env. Recovery</label>
                                    <input type="number" id="ENV_PASSIVE_RECOVERY_RATE" name="ENV_PASSIVE_RECOVERY_RATE" step="0.01">
                                </div>
                                <div>
                                    <label for="ENV_DECAY_FOOD_GATHER">Env. Decay (Food)</label>
                                    <input type="number" id="ENV_DECAY_FOOD_GATHER" name="ENV_DECAY_FOOD_GATHER" step="0.01">
                                </div>
                                <div>
                                    <label for="ENV_DECAY_WOOD_GATHER">Env. Decay (Wood)</label>
                                    <input type="number" id="ENV_DECAY_WOOD_GATHER" name="ENV_DECAY_WOOD_GATHER" step="0.01">
                                </div>
                                <div>
                                    <label for="ENV_HEAL_PLANT_BASE">Env. Heal (Plant)</label>
                                    <input type="number" id="ENV_HEAL_PLANT_BASE" name="ENV_HEAL_PLANT_BASE" step="0.1">
                                </div>
                            </div>
                        </fieldset>
                    </div>
                    
                    <div>
                        <fieldset>
                            <legend>Simulation & World</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="SIM_SPEED">Sim Speed (ms)</label>
                                    <input type="number" id="SIM_SPEED" name="SIM_SPEED" step="1">
                                </div>
                                <div>
                                    <label for="WORLD_WIDTH">World Width</label>
                                    <input type="number" id="WORLD_WIDTH" name="WORLD_WIDTH" step="1">
                                </div>
                                <div>
                                    <label for="WORLD_HEIGHT">World Height</label>
                                    <input type="number" id="WORLD_HEIGHT" name="WORLD_HEIGHT" step="1">
                                </div>
                                <div>
                                    <label for="STARTING_AGENTS">Starting Agents</label>
                                    <input type="number" id="STARTING_AGENTS" name="STARTING_AGENTS" step="1">
                                </div>
                                <div>
                                    <label for="STARTING_FOOD">Starting Food</label>
                                    <input type="number" id="STARTING_FOOD" name="STARTING_FOOD" step="1">
                                </div>
                                <div>
                                    <label for="STARTING_WOOD">Starting Wood</label>
                                    <input type="number" id="STARTING_WOOD" name="STARTING_WOOD" step="1">
                                </div>
                                <div>
                                    <label for="MIN_POPULATION_TARGET">Min. Pop. Target</label>
                                    <input type="number" id="MIN_POPULATION_TARGET" name="MIN_POPULATION_TARGET" step="1">
                                </div>
                                <div>
                                    <label for="CRITICAL_FOOD_COUNT">Critical Food</label>
                                    <input type="number" id="CRITICAL_FOOD_COUNT" name="CRITICAL_FOOD_COUNT" step="1">
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset>
                            <legend>Resources & Farming</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="FOOD_SPAWN_RATE">Food Spawn Rate</label>
                                    <input type="number" id="FOOD_SPAWN_RATE" name="FOOD_SPAWN_RATE" step="1">
                                </div>
                                <div>
                                    <label for="WOOD_SPAWN_RATE">Wood Spawn Rate</label>
                                    <input type="number" id="WOOD_SPAWN_RATE" name="WOOD_SPAWN_RATE" step="1">
                                </div>
                                <div>
                                    <label for="FOOD_FRESHNESS">Food Freshness</label>
                                    <input type="number" id="FOOD_FRESHNESS" name="FOOD_FRESHNESS" step="1">
                                </div>
                                <div>
                                    <label for="GROW_TIME">Grow Time (Food)</label>
                                    <input type="number" id="GROW_TIME" name="GROW_TIME" step="1">
                                </div>
                                <div>
                                    <label for="TREE_GROW_TIME">Grow Time (Tree)</label>
                                    <input type="number" id="TREE_GROW_TIME" name="TREE_GROW_TIME" step="1">
                                </div>
                                <div>
                                    <label for="WOOD_SEED_CHANCE">Wood Seed Chance</label>
                                    <input type="number" id="WOOD_SEED_CHANCE" name="WOOD_SEED_CHANCE" step="0.01">
                                </div>
                                <div>
                                    <label for="FOOD_SEED_BASE_CHANCE">Food Seed Chance</label>
                                    <input type="number" id="FOOD_SEED_BASE_CHANCE" name="FOOD_SEED_BASE_CHANCE" step="0.01">
                                </div>
                            </div>
                        </fieldset>
                        
                        <fieldset>
                            <legend>Structures</legend>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="CAMPFIRE_BURN_TIME">Campfire Burn Time</label>
                                    <input type="number" id="CAMPFIRE_BURN_TIME" name="CAMPFIRE_BURN_TIME" step="1">
                                </div>
                                <div>
                                    <label for="CAMPFIRE_WOOD_COST">Campfire Wood Cost</label>
                                    <input type="number" id="CAMPFIRE_WOOD_COST" name="CAMPFIRE_WOOD_COST" step="1">
                                </div>
                                <div>
                                    <label for="CAMPFIRE_REFUEL_THRESHOLD">Campfire Refuel</label>
                                    <input type="number" id="CAMPFIRE_REFUEL_THRESHOLD" name="CAMPFIRE_REFUEL_THRESHOLD" step="1">
                                </div>
                                <div>
                                    <label for="HOME_DURABILITY_START">Home Durability</label>
                                    <input type="number" id="HOME_DURABILITY_START" name="HOME_DURABILITY_START" step="1">
                                </div>
                                <div>
                                    <label for="HOME_DECAY_RATE">Home Decay Rate</label>
                                    <input type="number" id="HOME_DECAY_RATE" name="HOME_DECAY_RATE" step="1">
                                </div>
                            </div>
                        </fieldset>
                    </div>
                    
                </div>
            </form>
            
            <div class="flex justify-end items-center p-4 bg-gray-900 border-t border-gray-700 rounded-b-lg space-x-4">
                <button id="resetSettingsBtn" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg shadow-md">
                    Reset to Default
                </button>
                <button id="saveSettingsBtn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow-md">
                    Save & Restart
                </button>
            </div>
        </div>
    </div>
    <div class="w-full">
        <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-4">
            <div>
                <h1 class="text-4xl font-bold text-cyan-400">A-Life: Web Simulation</h1>
                <p class="text-gray-400 mb-6">A JavaScript implementation of the Python Life Simulation. See evolution in action!</p>
            </div>
            
            <div class="flex space-x-4">
                <button id="openSettingsBtn" class="mb-4 sm:mb-0 px-5 py-2.5 bg-gray-700 hover:bg-gray-600 text-white font-medium rounded-lg shadow-md">
                    Settings
                </button>
                
                <a href="agent_mechanics_guide.html" target="_blank" class="mb-4 sm:mb-0 px-5 py-2.5 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg shadow-md">
                    How it Works
                </a>
            </div>
        </div>

        <div class="flex flex-col lg:grid lg:grid-cols-3 lg:gap-6">

            <div class="order-1 lg:col-span-2 min-w-0"> 
                <div id="canvasWrapper" class="bg-gray-900 p-2 rounded-lg shadow-2xl">
                    <canvas id="worldCanvas"></canvas>
                </div>
            </div>

            <div id="statsPanel" class="mt-6 lg:mt-0 lg:col-span-1 lg:row-start-1 lg:row-span-2 order-2 bg-gray-900 p-6 rounded-lg shadow-2xl font-mono text-xs">
                <div class="mb-4">
                    <p class="text-yellow-400 text-sm">Turn: <span id="turnCounter" class="font-bold text-base">0</span></p>
                    <p class="text-yellow-400 text-sm">Generation: <span id="generationCounter" class="font-bold text-base">0</span></p>
                </div>

                <div class="space-y-4">
                    <h2 class="text-base font-semibold text-cyan-400">Overview</h2>
                    <p>Population: <span id="statPopulation" class="text-white">0</span> | Homes: <span id="statHomes" class="text-white">0</span> | Fires: <span id="statFires" class="text-white">0</span></p>
                    <p class="text-yellow-400 text-sm">Environmental Health: <span id="statEnvHealth" class="font-bold text-base text-green-400">100.0%</span></p>

                    <h2 class="text-base font-semibold text-cyan-400">Average Genes (Evolution)</h2>
                    <div id="geneStats"></div>

                    <h2 class="text-base font-semibold text-cyan-400">Average Skills (Learning)</h2>
                    <div id="skillStats"></div>

                    <h2 class="text-base font-semibold text-cyan-400">Global Knowledge Library</h2>
                    <div id="knowledgeStats"></div>

                    <h2 class="text-base font-semibold text-cyan-400">Death Analysis</h2>
                    <div id="deathStats"></div>
                </div>
            </div>

            <div class="mt-4 p-4 bg-gray-900 rounded-lg text-sm font-mono order-3 lg:col-span-2 lg:mt-0">
                <h2 class="text-lg font-semibold mb-2 text-yellow-300">Legend</h2>
                <div id="legend" class="flex flex-wrap gap-x-6 gap-y-1">
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- CONSTANTS MAPPING FROM PYTHON ---
        // NEW: Refactored constants into objects for settings management
        
        const SETTINGS_STORAGE_KEY = 'aLifeSimSettings';

        // These are the hard-coded defaults
        const defaultSimSettings = {
            // *** SYNCED WITH life_simulation2.py ***
            ADULT_AGE: 300, // Py: 300
            OLD_AGE: 1500,
            MAX_AGE: 2000,
            
            // Love Parameters
            STARTING_LOVE: 10, 
            LOVE_GAIN_EAT: 2.5,
            LOVE_GAIN_SOCIAL: 5, 
            LOVE_GAIN_REST: 0.5,
            LOVE_LOSS_STRUGGLE: 2.5, 
            PASSIVE_LOVE_GAIN: 0.0,

            // PAUSE THRESHOLDS
            PAUSE_ENERGY_THRESHOLD: 100,
            PAUSE_SOCIAL_THRESHOLD: 80, 

            // Environmental Degradation Constants
            ENV_HEALTH_MAX: 100.0,
            ENV_PASSIVE_RECOVERY_RATE: 0.05,
            ENV_DECAY_FOOD_GATHER: 0.1,   
            ENV_DECAY_WOOD_GATHER: 0.2,   
            ENV_HEAL_PLANT_BASE: 1.0,    

            // Apathy System Constants
            APATHY_DURATION: 50, 
            APATHY_METABOLISM_PENALTY: 0.5,
            APATHY_SOCIAL_LOSS_MULTIPLIER: 2.0,

            // Critical Survival Thresholds
            MIN_POPULATION_TARGET: 16, 
            CRITICAL_FOOD_COUNT: 60, 

            // Simulation Parameters
            WORLD_WIDTH: 70,
            WORLD_HEIGHT: 30,
            STARTING_AGENTS: 15,
            STARTING_FOOD: 120,  
            STARTING_WOOD: 80,  
            SIM_SPEED: 150, // Milliseconds for simulation tick (Py: 0.15)

            // Resources spawn every N turns
            FOOD_SPAWN_RATE: 20, // Py: 20
            WOOD_SPAWN_RATE: 50, // Py: 50

            // Farming Parameters
            FOOD_FRESHNESS: 185, 
            GROW_TIME: 10, 

            // Tree Parameters
            TREE_GROW_TIME: 10, 
            WOOD_SEED_CHANCE: 0.5,
            FOOD_SEED_BASE_CHANCE: 0.5, // Py: 0.5

            // Campfire Parameters
            CAMPFIRE_BURN_TIME: 300, 
            CAMPFIRE_WOOD_COST: 3, 
            CAMPFIRE_REFUEL_THRESHOLD: 100, 

            // Home Durability
            HOME_DURABILITY_START: 3,
            HOME_DECAY_RATE: 400, 
        };
        
        // This 'let' variable will hold the active settings (either default or loaded from storage)
        let simSettings = {};

        // --- STATIC CONSTANTS (Not configurable by user) ---
        // *** SYNCED WITH life_simulation2.py ***
        const VENGEANCE_DURATION = 50;
        const PERSONALITY_COOPERATIVE = 1;
        const PERSONALITY_ISOLATED = 2;
        const PERSONALITY_JUDGMENTAL = 3; 
        const PERSONALITY_AGGRESSIVE_COOPERATOR = 4;

        const PERSONALITY_CONFLICTS = {
            [PERSONALITY_JUDGMENTAL]: [PERSONALITY_ISOLATED],
            [PERSONALITY_AGGRESSIVE_COOPERATOR]: [PERSONALITY_JUDGMENTAL]
        };

        const GENE_RANGES = {
            'vision': [3, 10, 0.1],
            'speed': [1, 3, 0.1],
            'metabolism': [0.5, 2.0, 0.1],
            'aggression': [0.0, 0.5, 0.1],
            'builder': [0.0, 1.0, 0.1],
            'mating_drive': [120, 160, 5.0], // Py: (120, 160)
            'sociability': [0.0, 1.0, 0.1],
            'farming': [0.0, 1.0, 0.1],
            'personality': [1.0, 4.0, 0.5] 
        };
        // *** END SYNCED CONSTANTS ***

        const COLORS = {
            CYAN_BRIGHT: '#22d3ee', // A
            CYAN_NORMAL: '#06b6d4', // f
            MAGENTA_BRIGHT: '#d946ef', // m, L (Seek Library), M (Seek Mate)
            MAGENTA_DIM: '#a855f7', // s
            WHITE_BRIGHT: '#ffffff', // T, g, wellbeing
            WHITE_NORMAL: '#f3f4f6', // t
            YELLOW_BRIGHT: '#fcd34d', // b, W
            YELLOW_NORMAL: '#f59e0b', // w, E
            RED_BRIGHT: '#f87171', // X, r, V, R, C
            RED_NORMAL: '#ef4444', // c
            BLUE_BRIGHT: '#60a5fa', // H, C, k
            BLUE_NORMAL: '#3b82f6', // B, h
            BLUE_DIM: '#1d4ed8', // S(remote spot), .
            GREEN_BRIGHT: '#4ade80', // F, G
            GREEN_NORMAL: '#10b981', // p, P
            GREEN_DIM: '#059669', // T (Tree)
            LIBRARY: '#a855f7', // L (Structure)
        };
        
        const CHAR_MAP = {
            'WANDERING': { char: 'A', color: COLORS.CYAN_BRIGHT, dim: false },
            'FORAGING': { char: 'f', color: COLORS.CYAN_NORMAL, dim: false },
            'BUILDING': { char: 'b', color: COLORS.YELLOW_BRIGHT, dim: false },
            'WANDERING_TO_BUILD': { char: 'B', color: COLORS.BLUE_NORMAL, dim: false },
            'SEEKING_COMMUNITY': { char: 'C', color: COLORS.BLUE_BRIGHT, dim: false },
            'SEEKING_REMOTE_SPOT': { char: 'S', color: COLORS.BLUE_DIM, dim: true },
            'GETTING_WOOD': { char: 'w', color: COLORS.YELLOW_NORMAL, dim: false },
            'PLANTING': { char: 'p', color: COLORS.GREEN_NORMAL, dim: false },
            'PLANTING_WOOD': { char: 'p', color: COLORS.GREEN_NORMAL, dim: false },
            'GOING_HOME_TO_FARM': { char: 'G', color: COLORS.GREEN_BRIGHT, dim: false },
            'GOING_HOME_TO_PLANT_WOOD': { char: 'G', color: COLORS.GREEN_BRIGHT, dim: false },
            'SHARING': { char: 'g', color: COLORS.WHITE_BRIGHT, dim: false },
            'BUILDING_CAMPFIRE': { char: 'c', color: COLORS.RED_NORMAL, dim: false },
            'REPAIRING_HOME': { char: 'E', color: COLORS.YELLOW_NORMAL, dim: false },
            'CLAIMING_HOME': { char: 'k', color: COLORS.BLUE_BRIGHT, dim: false },
            'REFUELING_CAMPFIRE': { char: 'R', color: COLORS.RED_BRIGHT, dim: false },
            'MATING': { char: 'm', color: COLORS.MAGENTA_BRIGHT, dim: false },
            'SEEKING_MATE': { char: 'M', color: COLORS.MAGENTA_BRIGHT, dim: false }, // <-- NEW
            'ATTACKING': { char: 'X', color: COLORS.RED_BRIGHT, dim: false },
            'RETALIATING': { char: 'r', color: COLORS.RED_BRIGHT, dim: false },
            'AVENGING': { char: 'V', color: COLORS.RED_BRIGHT, dim: false },
            'SEEKING_SOCIAL': { char: 't', color: COLORS.WHITE_NORMAL, dim: false },
            'COMMUNICATING': { char: 'T', color: COLORS.WHITE_BRIGHT, dim: false },
            'SEEKING_LIBRARY': { char: 'L', color: COLORS.MAGENTA_BRIGHT, dim: false },
            'SOCIAL_SAD': { char: 's', color: COLORS.MAGENTA_DIM, dim: true },
            'SOCIAL_HAPPY': { char: 'o', color: COLORS.MAGENTA_BRIGHT, dim: false },
        };

        // --- HELPERS ---

        function clamp(value, minVal, maxVal) {
            return Math.max(minVal, Math.min(value, maxVal));
        }

        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }
        
        function arrayToKey(arr) {
            return `${arr[0]},${arr[1]}`;
        }
        
        function keyToArray(key) {
            return key.split(',').map(Number);
        }

        // --- AGENT CLASS ---

        class Agent {
            constructor(x, y, world, genes = null) {
                this.world = world;
                this.x = x;
                this.y = y;
                this.char = 'A';
                this.id = this.world.getNextAgentId();
                this.energy = 150;
                this.wood_carried = 0;
                this.food_carried = 0;
                this.mate_cooldown = 0;
                this.seeds_carried = Math.floor(Math.random() * 3);
                this.wood_seeds_carried = Math.floor(Math.random() * 2);
                this.social = Math.random() * (80.0 - 30.0) + 30.0;
                this.home_location = null;
                this.campfire_location = null;
                this.social_buff_timer = 0;
                this.contentment_buff_timer = 0;
                this.apathy_timer = 0; 
                this.state = "WANDERING";
                this.exploration_vector = [0, 0];
                this.memory = { 
                    'food': new Set(), 
                    'wood': new Set(),
                    'library': null // <-- NEW (from Python)
                };
                this.struggle_timer = 0;
                this.was_attacked_by = null;
                
                // --- Vengeance System ---
                this.avenging_target_id = null; 
                this.vengeance_timer = 0;
                
                this.age = 0;
                this.children_ids = new Set();
                this.parent_ids = new Set(); 
                
                this.love = simSettings.STARTING_LOVE;
                this.skills = {
                    'foraging': 0.0, 'social': 0.0, 'building': 0.0,
                    'navigation': 0.0, 'combat': 0.0, 'farming': 0.0
                };

                if (genes) {
                    this.genes = genes;
                } else {
                    this.genes = this.createRandomGenes(this.world.agents.length < simSettings.STARTING_AGENTS);
                }
            }

            createRandomGenes(stabilize = false) {
                // *** SYNCED WITH life_simulation2.py ***
                const genes = {};
                for (const gene in GENE_RANGES) {
                    const [minVal, maxVal] = GENE_RANGES[gene];
                    if (stabilize) {
                        if (gene === 'metabolism') {
                            genes[gene] = Math.random() * (0.8 - 0.5) + 0.5;
                        } else if (gene === 'speed') {
                            genes[gene] = Math.random() * (3.0 - 1.0) + 1.0;
                        } else if (gene === 'personality') {
                            if (Math.random() < 0.8) {
                                genes[gene] = Math.floor(Math.random() * (PERSONALITY_ISOLATED - PERSONALITY_COOPERATIVE + 1)) + PERSONALITY_COOPERATIVE;
                            } else {
                                genes[gene] = Math.floor(Math.random() * (PERSONALITY_AGGRESSIVE_COOPERATOR - PERSONALITY_JUDGMENTAL + 1)) + PERSONALITY_JUDGMENTAL;
                            }
                        } else {
                            genes[gene] = Math.random() * (maxVal - minVal) + minVal;
                        }
                    } else {
                        genes[gene] = Math.random() * (maxVal - minVal) + minVal;
                    }
                }
                return genes;
            }

            getPersonality() {
                // *** SYNCED WITH life_simulation2.py ***
                return Math.floor(clamp(this.genes.personality || 1, 1, 4));
            }

            update() {
                // *** SYNCED WITH life_simulation2.py ***

                // 1. Update Age and Check for Death
                this.age += 1;
                
                if (this.age >= simSettings.MAX_AGE) {
                    this.die('MAX_AGE');
                    return;
                }
                
                if (this.age >= simSettings.OLD_AGE && this.energy < 100) { 
                    this.die('NATURAL_DEATH_OLD');
                    return;
                }
                
                // 2. Update basic needs
                let metabolismCost = this.genes['metabolism'];
                
                // --- Parental Care Cost ---
                let livingChildrenUnderAge = 0;
                for (const childId of Array.from(this.children_ids)) {
                    const child = this.world.getAgentById(childId);
                    if (child) {
                        if (child.age < simSettings.ADULT_AGE) {
                            livingChildrenUnderAge++;
                        } else {
                            this.children_ids.delete(childId); // Child is an adult, remove from list
                        }
                    } else {
                        this.children_ids.delete(childId); // Child is dead
                    }
                }

                const parentalCost = livingChildrenUnderAge * 0.2;

                if (this.age < simSettings.ADULT_AGE) {
                    metabolismCost = parentalCost;
                    if (this.energy < 50) { 
                        this.die('STARVATION_CHILD');
                        return;
                    }
                } else {
                    metabolismCost += parentalCost;
                }
                // --- END FIX ---

                // Home buff (Family/Owner only)
                const currentPosKey = arrayToKey([this.x, this.y]);
                if (this.world.homes[currentPosKey]) {
                    const homeData = this.world.homes[currentPosKey];
                    const ownerId = homeData.owner_id;
                    const isOwner = (this.id === ownerId);
                    let isFamily = false;

                    if (ownerId !== null) {
                        const ownerAgent = this.world.getAgentById(ownerId);
                        if (ownerAgent && ownerAgent.children_ids.has(this.id)) {
                            isFamily = true;
                        }
                    }

                    if (isOwner || isFamily) {
                        metabolismCost *= 0.5;
                        if (this.energy < 150) {
                            this.energy = clamp(this.energy + 2.0, 0, 150);
                        }
                        this.social = clamp(this.social + 0.5, 0, 100);
                    }
                }
                // --- END Home buff ---
                    
                // Social buff (Campfire is communal)
                if (this.social_buff_timer > 0) {
                    metabolismCost *= 0.8;
                    this.social_buff_timer--;
                }
                
                // Check if the agent's OWNED campfire is still active
                if (this.campfire_location && !this.world.campfires[this.campfire_location]) {
                     this.campfire_location = null; 
                }
                    
                // Check for "Cozy" buff from a nearby campfire
                const nearbyCampfirePosKey = this.world.getNearest(this.x, this.y, 2, this.world.campfires);
                if (nearbyCampfirePosKey) {
                    metabolismCost *= 0.9;
                    this.social = clamp(this.social + 0.5, 0, 100);
                }
                    
                // --- APATHY SYSTEM UPDATE ---
                if (this.apathy_timer > 0) {
                    metabolismCost += simSettings.APATHY_METABOLISM_PENALTY; 
                    this.apathy_timer--;
                }
                // --- END APATHY SYSTEM UPDATE ---
                    
                // --- VENGEANCE TIMER UPDATE ---
                if (this.vengeance_timer > 0) {
                    this.vengeance_timer--;
                    if (this.vengeance_timer === 0) {
                        this.avenging_target_id = null; // Timer ran out, stop avenging
                    }
                }
                // --- END NEW ---
                    
                this.energy -= metabolismCost;
                if (this.mate_cooldown > 0) {
                    this.mate_cooldown--;
                }
                    
                // Update Social Need
                let socialLossMultiplier = 1.0;
                if (this.apathy_timer > 0) {
                    socialLossMultiplier = simSettings.APATHY_SOCIAL_LOSS_MULTIPLIER; 
                }

                if (this.contentment_buff_timer > 0) {
                    this.contentment_buff_timer--;
                } else {
                    const visionRadius = Math.floor(this.genes['vision']);
                    const nearbyAgents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                    if (nearbyAgents.length === 0 && !nearbyCampfirePosKey) { 
                        this.social -= this.genes['sociability'] * 0.5 * socialLossMultiplier;
                    } else {
                        this.social += 0.1;
                    }
                    this.social = clamp(this.social, 0, 100);
                }
                    
                // --- Update Struggle Timer (Love Loss happens here) ---
                if (this.energy < 30 || this.social < 20) {
                    this.struggle_timer++;
                    this.love = clamp(this.love - simSettings.LOVE_LOSS_STRUGGLE, 0, simSettings.STARTING_LOVE);
                } else {
                    this.struggle_timer = 0;
                    // PASSIVE_LOVE_GAIN is 0.0 in Python
                }
                    
                // --- Check for Apathy Trigger ---
                if (this.love <= 0 && this.apathy_timer === 0) {
                    this.apathy_timer = simSettings.APATHY_DURATION;
                }
                // --- END APATHY TRIGGER ---
                    
                // --- Global Knowledge Retrieval (The Library Effect) ---
                for (const skillKey in this.skills) {
                    const globalValue = this.world.globalSkillKnowledge[skillKey] || 0.0;
                    const currentSkill = this.skills[skillKey];
                    if (currentSkill < globalValue) {
                        this.skills[skillKey] = clamp(currentSkill + 0.0001, 0, 10.0); 
                    }
                }
                // --- END NEW ---

                // 3. Check for death
                if (this.energy <= 0) {
                    // --- MODIFIED: Safeguard against double-death logging ---
                    if (!this.world.agents.includes(this)) {
                        return;
                    }
                    // --- END MODIFIED ---
                    this.die('STARVATION_ADULT');
                    return;
                }

                // 4. Decide what to do
                this.decideState();
                
                // 5. Execute the action
                this.executeAction();
            }

            decideState() {
                // *** COMPLETELY OVERHAULED to match life_simulation2.py ***
                const visionRadius = Math.floor(this.genes['vision']);

                // --- Opportunistic Socializing ---
                // Check for agents right next to self (radius 1.5)
                const nearbyAgents = this.world.getNearestAgents(this.x, this.y, 1.5, this);

                if (nearbyAgents.length > 0) {
                    // Avoid chatting if in crisis or combat
                    if (!(this.apathy_timer > 0 || this.was_attacked_by !== null || this.avenging_target_id !== null)) {
                        const target = nearbyAgents[Math.floor(Math.random() * nearbyAgents.length)];

                        // Don't chat with someone in combat or already chatting
                        if (!(target.was_attacked_by !== null || target.avenging_target_id !== null || target.state === "COMMUNICATING")) {
                            
                            let chance = 0.0;
                            
                            // Check if self is lingering/happy
                            const isLingering = (this.state === "WANDERING" || this.state === "SOCIAL_HAPPY") && 
                                              this.energy > simSettings.PAUSE_ENERGY_THRESHOLD && 
                                              this.social > simSettings.PAUSE_SOCIAL_THRESHOLD;
                            
                            if (isLingering) {
                                chance = 0.6; // High chance to chat if lingering
                            }
                            // If I'm just wandering or working, smaller chance
                            else if (["WANDERING", "FORAGING", "GETTING_WOOD"].includes(this.state) &&
                                 this.social > 50 && this.genes.sociability > 0.5) {
                                
                                chance = 0.1; // Small chance to pause and chat
                            }
                            
                            if (Math.random() < chance) {
                                this.communicate(target); // This sets both states
                                return; // This is our action for the turn
                            }
                        }
                    }
                }
                // --- END: Opportunistic Socializing ---
                
                const foodInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.food);
                
                const conserveEnergy = this.genes.metabolism < 0.8 && this.energy < 100;
                
                // --- Check Global Food Crisis for Mandated Action ---
                const globalFoodCrisis = Object.keys(this.world.food).length < simSettings.CRITICAL_FOOD_COUNT;
                const populationLow = this.world.agents.length < simSettings.MIN_POPULATION_TARGET;
                
                // --- Vengeance System Priority ---
                // Priority -2: Avenging
                if (this.avenging_target_id !== null) { // Timer logic is handled in update()
                    // Check if target still exists
                    const target = this.world.getAgentById(this.avenging_target_id);
                    if (target) {
                        this.state = "AVENGING";
                        return;
                    } else {
                        // Target is dead, vengeance is over
                        this.avenging_target_id = null;
                        this.vengeance_timer = 0; // Clear timer just in case
                    }
                }
                // --- END NEW ---

                // Priority -1: Retaliation
                if (this.was_attacked_by !== null) {
                    this.state = "RETALIATING"; 
                    return;
                }
                
                // Priority 0: Hopeless/Sad
                if ((this.energy < 20 || this.social < 10) && foodInSight.length === 0 && this.memory.food.size === 0) {
                    this.state = "SOCIAL_SAD"; 
                    return;
                }
                    
                // --- CRITICAL SURVIVAL OVERRIDES (MOVED TO HIGH PRIORITY) ---
                
                // Mandate 1: Plant if Food Crisis or Low Population, AND I have seeds
                if ((globalFoodCrisis || populationLow) && this.seeds_carried > 0) {
                    if (this.home_location) {
                        const [hx, hy] = keyToArray(this.home_location);
                        const dist = getDistance(this.x, this.y, hx, hy);
                        if (dist > 5) { 
                            this.state = "GOING_HOME_TO_FARM"; 
                        } else {
                            this.state = "PLANTING"; 
                        }
                    } else {
                        this.state = "PLANTING"; 
                    }
                    return;
                }

                // Mandate 2: Share if others are desperately needy
                if (this.energy > 100 && this.social > 50 && (this.wood_carried > 3 || this.food_carried >= 1)) {
                    const allNearbyAgents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                    // Check for agents with CRITICALLY low energy (forcing immediate share)
                    const needyAgents = allNearbyAgents.filter(a => a.energy < 40 && a.food_carried < 1); 
                    if (needyAgents.length > 0) {
                        this.state = "SHARING"; 
                        return;
                    }
                }
                // --- END CRITICAL SURVIVAL OVERRIDES ---

                // --- Mandate 3: Seek a mate if population is critically low ---
                if (populationLow && this.age >= simSettings.ADULT_AGE && 
                   this.energy > this.genes.mating_drive && this.mate_cooldown === 0) {
                    
                    this.state = "SEEKING_MATE";
                    return; 
                }
                // --- END Mandate 3 ---

                // Priority 1: Survival (Energy)
                let forageThreshold = 70; 
                if (this.age < simSettings.ADULT_AGE) { 
                    forageThreshold = 100; 
                }
                    
                if (this.energy < forageThreshold || (this.food_carried > 0 && this.energy < 150)) {
                    this.state = "FORAGING"; 
                    return;
                }
                    
                // Priority 1.5: Campfire Refuel
                const nearbyCampfirePosKey = this.world.getNearest(this.x, this.y, visionRadius, this.world.campfires);
                if (nearbyCampfirePosKey) {
                    const campfireTimer = this.world.campfires[nearbyCampfirePosKey];
                    if (campfireTimer && campfireTimer < simSettings.CAMPFIRE_REFUEL_THRESHOLD) {
                        if (this.wood_carried < 1) {
                            this.state = "GETTING_WOOD"; 
                            return;
                        } else {
                            this.state = "REFUELING_CAMPFIRE"; 
                            return;
                        }
                    }
                }

                // Priority 2: Home Repair (MODIFIED: Repair if durability is not max)
                if (this.home_location) {
                    const homeData = this.world.homes[this.home_location];
                    
                    // Check if the home exists, durability is less than max, AND the agent is the owner
                    const isOwner = homeData && homeData.owner_id === this.id;
                    // FIX: Check if durability is less than max (HOME_DURABILITY_START is 3)
                    if (homeData && homeData.durability < simSettings.HOME_DURABILITY_START && isOwner) { 
                        if (this.wood_carried < 1) {
                            this.state = "GETTING_WOOD"; 
                            return;
                        } else {
                            this.state = "REPAIRING_HOME"; 
                            return;
                        }
                    }
                }

                // Priority 3: Social Need (MODIFIED: Check social more often)
                // FIX: Raised social threshold from 30 to 60
                if (this.social < 60 && this.genes.sociability > 0.2) {
                    this.state = "SEEKING_SOCIAL"; 
                    return;
                }
                    
                // Priority 4: Claim or Build Home (MODIFIED: Only if agent has NO home)
                if (this.home_location === null) {
                    // Step 1: Try to claim an empty one
                    const emptyHomePos = this.world.getEmptyHome();
                    if (emptyHomePos) {
                        this.state = "CLAIMING_HOME"; 
                        return;
                    }
                    
                    // Step 2: If no empty homes AND pop > homes, build one
                    else if ((Object.keys(this.world.homes).length < this.world.agents.length) && (this.genes.builder > Math.random())) {
                        
                        if (conserveEnergy) {
                            this.state = "FORAGING"; 
                            return;
                        }
                        
                        let woodCostNeeded = 3 - Math.floor(this.skills.building * 0.5);
                        if (woodCostNeeded < 1) woodCostNeeded = 1;
                        
                        if (this.wood_carried < woodCostNeeded) {
                            this.state = "GETTING_WOOD"; 
                            return;
                        }
                        
                        const communityRadius = visionRadius + 5; 
                        const nearbyHomes = this.world.getNearest(this.x, this.y, communityRadius, this.world.homes);
                        const isSocial = this.genes.sociability > 0.5;

                        if (this.isClearTile(this.x, this.y)) {
                            if (isSocial) {
                                if (nearbyHomes || Object.keys(this.world.homes).length === 0) {
                                    this.state = "BUILDING"; 
                                } else {
                                    this.state = "SEEKING_COMMUNITY"; 
                                }
                            } else {
                                if (!nearbyHomes) {
                                    this.state = "BUILDING"; 
                                } else {
                                    this.state = "SEEKING_REMOTE_SPOT"; 
                                }
                            }
                        } else {
                            if (isSocial) {
                                if (nearbyHomes || Object.keys(this.world.homes).length === 0) {
                                    this.state = "WANDERING_TO_BUILD"; 
                                } else {
                                    this.state = "SEEKING_COMMUNITY"; 
                                }
                            } else {
                                if (!nearbyHomes) {
                                    this.state = "WANDERING_TO_BUILD"; 
                                } else {
                                    this.state = "SEEKING_REMOTE_SPOT"; 
                                }
                            }
                        }
                        return;
                    }
                }
                
                // Priority 5: Farming (Food Seeds) - Normal Planting (if no crisis)
                if (this.seeds_carried > 0 && this.energy > 80 && this.genes.farming > Math.random()) {
                    if (this.home_location) {
                        const [hx, hy] = keyToArray(this.home_location);
                        const dist = getDistance(this.x, this.y, hx, hy);
                        if (dist > 5) { 
                            this.state = "GOING_HOME_TO_FARM"; 
                        } else {
                            this.state = "PLANTING"; 
                        }
                    } else {
                        this.state = "PLANTING"; 
                    }
                    return;
                }

                // Priority 5.5: Planting Trees (if wood is scarce)
                if (this.wood_seeds_carried > 0 && this.energy > 80 && 
                   (Object.keys(this.world.wood).length < simSettings.STARTING_WOOD) && (this.genes.builder > Math.random())) { 
                    if (this.home_location) {
                        const [hx, hy] = keyToArray(this.home_location);
                        const dist = getDistance(this.x, this.y, hx, hy);
                        if (dist > 5) {
                            this.state = "GOING_HOME_TO_PLANT_WOOD"; 
                        } else {
                            this.state = "PLANTING_WOOD";
                        }
                    } else {
                        this.state = "PLANTING_WOOD"; 
                    }
                    return;
                }
                    
                // Priority 6: Build Campfire (MODIFIED: Only if no nearby active fire)
                // Check if there is a fire *near* the agent, not just if the agent owns one
                const nearbyActiveFire = this.world.getNearest(this.x, this.y, 5, this.world.campfires);

                if (this.energy > 120 && this.social > 50 && 
                   this.genes.builder > 0.5 && 
                   nearbyActiveFire === null && 
                   this.campfire_location === null) { // NEW RULE: Can't build if I already own one 
                   
                    if (conserveEnergy) {
                        this.state = "FORAGING"; 
                        return;
                    }
                    
                    let woodCostNeeded = simSettings.CAMPFIRE_WOOD_COST - Math.floor(this.skills.building * 0.5);
                    if (woodCostNeeded < 1) woodCostNeeded = 1;
                    
                    if (this.wood_carried >= woodCostNeeded) {
                         this.state = "BUILDING_CAMPFIRE"; 
                         return;
                    } else if (this.wood_carried < woodCostNeeded) {
                         this.state = "GETTING_WOOD";
                         return;
                    }
                }
                    
                // Priority 7: Share Resources (Standard Share, if energy > 70)
                if (this.energy > 100 && this.social > 50 && (this.wood_carried > 3 || this.food_carried >= 1)) {
                    const allNearbyAgents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                    const needyAgents = allNearbyAgents.filter(a => a.energy < 70 && a.food_carried < 1); 
                    if (needyAgents.length > 0) {
                        this.state = "SHARING"; 
                        return;
                    }
                }
                    
                // Default State: Wandering
                // Priority 8: Happy/Content
                this.state = "WANDERING";
            }

            executeAction() {
                // *** SYNCED WITH life_simulation2.py ***
                const visionRadius = Math.floor(this.genes['vision']);
                
                // 1. Check ALL visible resources
                const foodInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.food);
                const woodInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.wood);
                const agents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                
                // --- NEW: Check for Library in sight ---
                if (this.memory.library === null) {
                    const [lx, ly] = this.world.libraryLocation;
                    if (getDistance(this.x, this.y, lx, ly) <= visionRadius) {
                        this.memory.library = [lx, ly];
                    }
                }
                // --- END NEW ---

                // 2. Get nearest target from combined vision and memory
                const bestFoodTarget = this.getClosestCombinedTarget('food', foodInSight);
                const bestWoodTarget = this.getClosestCombinedTarget('wood', woodInSight);

                // --- Handle "Anger" (Aggression) ---
                const agentsOnTile = this.world.agents.filter(a => a.x === this.x && a.y === this.y && a !== this);
                if (agentsOnTile.length > 0) {
                    const target = agentsOnTile[Math.floor(Math.random() * agentsOnTile.length)];
                    
                    const baseAggression = this.genes['aggression'];
                    const struggleBonus = Math.min(this.struggle_timer * 0.0005, 0.5); 
                    const dynamicAggression = baseAggression + struggleBonus;
                    
                    // --- COMBAT LOCK CHECK: Love is ZERO and Energy is high enough ---
                    if (this.love <= 0 && this.energy > 80 && Math.random() < dynamicAggression) {
                        this.attack(target, 'COMBAT_AGGRESSION');
                        return; 
                    }
                }
                
                // --- Execute State ---
                switch (this.state) {
                    case "FORAGING":
                        // --- MODIFIED: Check for needy neighbors before eating carried food ---
                        const currentPosKey = arrayToKey([this.x, this.y]);
                        if (this.food_carried > 0 && this.energy < 150) { 
                            
                            const needyNeighbors = agents.filter(a => a.energy < 40 && a.food_carried < 1);
                            
                            // Only consume if no neighbor is critically starving
                            if (needyNeighbors.length === 0) {
                                this.consumeFood();
                            } else {
                                // If neighbors are starving, switch to sharing mode
                                this.state = "SHARING";
                                return;
                            }
                            
                        } else if (this.world.food[currentPosKey] && this.food_carried < 2) { 
                            this.pickupFood();
                        } else if (bestFoodTarget) { 
                            this.moveTowards(bestFoodTarget[0], bestFoodTarget[1]);
                            if (getDistance(this.x, this.y, bestFoodTarget[0], bestFoodTarget[1]) < 2.0) {
                                if (!this.world.food[arrayToKey(bestFoodTarget)]) {
                                    this.memory.food.delete(arrayToKey(bestFoodTarget));
                                }
                            }
                        } else {
                            this.moveExploring(); 
                        }
                        break;
                    // --- END MODIFIED FORAGING ---

                    case "GETTING_WOOD":
                        const currentWoodPosKey = arrayToKey([this.x, this.y]);
                        if (this.wood_carried >= 3) { 
                            this.state = "WANDERING";
                            return;
                        }
                        if (this.world.wood[currentWoodPosKey] && this.wood_carried < 3) {
                            this.takeWood();
                        } else if (bestWoodTarget) { 
                            this.moveTowards(bestWoodTarget[0], bestWoodTarget[1]);
                             if (getDistance(this.x, this.y, bestFoodTarget[0], bestFoodTarget[1]) < 2.0) {
                                if (!this.world.wood[arrayToKey(bestFoodTarget)]) {
                                    this.memory.wood.delete(arrayToKey(bestWoodTarget));
                                }
                            }
                        } else {
                            this.moveExploring();
                        }
                        break;

                    case "BUILDING":
                        this.buildHome();
                        break;

                    case "REPAIRING_HOME":
                        if (this.home_location) {
                            const [hx, hy] = keyToArray(this.home_location);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist < 2.0) {
                                if (this.wood_carried > 0) {
                                    // FIX: Repair to max durability
                                    this.world.homes[this.home_location].durability = simSettings.HOME_DURABILITY_START;
                                    this.wood_carried--;
                                    this.skills.building = clamp(this.skills.building + 0.2, 0, 4.0);
                                    this.state = "WANDERING";
                                } else {
                                    this.state = "GETTING_WOOD";
                                }
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "REFUELING_CAMPFIRE":
                        const nearbyCampfireKey = this.world.getNearest(this.x, this.y, visionRadius, this.world.campfires);
                        if (nearbyCampfireKey) {
                            const [cx, cy] = keyToArray(nearbyCampfireKey);
                            const dist = getDistance(this.x, this.y, cx, cy);
                            if (dist < 2.0) {
                                if (this.wood_carried > 0) {
                                    this.world.campfires[nearbyCampfireKey] = simSettings.CAMPFIRE_BURN_TIME;
                                    this.wood_carried--;
                                    this.state = "WANDERING";
                                } else {
                                    this.state = "GETTING_WOOD";
                                }
                            } else {
                                this.moveTowards(cx, cy);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "CLAIMING_HOME":
                        const emptyHomePos = this.world.getEmptyHome();
                        if (emptyHomePos) {
                            const [hx, hy] = keyToArray(emptyHomePos);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist < 2.0) {
                                this.world.homes[emptyHomePos].owner_id = this.id;
                                this.home_location = emptyHomePos;
                                this.state = "WANDERING";
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "WANDERING_TO_BUILD":
                        this.moveRandomly(0.5, 0.0);
                        break;

                    case "SEEKING_COMMUNITY":
                        // Find *any* home
                        const allHomeKeys = Object.keys(this.world.homes);
                        if (allHomeKeys.length > 0) {
                            // Find the nearest one
                            let nearestDist = Infinity;
                            let nearestHomePos = null;
                            for (const homeKey of allHomeKeys) {
                                const [hx, hy] = keyToArray(homeKey);
                                const dist = getDistance(this.x, this.y, hx, hy);
                                if (dist < nearestDist) {
                                    nearestDist = dist;
                                    nearestHomePos = [hx, hy];
                                }
                            }
                            this.moveTowards(nearestHomePos[0], nearestHomePos[1]);
                        } else {
                            this.moveExploring();
                        }
                        break;

                    case "SEEKING_REMOTE_SPOT":
                        this.moveExploring();
                        break;
                    
                    case "GOING_HOME_TO_FARM":
                        if (this.home_location) {
                            const [hx, hy] = keyToArray(this.home_location);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist <= 5.0) {
                                this.state = "PLANTING";
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "PLANTING";
                        }
                        break;

                    case "PLANTING":
                        if (this.isClearTile(this.x, this.y)) {
                            this.plantSeed();
                        } else {
                            this.moveRandomly(0.5, 0.0);
                        }
                        break;

                    case "GOING_HOME_TO_PLANT_WOOD":
                        if (this.home_location) {
                            const [hx, hy] = keyToArray(this.home_location);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist <= 5.0) {
                                this.state = "PLANTING_WOOD";
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "PLANTING_WOOD";
                        }
                        break;

                    case "PLANTING_WOOD":
                        if (this.isClearTile(this.x, this.y)) {
                            this.plantTree();
                        } else {
                            this.moveRandomly(0.5, 0.0);
                        }
                        break;
                        
                    case "BUILDING_CAMPFIRE":
                        if (this.isClearTile(this.x, this.y)) {
                            this.buildCampfire();
                        } else {
                            this.moveRandomly(0.5, 0.0);
                        }
                        break;

                    case "SHARING":
                        // Prioritize critically low agents (energy < 40)
                        let needyAgents = agents.filter(a => a.energy < 40 && a.food_carried < 1); 
                        
                        // If no critically needy agents, target standard needy agents (energy < 70)
                        if (needyAgents.length === 0) {
                             needyAgents = agents.filter(a => a.energy < 70 && a.food_carried < 1); 
                        }

                        if (needyAgents.length > 0) {
                            const target = needyAgents[0];
                            if (getDistance(this.x, this.y, target.x, target.y) < 2.0) {
                                if (this.food_carried >= 1) {
                                    this.food_carried--;
                                    target.food_carried++;
                                    this.state = "WANDERING"; 
                                } else if (this.wood_carried >= 1) {
                                    this.wood_carried--;
                                    target.wood_carried++;
                                    this.state = "WANDERING";
                                } else {
                                     this.state = "WANDERING";
                                }
                            } else {
                                this.moveTowards(target.x, target.y);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "MATING":
                        // Agent is waiting, partner logic will find them
                        break;
                    
                    case "RETALIATING":
                        const attacker = this.world.getAgentById(this.was_attacked_by);
                        if (attacker) {
                            const dist = getDistance(this.x, this.y, attacker.x, attacker.y);
                            if (dist < 2.0) {
                                this.attack(attacker, 'COMBAT_RETALIATION');
                                this.was_attacked_by = null;
                            } else {
                                this.moveTowards(attacker.x, attacker.y);
                            }
                        } else {
                            this.was_attacked_by = null;
                            this.state = "WANDERING";
                        }
                        break;
                    
                    // --- NEW: Vengeance State ---
                    case "AVENGING":
                        const targetParent = this.world.getAgentById(this.avenging_target_id);
                        if (targetParent) {
                            
                            // --- Recruit nearby agents (The 'Posse' logic) ---
                            const recruitVision = Math.floor(this.genes['vision']);
                            const potentialRecruits = this.world.getNearestAgents(this.x, this.y, recruitVision, this)
                                .filter(a => a.id !== targetParent.id && a.avenging_target_id === null);
                            
                            for (const recruit of potentialRecruits) {
                                const roll = Math.random();
                                let chance = recruit.genes['aggression'] * 0.5;
                                const p = recruit.getPersonality();
                                
                                if (p === PERSONALITY_AGGRESSIVE_COOPERATOR) {
                                    chance += 0.4;
                                } else if (p === PERSONALITY_COOPERATIVE) {
                                    chance += 0.1;
                                } else if (p === PERSONALITY_ISOLATED) {
                                    chance -= 0.3;
                                }
                                
                                if (roll < chance) {
                                    recruit.state = "AVENGING";
                                    recruit.avenging_target_id = this.avenging_target_id; // Hunt same target
                                    recruit.vengeance_timer = VENGEANCE_DURATION;
                                }
                            }
                            // --- END: Recruit logic ---

                            const dist = getDistance(this.x, this.y, targetParent.x, targetParent.y);
                            if (dist < 2.0) {
                                this.attack(targetParent, 'COMBAT_VENDETTA');
                                // Vengeance continues until target is dead or timer runs out
                            } else {
                                this.moveTowards(targetParent.x, targetParent.y);
                            }
                        } else {
                            // Target is dead. Vengeance is over.
                            this.avenging_target_id = null;
                            this.vengeance_timer = 0;
                            this.state = "WANDERING";
                        }
                        break;
                    // --- END: Vengeance State ---

                    // --- NEW: Seeking Mate State ---
                    case "SEEKING_MATE":
                        // Find the nearest agent who is ALSO eligible to mate
                        const eligiblePartners = [];
                        const mateVision = Math.floor(this.genes['vision']); // Use vision
                        
                        const nearbyAgentsForMating = this.world.getNearestAgents(this.x, this.y, mateVision, this);

                        for (const agent of nearbyAgentsForMating) {
                            if (agent.age >= simSettings.ADULT_AGE && 
                               agent.energy > agent.genes.mating_drive && 
                               agent.mate_cooldown === 0) {
                                eligiblePartners.push(agent);
                            }
                        }

                        if (eligiblePartners.length > 0) {
                            // Target the nearest one
                            eligiblePartners.sort((a, b) => getDistance(this.x, this.y, a.x, a.y) - getDistance(this.x, this.y, b.x, b.y));
                            const target = eligiblePartners[0];

                            if (getDistance(this.x, this.y, target.x, target.y) < 2.0) {
                                // Found them! Initiate mating.
                                this.mate(target);
                            } else {
                                // Move towards them
                                this.moveTowards(target.x, target.y);
                            }
                        } else {
                            // No eligible partners in sight, wander to find one
                            this.moveExploring();
                        }
                        break;
                    // --- END NEW ---
                    
                    case "SEEKING_SOCIAL":
                        const nearbyCampfire = this.world.getNearest(this.x, this.y, visionRadius, this.world.campfires);
                        
                        // --- MODIFIED LOGIC: Prioritize nearby happy, pausing agents ---
                        let targetAgent = null;
                        
                        const happyAgents = this.world.getNearestAgents(this.x, this.y, 3, this);
                        const happyAndPausing = happyAgents.filter(
                            a => a.energy > simSettings.PAUSE_ENERGY_THRESHOLD && a.social > simSettings.PAUSE_SOCIAL_THRESHOLD
                        );
                        
                        if (happyAndPausing.length > 0) {
                            happyAndPausing.sort((a, b) => b.social - a.social);
                            targetAgent = happyAndPausing[0];
                        }
                        // If no happy pausers, default to the nearest agent in vision
                        else if (agents.length > 0) {
                            targetAgent = agents[0];
                        }
                            
                        if (targetAgent) {
                            if (getDistance(this.x, this.y, targetAgent.x, targetAgent.y) < 2.0) {
                                this.communicate(targetAgent);
                            } else {
                                this.moveTowards(targetAgent.x, targetAgent.y);
                            }
                        } else if (nearbyCampfire) {
                             const [cx, cy] = keyToArray(nearbyCampfire);
                            this.moveTowards(cx, cy);
                        } else {
                            // --- MODIFICATION: The "Lonely Agent" Fix ---
                            // If no one is around, go to the Library (L) *if they know where it is*.
                            if (this.memory.library) { // <-- FIXED
                                const [lx, ly] = this.memory.library;
                                this.moveTowards(lx, ly);
                                this.state = "SEEKING_LIBRARY"; 
                            } else {
                                // Don't know where library is, just wander hopelessly
                                this.moveExploring();
                            }
                            // --- END MODIFICATION ---
                        }
                        break;
                    
                    case "SOCIAL_HAPPY": 
                        if (this.energy > simSettings.PAUSE_ENERGY_THRESHOLD && this.social > simSettings.PAUSE_SOCIAL_THRESHOLD) {
                            
                            // FIX: New logic - Small chance to move to the Library (L) when content
                            // --- MODIFIED: Must *know* where library is to go ---
                            if (Math.random() < 0.2 && this.memory.library) { // <-- FIXED
                                const [lx, ly] = this.memory.library;
                                if (getDistance(this.x, this.y, lx, ly) > 5.0) {
                                    this.moveTowards(lx, ly);
                                    this.state = "SEEKING_LIBRARY"; 
                                    return;
                                }
                            }
                            // Linger/observe
                        } else {
                            this.moveRandomly(0.5, 0.0); 
                        }
                        break; 
                    
                    case "SOCIAL_SAD":
                        this.love = clamp(this.love + simSettings.LOVE_GAIN_REST, 0, simSettings.STARTING_LOVE);
                        
                        if (this.energy < 20 && bestFoodTarget) {
                            this.moveTowards(bestFoodTarget[0], bestFoodTarget[1]);
                        
                        } else if (this.social < 10) {
                            const nearestCampfireSad = this.world.getNearest(this.x, this.y, visionRadius, this.world.campfires);
                            if (agents.length > 0) {
                                this.moveTowards(agents[0].x, agents[0].y);
                            } else if (nearestCampfireSad) {
                                const [cx, cy] = keyToArray(nearestCampfireSad);
                                this.moveTowards(cx, cy);
                            } else {
                                // --- MODIFIED: Try to go to library if sad and knows location ---
                                if (this.memory.library) { // <-- NEW
                                    const [lx, ly] = this.memory.library;
                                    this.moveTowards(lx, ly);
                                    this.state = "SEEKING_LIBRARY";
                                } else {
                                    this.moveExploring();
                                }
                            }
                        } else {
                             this.moveExploring(); 
                        }
                        break;

                    case "WANDERING":
                        if (this.energy > simSettings.PAUSE_ENERGY_THRESHOLD && this.social > simSettings.PAUSE_SOCIAL_THRESHOLD) {
                            
                            // --- MODIFIED: Must *know* where library is to go ---
                            if (Math.random() < 0.2 && this.memory.library) { // <-- FIXED
                                const [lx, ly] = this.memory.library;
                                if (getDistance(this.x, this.y, lx, ly) > 5.0) {
                                    this.moveTowards(lx, ly);
                                    this.state = "SEEKING_LIBRARY"; 
                                    return;
                                }
                            }
                             // Linger/observe
                        } else {
                            // Log resources in sight to memory
                            foodInSight.forEach(posKey => this.memory.food.add(posKey));
                            woodInSight.forEach(posKey => this.memory.wood.add(posKey));
                            this.moveExploring();
                        }
                        break;
                    
                    case "SEEKING_LIBRARY": 
                        // This state is only entered if this.memory.library is set
                        const [lx, ly] = this.memory.library;
                        
                        // Add navigation skill gain
                        this.skills.navigation = clamp(this.skills.navigation + 0.001, 0, 5.0); // <-- FIXED
                        
                        if (getDistance(this.x, this.y, lx, ly) < 2.0) {
                            // Arrived at library, gaining knowledge buff
                            this.skills.social = clamp(this.skills.social + 0.01, 0, 10.0); // <-- FIXED
                            this.state = "WANDERING";
                            
                        } else {
                             this.moveTowards(lx, ly);
                        }
                        break;
                        
                    case "COMMUNICATING":
                        // No movement, just talking
                        break;
                }
            }

            isClearTile(x, y) {
                // *** SYNCED WITH life_simulation2.py ***
                const posKey = arrayToKey([x, y]);
                // --- FIX: Prevent building/planting on the Library tile ---
                if (posKey === arrayToKey(this.world.libraryLocation)) {
                    return false;
                }
                // --- END FIX ---
                if (this.world.homes[posKey]) return false;
                if (this.world.food[posKey]) return false;
                if (this.world.wood[posKey]) return false;
                if (this.world.growingPlants[posKey]) return false;
                if (this.world.growingTrees[posKey]) return false;
                if (this.world.campfires[posKey]) return false;
                return true;
            }
            
            // --- NEW: Helper for new movement logic ---
            isObstacle(x, y) {
                // *** NEW METHOD from life_simulation2.py ***
                const posKey = arrayToKey([x, y]);
                if (this.world.homes[posKey]) {
                    const homeData = this.world.homes[posKey];
                    // It's an obstacle if it's a home and it's NOT our home
                    if (homeData.owner_id !== this.id) {
                        return true;
                    }
                }
                return false;
            }
            // --- END NEW ---

            moveTowards(targetX, targetY) {
                // *** REPLACED with life_simulation2.py logic (Obstacle Avoidance) ***
                this.exploration_vector = [0, 0];
                
                let steps = Math.floor(this.genes['speed']);
                if (steps < 1) steps = 1;
                
                for (let i = 0; i < steps; i++) {
                    let dx = 0, dy = 0;
                    if (this.x < targetX) dx = 1;
                    else if (this.x > targetX) dx = -1;
                    if (this.y < targetY) dy = 1;
                    else if (this.y > targetY) dy = -1;
                    
                    const newX = clamp(this.x + dx, 0, this.world.width - 1);
                    const newY = clamp(this.y + dy, 0, this.world.height - 1);
                    
                    // --- NEW: Obstacle Avoidance Logic ---
                    if (!this.isObstacle(newX, newY)) {
                        // Path is clear, move diagonally/normally
                        this.x = newX;
                        this.y = newY;
                    } else {
                        // Path is blocked. Try to slide.
                        // Try moving just horizontally
                        const slideX = clamp(this.x + dx, 0, this.world.width - 1);
                        if (dx !== 0 && !this.isObstacle(slideX, this.y)) {
                            this.x = slideX;
                        // Try moving just vertically
                        } else if (dy !== 0 && !this.isObstacle(this.x, clamp(this.y + dy, 0, this.world.height - 1))) {
                            this.y = clamp(this.y + dy, 0, this.world.height - 1);
                        } else {
                            // Stuck, can't slide. Stop moving.
                            break; // Exit the 'steps' loop
                        }
                    }
                    // --- END NEW ---
                    
                    this.skills.navigation = clamp(this.skills.navigation + 0.001, 0, 5.0); 
                    const costMultiplier = 1.0 - (this.skills.navigation * 0.15); 
                    const finalMultiplier = Math.max(0.25, costMultiplier);
                    
                    this.energy -= (0.05) * finalMultiplier; 
                }
            }

            moveRandomly(speedFactor, persistentChance) {
                // *** REPLACED with life_simulation2.py logic (Obstacle Avoidance) ***
                let steps = Math.floor(this.genes['speed'] * speedFactor);
                if (steps < 1) steps = 1;

                for (let i = 0; i < steps; i++) {
                    let stuck = false;
                    if (this.exploration_vector[0] !== 0 || this.exploration_vector[1] !== 0) {
                        const newX = clamp(this.x + this.exploration_vector[0], 0, this.world.width - 1);
                        const newY = clamp(this.y + this.exploration_vector[1], 0, this.world.height - 1);
                        if (newX === this.x && newY === this.y) {
                            stuck = true; 
                        }
                    }

                    if ((this.exploration_vector[0] === 0 && this.exploration_vector[1] === 0) || stuck || Math.random() > persistentChance) {
                        while (true) { 
                            this.exploration_vector = [Math.floor(Math.random() * 3) - 1, Math.floor(Math.random() * 3) - 1];
                            if (this.exploration_vector[0] !== 0 || this.exploration_vector[1] !== 0) {
                                break;
                            }
                        }
                    }
                    
                    const [dx, dy] = this.exploration_vector;
                    
                    // --- NEW: Obstacle Avoidance Logic ---
                    const newX = clamp(this.x + dx, 0, this.world.width - 1);
                    const newY = clamp(this.y + dy, 0, this.world.height - 1);
                    
                    if (!this.isObstacle(newX, newY)) {
                        this.x = newX;
                        this.y = newY;
                    } else {
                        // Hit an obstacle, stop moving this step
                        this.exploration_vector = [0, 0]; // Force new direction next time
                        break; // Stop the 'steps' loop
                    }
                    // --- END NEW ---
                    
                    this.skills.navigation = clamp(this.skills.navigation + 0.001, 0, 5.0); 
                    const costMultiplier = 1.0 - (this.skills.navigation * 0.15); 
                    const finalMultiplier = Math.max(0.25, costMultiplier);
                    
                    this.energy -= (0.05) * finalMultiplier;
                }
            }

            moveExploring() {
                // *** SYNCED WITH life_simulation2.py ***
                this.moveRandomly(1.0, 0.8);
            }

            getClosestCombinedTarget(resourceType, visibleResources) {
                // *** SYNCED WITH life_simulation2.py ***
                const possibleTargets = new Set();
                
                visibleResources.forEach(posKey => possibleTargets.add(posKey));
                this.memory[resourceType].forEach(posKey => {
                    // Clean memory: check if item still exists
                    if (this.world[resourceType][posKey]) {
                        possibleTargets.add(posKey)
                    } else {
                        this.memory[resourceType].delete(posKey);
                    }
                });
                
                if (possibleTargets.size === 0) return null;
                    
                let nearestItem = null;
                let minDist = Infinity;
                
                for (const posKey of possibleTargets) {
                    const [ix, iy] = keyToArray(posKey);
                    const dist = getDistance(this.x, this.y, ix, iy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestItem = [ix, iy];
                    }
                }
                return nearestItem;
            }

            consumeFood() {
                // *** SYNCED WITH life_simulation2.py ***
                if (this.food_carried > 0) {
                    this.food_carried--;
                    this.skills.foraging = clamp(this.skills.foraging + 0.1, 0, 10.0); 
                    const energyGain = 120 + (this.skills.foraging * 20); 
                    this.energy += energyGain;
                    this.love = clamp(this.love + simSettings.LOVE_GAIN_EAT, 0, simSettings.STARTING_LOVE);
                    
                    // --- Environmental Degradation ---
                    const decayAmount = simSettings.ENV_DECAY_FOOD_GATHER * (1.0 - (this.skills.foraging / 10.0));
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth - decayAmount, 0, simSettings.ENV_HEALTH_MAX);

                    // --- Chance to drop a food seed ---
                    const foragingChance = simSettings.FOOD_SEED_BASE_CHANCE + (this.skills.foraging * 0.05);
                    if (Math.random() < foragingChance) {
                        this.seeds_carried++;
                    }

                    this.state = "WANDERING";
                }
            }

            pickupFood() {
                // *** SYNCED WITH life_simulation2.py ***
                const posKey = arrayToKey([this.x, this.y]);
                if (this.world.food[posKey] && this.food_carried < 2) {
                    delete this.world.food[posKey];
                    delete this.world.foodFreshness[posKey];
                    this.food_carried++;
                    this.memory.food.delete(posKey);
                    this.state = "WANDERING";
                }
            }

            takeWood() {
                // *** SYNCED WITH life_simulation2.py ***
                const posKey = arrayToKey([this.x, this.y]);
                if (this.world.wood[posKey] && this.wood_carried < 3) {
                    delete this.world.wood[posKey];
                    this.wood_carried++;
                    
                    // --- Environmental Degradation ---
                    const decayAmount = simSettings.ENV_DECAY_WOOD_GATHER * (1.0 - (this.skills.foraging / 10.0));
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth - decayAmount, 0, simSettings.ENV_HEALTH_MAX);
                    
                    if (Math.random() < simSettings.WOOD_SEED_CHANCE) {
                        this.wood_seeds_carried++;
                    }

                    this.memory.wood.delete(posKey);
                    this.state = "WANDERING";
                }
            }

            buildHome() {
                // *** SYNCED WITH life_simulation2.py ***
                const posKey = arrayToKey([this.x, this.y]);
                let woodCost = 3 - Math.floor(this.skills.building * 0.5);
                if (woodCost < 1) woodCost = 1;
                
                if (this.wood_carried >= woodCost) {
                    this.wood_carried -= woodCost;
                    this.world.homes[posKey] = { owner_id: this.id, durability: simSettings.HOME_DURABILITY_START };
                    this.home_location = posKey; 
                    this.state = "WANDERING";
                    this.skills.building = clamp(this.skills.building + 0.5, 0, 4.0); 
                }
            }
            
            buildCampfire() {
                // *** SYNCED WITH life_simulation2.py ***
                const posKey = arrayToKey([this.x, this.y]);
                let woodCost = simSettings.CAMPFIRE_WOOD_COST - Math.floor(this.skills.building * 0.5);
                if (woodCost < 1) woodCost = 1;
                
                if (this.wood_carried >= woodCost) {
                    this.wood_carried -= woodCost;
                    this.world.campfires[posKey] = simSettings.CAMPFIRE_BURN_TIME;
                    this.campfire_location = posKey; 
                    this.skills.building = clamp(this.skills.building + 0.2, 0, 4.0);
                    this.state = "WANDERING";
                }
            }
            
            attack(target, attack_type = 'COMBAT_AGGRESSION') {
                // *** SYNCED WITH life_simulation2.py ***
                let energyCost = 10 - (this.skills.combat * 1.0);
                if (energyCost < 2) energyCost = 2;
                
                let damage = 15 + (this.skills.combat * 8); 
                
                this.state = "ATTACKING";
                this.energy -= energyCost;
                this.energy += 10; 
                
                target.energy -= damage;
                this.skills.combat = clamp(this.skills.combat + 0.2, 0, 10.0); 
                
                // FIX: Aggression is emotionally costly
                this.love = clamp(this.love - 5.0, 0, simSettings.STARTING_LOVE); 

                target.was_attacked_by = this.id;
                
                // --- NEW: CHECK FOR COMBAT DEATH ---
                if (target.energy <= 0) {
                    target.die(attack_type);
                }
                // --- END NEW ---
            }
            
            mate(partner) {
                // *** SYNCED WITH life_simulation2.py ***
                this.state = "MATING";
                partner.state = "MATING";
                
                this.energy -= 40;
                partner.energy -= 40;
                
                // FIX: Reduced mate cooldown from 70 to 65
                this.mate_cooldown = 600; // <-- FIXED
                partner.mate_cooldown = 600; // <-- FIXED
                
                // --- FIX: Number of children set to 1-3 ---
                let numChildren = Math.floor(Math.random() * 3) + 1; // <-- FIXED
                // --- END FIX ---
                
                for (let i = 0; i < numChildren; i++) {
                    const newGenes = {};
                    for (const gene in this.genes) {
                        const [minVal, maxVal, mutRate] = GENE_RANGES[gene];
                        const avgGene = (this.genes[gene] + partner.genes[gene]) / 2;
                        const mutation = (Math.random() * 2 - 1) * mutRate * (maxVal - minVal);
                        newGenes[gene] = clamp(avgGene + mutation, minVal, maxVal);
                    }
                    
                    const newAgent = this.world.addAgent(this.x, this.y, newGenes);
                    if (newAgent) {
                        newAgent.skills = { 'foraging': 0.0, 'social': 0.0, 'building': 0.0, 'navigation': 0.0, 'combat': 0.0, 'farming': 0.0 };
                        newAgent.home_location = null;
                        
                        // --- NEW: Assign parentage ---
                        newAgent.parent_ids = new Set([this.id, partner.id]);
                        // --- END NEW ---
                        
                        this.children_ids.add(newAgent.id);
                        partner.children_ids.add(newAgent.id);
                    }
                }
                
                this.social = 100.0;
                this.contentment_buff_timer = 25; 
                partner.social = 100.0;
                partner.contentment_buff_timer = 25;
            }

            shareSkills(partner) {
                // *** SYNCED WITH life_simulation2.py ***
                const skillsToShare = ['foraging', 'building', 'navigation', 'farming', 'combat', 'social']; // <-- FIXED
                // FIX: Reduced learning rate
                const learningRate = 0.01; 
                
                for (const skill of skillsToShare) {
                    const selfSkill = this.skills[skill];
                    const partnerSkill = partner.skills[skill];
                    
                    if (selfSkill > partnerSkill) {
                        partner.skills[skill] = clamp(partnerSkill + learningRate, 0, 10.0);
                        // High skill agent contributes to global knowledge pool
                        if (selfSkill > 2.0) { 
                            this.world.globalSkillKnowledge[skill] = clamp((this.world.globalSkillKnowledge[skill] || 0.0) + 0.001, 0, 10.0); // <-- FIXED
                        }
                    } else if (partnerSkill > selfSkill) {
                        this.skills[skill] = clamp(selfSkill + learningRate, 0, 10.0);
                        // High skill agent contributes to global knowledge pool
                        if (partnerSkill > 2.0) {
                            this.world.globalSkillKnowledge[skill] = clamp((this.world.globalSkillKnowledge[skill] || 0.0) + 0.001, 0, 10.0); // <-- FIXED
                        }
                    }
                }
                
                // --- NEW: Share Library Location ---
                if (this.memory.library && !partner.memory.library) {
                    partner.memory.library = this.memory.library;
                } else if (partner.memory.library && !this.memory.library) {
                    this.memory.library = partner.memory.library;
                }
                // --- END NEW ---
            }

            communicate(partner) {
                // *** SYNCED WITH life_simulation2.py ***
                this.state = "COMMUNICATING";
                partner.state = "COMMUNICATING";
                
                // --- NEW: Personality Conflict Check ---
                const selfPersonality = this.getPersonality();
                const partnerPersonality = partner.getPersonality();
                
                let conflictDetected = false;
                // Check if self dislikes partner
                if (PERSONALITY_CONFLICTS[selfPersonality] && PERSONALITY_CONFLICTS[selfPersonality].includes(partnerPersonality)) {
                    conflictDetected = true;
                } 
                // Check if partner dislikes self
                else if (PERSONALITY_CONFLICTS[partnerPersonality] && PERSONALITY_CONFLICTS[partnerPersonality].includes(selfPersonality)) {
                    conflictDetected = true;
                }
                    
                // If conflict detected, check aggression
                if (conflictDetected) {
                    // High aggression agents are more likely to fight
                    let conflictChance = this.genes.aggression * 0.8;
                    if (selfPersonality === PERSONALITY_AGGRESSIVE_COOPERATOR) {
                         conflictChance = this.genes.aggression * 1.5;
                    }
                    
                    if (Math.random() < conflictChance) {
                        // Trigger an immediate fight
                        this.attack(partner, 'COMBAT_CONFLICT');
                        return;
                    }
                }
                // --- END NEW: Personality Conflict Check ---

                // FIX: Communication has a minor energy cost
                this.energy -= 1.0; 
                partner.energy -= 1.0;

                this.skills.social = clamp(this.skills.social + 0.001, 0, 10.0); 
                partner.skills.social = clamp(partner.skills.social + 0.001, 0, 10.0); 
                
                const socialGain = 50 + (this.skills.social * 10);
                const partnerSocialGain = 20 + (partner.skills.social * 5);
                
                this.social = clamp(this.social + socialGain, 0, 100);
                partner.social = clamp(partner.social + partnerSocialGain, 0, 100);
                
                this.social_buff_timer = 20; 
                partner.social_buff_timer = 20; 
                
                // --- APATHY SYSTEM: Halve social recovery ---
                let loveGain = simSettings.LOVE_GAIN_SOCIAL;
                if (this.apathy_timer > 0) {
                    loveGain /= 2;
                }
                this.love = clamp(this.love + loveGain, 0, simSettings.STARTING_LOVE);
                    
                let loveGainPartner = simSettings.LOVE_GAIN_SOCIAL;
                if (partner.apathy_timer > 0) {
                    loveGainPartner /= 2;
                }
                partner.love = clamp(partner.love + loveGainPartner, 0, simSettings.STARTING_LOVE);
                // --- END APATHY SYSTEM ---
                
                this.shareSkills(partner);
                
                // Communal Planting Decision (Survival Communication)
                if (Object.keys(this.world.food).length < simSettings.STARTING_FOOD && 
                   this.seeds_carried >= 1 && partner.seeds_carried >= 1) {
                    
                    const totalSeeds = this.seeds_carried + partner.seeds_carried;
                    if (totalSeeds >= 3) {
                        this.seeds_carried = 0;
                        partner.seeds_carried = 0;
                        
                        const [lx, ly] = this.world.libraryLocation;
                        let plantLocKey = arrayToKey([lx, ly]); 
                        if (!this.isClearTile(lx, ly)) {
                            plantLocKey = arrayToKey([this.x, this.y]);
                        }
                        
                        this.world.food[plantLocKey] = true;
                        this.world.foodFreshness[plantLocKey] = simSettings.FOOD_FRESHNESS;
                        
                        this.state = "FORAGING";
                        partner.state = "FORAGING";
                        return;
                    }
                }
                
                // Age check added to mating condition
                if (this.age >= simSettings.ADULT_AGE && this.energy > this.genes.mating_drive && this.mate_cooldown === 0 && 
                   partner.age >= simSettings.ADULT_AGE && partner.energy > partner.genes.mating_drive && partner.mate_cooldown === 0) {
                    
                    this.mate(partner);
                }
            }

            plantSeed() {
                // *** SYNCED WITH life_simulation2.py ***
                if (this.seeds_carried > 0) {
                    this.seeds_carried--;
                    this.energy -= 10;
                    
                    const posKey = arrayToKey([this.x, this.y]);
                    this.world.growingPlants[posKey] = simSettings.GROW_TIME;
                    
                    this.skills.farming = clamp(this.skills.farming + 0.2, 0, 10.0);
                    
                    // --- NEW: Environmental Healing from Planting ---
                    const healAmount = simSettings.ENV_HEAL_PLANT_BASE * (this.skills.farming / 10.0);
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth + healAmount, 0, simSettings.ENV_HEALTH_MAX);
                    // --- END NEW ---
                    
                    this.state = "WANDERING";
                }
            }

            plantTree() {
                // *** SYNCED WITH life_simulation2.py ***
                if (this.wood_seeds_carried > 0) {
                    this.wood_seeds_carried--;
                    this.energy -= 10;
                    
                    const posKey = arrayToKey([this.x, this.y]);
                    this.world.growingTrees[posKey] = simSettings.TREE_GROW_TIME;
                    
                    this.skills.farming = clamp(this.skills.farming + 0.2, 0, 10.0);
                    
                    // --- NEW: Environmental Healing from Planting ---
                    const healAmount = simSettings.ENV_HEAL_PLANT_BASE * (this.skills.farming / 10.0);
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth + healAmount, 0, simSettings.ENV_HEALTH_MAX);
                    // --- END NEW ---
                    
                    this.state = "WANDERING";
                }
            }

            die(reason = 'UNKNOWN') {
                // *** SYNCED WITH life_simulation2.py ***
                
                // --- NEW: Vengeance System ---
                // Check if a child died and if there were witnesses
                // This check must happen *before* the agent is removed from the world
                if (this.age < simSettings.ADULT_AGE && this.parent_ids.size > 0) {
                    const witnesses = [];
                    for (const agent of this.world.agents) {
                        // Skip self and parents from being witnesses
                        if (agent.id === this.id || this.parent_ids.has(agent.id)) {
                            continue;
                        }
                        
                        // Check if the dying child is within the *agent's* vision
                        const visionRadius = Math.floor(agent.genes['vision']);
                        const dist = getDistance(agent.x, agent.y, this.x, this.y);
                        
                        if (dist <= visionRadius) {
                            witnesses.push(agent);
                        }
                    }
                    
                    // Find the closest living parent to blame
                    if (witnesses.length > 0) {
                        let closestParentAgent = null;
                        let minDistToParent = Infinity;
                        
                        for (const p_id of this.parent_ids) {
                            const parent = this.world.getAgentById(p_id);
                            if (parent) {
                                // Find distance from *child* to parent
                                const dist = getDistance(this.x, this.y, parent.x, parent.y);
                                if (dist < minDistToParent) {
                                    minDistToParent = dist;
                                    closestParentAgent = parent;
                                }
                            }
                        }
                        
                        // If a living parent is found, assign vengeance task to all witnesses
                        if (closestParentAgent) {
                            for (const witness of witnesses) {
                                witness.state = "AVENGING";
                                witness.avenging_target_id = closestParentAgent.id;
                                witness.vengeance_timer = VENGEANCE_DURATION; 
                            }
                        }
                    }
                }
                // --- END: Vengeance System ---
                
                
                this.world.deathCauses[reason] = (this.world.deathCauses[reason] || 0) + 1;
                
                const deathLocationKey = arrayToKey([this.x, this.y]);
                
                // Drop wood
                for (let i = 0; i < this.wood_carried; i++) {
                    this.world.wood[deathLocationKey] = true;
                }
                
                // Drop food
                for (let i = 0; i < this.food_carried; i++) {
                    this.world.food[deathLocationKey] = true;
                    this.world.foodFreshness[deathLocationKey] = simSettings.FOOD_FRESHNESS;
                }
                
                // Remove self from any parent's child list
                const dyingAgentId = this.id;
                for (const parent_id of this.parent_ids) {
                    const parent = this.world.getAgentById(parent_id);
                    if (parent && parent.children_ids.has(dyingAgentId)) {
                        parent.children_ids.delete(dyingAgentId);
                    }
                }
                
                const index = this.world.agents.indexOf(this);
                if (index > -1) {
                    this.world.agents.splice(index, 1);
                }
                
                if (this.home_location && this.world.homes[this.home_location]) {
                    this.world.homes[this.home_location].owner_id = null;
                }
            }
        }

        // --- WORLD CLASS ---

        class World {
            constructor(width, height) {
                // *** SYNCED WITH life_simulation2.py ***
                this.width = width;
                this.height = height;
                this.turn = 0;
                this.nextAgentId = 0;
                
                this.agents = [];
                this.food = {};
                this.wood = {};
                
                this.generationCount = 0;
                
                this.environmentalHealth = simSettings.ENV_HEALTH_MAX;

                this.deathCauses = {
                    'MAX_AGE': 0, 
                    'STARVATION_ADULT': 0, 
                    'STARVATION_CHILD': 0, 
                    'NATURAL_DEATH_OLD': 0, 
                    'UNKNOWN': 0,
                    // --- MODIFIED: Specific Combat Deaths ---
                    'COMBAT_VENDETTA': 0,
                    'COMBAT_CONFLICT': 0,
                    'COMBAT_RETALIATION': 0,
                    'COMBAT_AGGRESSION': 0
                };
                this.homes = {};
                this.growingPlants = {};
                this.growingTrees = {};
                this.foodFreshness = {};
                this.campfires = {};

                // Global Knowledge Pool
                this.globalSkillKnowledge = {
                    'foraging': 0.0, 
                    'social': 0.0, 
                    'building': 0.0, // <-- FIXED
                    'navigation': 0.0, 
                    'combat': 0.0, 
                    'farming': 0.0
                };
                // Library Location
                this.libraryLocation = [Math.floor(this.width / 2), Math.floor(this.height / 2)];

                this.stats = {};
                this.calculateStats(); // Pre-initialize stats
            }

            getNextAgentId() {
                return ++this.nextAgentId;
            }

            getAgentById(agentId) {
                return this.agents.find(a => a.id === agentId);
            }

            getEmptyHome() {
                for (const pos in this.homes) {
                    if (this.homes[pos].owner_id === null) {
                        return pos;
                    }
                }
                return null;
            }

            addAgent(x = null, y = null, genes = null) {
                // *** SYNCED WITH life_simulation2.py ***
                x = x === null ? Math.floor(Math.random() * this.width) : x;
                y = y === null ? Math.floor(Math.random() * this.height) : y;
                
                const agent = new Agent(x, y, this, genes);
                
                if (genes === null && this.agents.length < simSettings.STARTING_AGENTS) {
                    agent.genes = agent.createRandomGenes(true);
                }
                    
                this.agents.push(agent);
                return agent;
            }

            spawnResources() {
                // *** SYNCED WITH life_simulation2.py ***
                
                // --- Apply Environmental Health as Food Yield Multiplier ---
                const foodYieldMultiplier = this.environmentalHealth / simSettings.ENV_HEALTH_MAX;
                
                // Cap the number of new resources based on health
                const foodSpawnCount = Math.floor(5 * foodYieldMultiplier);
                const woodSpawnCount = Math.floor(3 * foodYieldMultiplier);
                // --- END NEW ---
                
                if (this.turn % simSettings.FOOD_SPAWN_RATE === 0) {
                    for (let i = 0; i < foodSpawnCount; i++) { 
                        if (Object.keys(this.food).length < (this.width * this.height * 0.1)) {
                            const tile = this.getRandomEmptyTile();
                            if (tile) {
                                const posKey = arrayToKey(tile);
                                this.food[posKey] = true;
                                this.foodFreshness[posKey] = simSettings.FOOD_FRESHNESS;
                            }
                        }
                    }
                }

                if (this.turn % simSettings.WOOD_SPAWN_RATE === 0) {
                    for (let i = 0; i < woodSpawnCount; i++) { 
                        if (Object.keys(this.wood).length < (this.width * this.height * 0.05)) {
                            const tile = this.getRandomEmptyTile();
                            if (tile) {
                                this.wood[arrayToKey(tile)] = true;
                            }
                        }
                    }
                }
            }

            updateWorldObjects() {
                // *** SYNCED WITH life_simulation2.py ***
                
                // --- Passive Environmental Health Recovery ---
                this.environmentalHealth = clamp(this.environmentalHealth + simSettings.ENV_PASSIVE_RECOVERY_RATE, 0, simSettings.ENV_HEALTH_MAX);
                // --- END NEW ---
                
                // 1. Update Growing Plants (Food)
                for (const pos in this.growingPlants) {
                    this.growingPlants[pos]--;
                    if (this.growingPlants[pos] <= 0) {
                        delete this.growingPlants[pos];
                        if (!this.food[pos] && !this.homes[pos] && !this.wood[pos]) {
                            this.food[pos] = true;
                            this.foodFreshness[pos] = simSettings.FOOD_FRESHNESS;
                        }
                    }
                }
                
                // 1.5. Update Growing Trees (Wood)
                for (const pos in this.growingTrees) {
                    this.growingTrees[pos]--;
                    if (this.growingTrees[pos] <= 0) {
                        delete this.growingTrees[pos];
                        if (!this.food[pos] && !this.homes[pos] && !this.wood[pos]) {
                            this.wood[pos] = true;
                        }
                    }
                }
                
                // 2. Update Food Spoilage
                for (const posKey of Object.keys(this.foodFreshness)) {
                    this.foodFreshness[posKey]--;
                    if (this.foodFreshness[posKey] <= 0) {
                        delete this.foodFreshness[posKey];
                        delete this.food[posKey]; // Also remove from the main food map
                    }
                }
                
                // 3. Update Campfires
                for (const pos in this.campfires) {
                    this.campfires[pos]--;
                    if (this.campfires[pos] <= 0) {
                        delete this.campfires[pos];
                    }
                }
                
                // 4. Update Home Decay (MODIFIED TO DECAY FASTER)
                if (this.turn % simSettings.HOME_DECAY_RATE === 0) {
                    for (const pos in this.homes) {
                        this.homes[pos].durability--;
                        if (this.homes[pos].durability <= 0) {
                            
                            // Drop wood when home is destroyed
                            for (let i = 0; i < 3; i++) {
                                this.wood[pos] = true;
                            }
                                
                            const ownerId = this.homes[pos].owner_id;
                            if (ownerId !== null) {
                                const agent = this.getAgentById(ownerId);
                                if (agent) {
                                    agent.home_location = null;
                                }
                            }
                            delete this.homes[pos];
                        }
                    }
                }
            }


            getRandomEmptyTile() {
                // *** SYNCED WITH life_simulation2.py ***
                const attempts = 10;
                // --- FIX: Get library location to prevent spawning on it ---
                const libKey = arrayToKey(this.libraryLocation);
                // --- END FIX ---

                for (let i = 0; i < attempts; i++) {
                    const x = Math.floor(Math.random() * this.width);
                    const y = Math.floor(Math.random() * this.height);
                    const posKey = arrayToKey([x, y]);
                    
                    // --- FIX: Check if the tile is the library ---
                    if (posKey === libKey) {
                        continue;
                    }
                    // --- END FIX ---
                    
                    const occupied = this.agents.some(agent => agent.x === x && agent.y === y);
                        
                    if (!occupied && !this.food[posKey] && !this.wood[posKey] && !this.homes[posKey] && 
                        !this.growingPlants[posKey] && !this.growingTrees[posKey] && !this.campfires[posKey]) {
                        return [x, y];
                    }
                }
                return null; 
            }

            update() {
                // *** SYNCED WITH life_simulation2.py ***
                this.turn++;
                
                if (this.turn % simSettings.MAX_AGE === 0) {
                    this.generationCount++;
                }
                
                // Iterate backwards to allow for agent removal during update
                for (let i = this.agents.length - 1; i >= 0; i--) {
                    const agent = this.agents[i];
                    // Check if agent still exists (it might have died this turn)
                    if (agent && this.agents.includes(agent)) {
                        agent.update();
                    }
                }
                
                this.spawnResources();
                this.updateWorldObjects();
                this.calculateStats();
            }

            calculateStats() {
                // *** SYNCED WITH life_simulation2.py ***
                const adultAgents = this.agents.filter(agent => agent.age >= simSettings.ADULT_AGE);
                
                let agentsForStats;
                if (adultAgents.length === 0) {
                    agentsForStats = this.agents;
                } else {
                    agentsForStats = adultAgents;
                }
                    
                if (agentsForStats.length === 0) {
                    // Clear all stats to 0 if no agents
                    this.stats = {};
                    for (const gene in GENE_RANGES) {
                        this.stats[`avg_${gene}`] = 0.0;
                    }
                    const skillList = ['foraging', 'social', 'building', 'navigation', 'combat', 'farming'];
                    for (const skill of skillList) {
                        this.stats[`avg_${skill}_skill`] = 0.0;
                    }
                    this.stats.population = 0;
                    this.stats.homes_built = 0;
                    this.stats.active_campfires = 0;
                    
                    // --- FIX: Prevent double-counting TOTAL_DEATHS ---
                    let totalDeaths = 0;
                    for (const reason in this.deathCauses) {
                        if (reason !== 'TOTAL_DEATHS') {
                            totalDeaths += this.deathCauses[reason];
                        }
                    }
                    this.deathCauses.TOTAL_DEATHS = totalDeaths;
                    // --- END FIX ---
                    
                    if (this.deathCauses.hasOwnProperty('UNKNOWN')) {
                        delete this.deathCauses['UNKNOWN'];
                    }
                    return;
                }
                    
                const numAgents = agentsForStats.length;
                    
                this.stats.population = this.agents.length;
                this.stats.homes_built = Object.keys(this.homes).length;
                this.stats.active_campfires = Object.keys(this.campfires).length;
                
                // Calculate average genes
                for (const gene in GENE_RANGES) {
                    const avgKey = `avg_${gene}`;
                    const total = agentsForStats.reduce((sum, agent) => sum + agent.genes[gene], 0);
                    this.stats[avgKey] = total / numAgents;
                }
                    
                // Calculate average skills
                const skillList = ['foraging', 'social', 'building', 'navigation', 'combat', 'farming'];
                for (const skill of skillList) {
                    const avgKey = `avg_${skill}_skill`;
                    const total = agentsForStats.reduce((sum, agent) => sum + agent.skills[skill], 0);
                    this.stats[avgKey] = total / numAgents;
                }
                    
                // Calculate total deaths for percentage breakdown
                // --- FIX: Prevent double-counting TOTAL_DEATHS ---
                let totalDeaths = 0;
                for (const reason in this.deathCauses) {
                    if (reason !== 'TOTAL_DEATHS') {
                        totalDeaths += this.deathCauses[reason];
                    }
                }
                this.deathCauses.TOTAL_DEATHS = totalDeaths;
                // --- END FIX ---
                
                if (this.deathCauses.hasOwnProperty('UNKNOWN')) {
                    delete this.deathCauses['UNKNOWN'];
                }
            }

            getNearest(x, y, radius, itemMap) {
                // *** SYNCED WITH life_simulation2.py ***
                let nearestItemKey = null;
                let minDist = Infinity;
                
                // itemMap is already the .keys() equivalent (it's an object)
                for (const posKey in itemMap) {
                    const [ix, iy] = keyToArray(posKey);
                    const dist = getDistance(x, y, ix, iy);
                    if (dist <= radius && dist < minDist) {
                        minDist = dist;
                        nearestItemKey = posKey;
                    }
                }
                return nearestItemKey;
            }

            getNearestInSet(x, y, radius, itemMap) {
                // *** SYNCED WITH life_simulation2.py ***
                const foundItemKeys = [];
                
                for (const posKey in itemMap) {
                    const [ix, iy] = keyToArray(posKey);
                    const dist = getDistance(x, y, ix, iy);
                    if (dist <= radius) {
                        foundItemKeys.push(posKey);
                    }
                }
                return foundItemKeys;
            }

            getNearestAgents(x, y, radius, excludeSelf = null) {
                // *** SYNCED WITH life_simulation2.py ***
                const nearbyAgents = [];
                for (const agent of this.agents) {
                    if (agent === excludeSelf) continue;
                    const dist = getDistance(x, y, agent.x, agent.y);
                    if (dist <= radius) {
                        nearbyAgents.push(agent);
                    }
                }
                return nearbyAgents;
            }
        }


        // --- RENDERING AND MAIN LOOP ---

        class Renderer {
            constructor(world, canvasId) {
                this.world = world;
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');

                this.cellSize = 20;
                
                this.resizeCanvas();
                let resizeTimer;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => this.resizeCanvas(), 100);
                });


                this.font = `${this.cellSize * 0.75}px Consolas, monospace`;
            }

            resizeCanvas() {
                const containerWidth = this.canvas.parentElement.clientWidth;
                if (containerWidth === 0) {
                    setTimeout(() => this.resizeCanvas(), 100); 
                    return;
                }
                let newCellSize = Math.floor(containerWidth / this.world.width);
                this.cellSize = Math.max(newCellSize, 8); 

                this.canvas.width = this.world.width * this.cellSize;
                this.canvas.height = this.world.height * this.cellSize;
                
                this.font = `${this.cellSize * 0.75}px Consolas, monospace`;
                this.render(); 
            }

            drawCell(x, y, char, color, isDim) {
                const ctx = this.ctx;
                const size = this.cellSize;
                const px = x * size + size / 2;
                const py = y * size + size / 2;

                ctx.fillStyle = color;
                if (isDim) {
                    ctx.globalAlpha = 0.5;
                } else {
                    ctx.globalAlpha = 1.0;
                }

                ctx.fillText(char, px, py);
            }

            render() {
                // *** SYNCED WITH life_simulation2.py (render logic) ***
                const ctx = this.ctx;
                const size = this.cellSize;

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                ctx.fillStyle = '#0d1117';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = this.font;

                // 1. Draw Grid
                for(let y = 0; y < this.world.height; y++) {
                    for(let x = 0; x < this.world.width; x++) {
                        this.drawCell(x, y, '.', COLORS.WHITE_NORMAL, true);
                    }
                }

                // 2. Draw Resources
                const resources = [
                    { map: this.world.growingPlants, char: 'P', color: COLORS.GREEN_NORMAL, dim: false },
                    { map: this.world.growingTrees, char: 'T', color: COLORS.GREEN_DIM, dim: false },
                    { map: this.world.food, char: 'F', color: COLORS.GREEN_BRIGHT, dim: false },
                    { map: this.world.wood, char: 'W', color: COLORS.YELLOW_BRIGHT, dim: false },
                    { map: this.world.campfires, char: 'C', color: COLORS.RED_BRIGHT, dim: false },
                ];

                resources.forEach(res => {
                    for (const posKey in res.map) {
                        const [x, y] = keyToArray(posKey);
                        this.drawCell(x, y, res.char, res.color, res.dim);
                    }
                });

                // 3. Draw HOMES
                for (const posKey in this.world.homes) {
                    const [x, y] = keyToArray(posKey);
                    const durability = this.world.homes[posKey].durability;
                    const char = durability < 2 ? 'h' : 'H';
                    const color = durability < 2 ? COLORS.BLUE_NORMAL : COLORS.BLUE_BRIGHT;
                    this.drawCell(x, y, char, color, false);
                }
                
                // 4. Draw the LIBRARY
                const [lx, ly] = this.world.libraryLocation;
                this.drawCell(lx, ly, 'L', COLORS.LIBRARY, false);

                // 5. Draw AGENTS
                // Agents at home are drawn smaller and offset
                const agentsAtHome = [];
                const agentsOutside = [];

                this.world.agents.forEach(agent => {
                    const isAtHome = agent.home_location !== null && agent.home_location === arrayToKey([agent.x, agent.y]);
                    if (isAtHome) {
                        agentsAtHome.push(agent);
                    } else {
                        agentsOutside.push(agent);
                    }
                });

                // Draw agents outside first (full size)
                agentsOutside.forEach(agent => {
                    let charMapEntry = CHAR_MAP[agent.state] || CHAR_MAP['WANDERING'];
                    let char = charMapEntry.char;
                    let color = charMapEntry.color;
                    let isDim = charMapEntry.dim;

                    // APATHY STATE OVERRIDE
                    if (agent.apathy_timer > 0) {
                        color = COLORS.MAGENTA_DIM; // 's' color
                        char = 's';
                        isDim = true;
                    }
                    // Wellbeing buff
                    else if (agent.social_buff_timer > 0 && agent.state !== 'COMMUNICATING') {
                        color = COLORS.WHITE_BRIGHT; 
                        isDim = false;
                    }
                    
                    this.drawCell(agent.x, agent.y, char, color, isDim);
                });

                // Draw agents at home (small)
                agentsAtHome.forEach(agent => {
                    const px = agent.x * size + size / 2 + size * 0.15;
                    const py = agent.y * size + size / 2 + size * 0.15;
                    
                    let charMapEntry = CHAR_MAP[agent.state] || CHAR_MAP['WANDERING'];
                    let char = charMapEntry.char;
                    let color = charMapEntry.color;
                    let isDim = charMapEntry.dim;

                    if (agent.apathy_timer > 0) {
                        color = COLORS.MAGENTA_DIM;
                        char = 's';
                        isDim = true;
                    }
                    else if (agent.social_buff_timer > 0 && agent.state !== 'COMMUNICATING') {
                        color = COLORS.WHITE_BRIGHT; 
                        isDim = false;
                    }

                    ctx.font = `${this.cellSize * 0.4}px Consolas, monospace`; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = color;
                    if (isDim) {
                        ctx.globalAlpha = 0.5;
                    } else {
                        ctx.globalAlpha = 1.0;
                    }

                    ctx.fillText(char, px, py);
                    ctx.font = this.font; // Reset font
                });

                ctx.globalAlpha = 1.0;
            }
        }

        // --- STATS RENDERING ---
        function updateStatsDisplay(world) {
            // *** SYNCED WITH life_simulation2.py (stats panel) ***
            document.getElementById('turnCounter').textContent = world.turn;
            document.getElementById('generationCounter').textContent = world.generationCount;
            document.getElementById('statPopulation').textContent = world.stats.population || 0;
            document.getElementById('statHomes').textContent = world.stats.homes_built || 0;
            document.getElementById('statFires').textContent = world.stats.active_campfires || 0;

            const envHealth = world.environmentalHealth;
            let envColor = 'text-green-400';
            if (envHealth <= 70) envColor = 'text-yellow-400';
            if (envHealth <= 30) envColor = 'text-red-400';
            document.getElementById('statEnvHealth').innerHTML = `<span class="${envColor}">${envHealth.toFixed(1)}%</span>`;

            const geneStatsDiv = document.getElementById('geneStats');
            geneStatsDiv.innerHTML = '';
            for (const gene in GENE_RANGES) {
                const avg = world.stats[`avg_${gene}`] || 0;
                let color = 'text-cyan-400'; // Default for vision, speed
                if (gene === 'aggression') color = 'text-red-400';
                if (gene === 'metabolism') color = 'text-red-400'; // Lower is better
                if (gene === 'builder') color = 'text-blue-400';
                if (gene === 'mating_drive') color = 'text-magenta-400';
                if (gene === 'sociability') color = 'text-white';
                if (gene === 'farming') color = 'text-green-400';
                if (gene === 'personality') color = 'text-magenta-400';
                
                const displayValue = (gene === 'mating_drive') ? avg.toFixed(0) : avg.toFixed(2);
                
                geneStatsDiv.innerHTML += `<p><span class="${color}">${gene.padEnd(12, ' ')}</span>: ${displayValue}</p>`;
            }

            const skillStatsDiv = document.getElementById('skillStats');
            skillStatsDiv.innerHTML = '';
            const skillList = ['foraging', 'social', 'building', 'navigation', 'combat', 'farming'];
            for (const skill of skillList) {
                const avg = world.stats[`avg_${skill}_skill`] || 0;
                let color = 'text-green-400'; // foraging, farming
                if (skill === 'social') color = 'text-white';
                if (skill === 'building') color = 'text-blue-400';
                if (skill === 'navigation') color = 'text-cyan-400';
                if (skill === 'combat') color = 'text-red-400';
                
                skillStatsDiv.innerHTML += `<p><span class="${color}">${skill.padEnd(12, ' ')}</span>: ${avg.toFixed(2)}</p>`;
            }

            const knowledgeStatsDiv = document.getElementById('knowledgeStats');
            knowledgeStatsDiv.innerHTML = '';
            for (const skill in world.globalSkillKnowledge) {
                const val = world.globalSkillKnowledge[skill];
                let color = 'text-green-400'; // foraging, farming
                if (skill === 'social') color = 'text-white';
                if (skill === 'building') color = 'text-blue-400';
                if (skill === 'navigation') color = 'text-cyan-400';
                if (skill === 'combat') color = 'text-red-400';
                knowledgeStatsDiv.innerHTML += `<p><span class="${color}">${skill.padEnd(12, ' ')}</span>: ${val.toFixed(2)}</p>`;
            }

            const deathStatsDiv = document.getElementById('deathStats');
            deathStatsDiv.innerHTML = '';
            const totalDeaths = world.deathCauses.TOTAL_DEATHS || 0;
            
            if (totalDeaths > 0) {
                const filteredDeaths = Object.entries(world.deathCauses).filter(([reason, count]) => 
                    reason !== 'TOTAL_DEATHS' && count > 0 // Remove UNKNOWN (handled in calcStats)
                );
                
                // Sort to show highest count first
                filteredDeaths.sort((a, b) => b[1] - a[1]);

                for (const [reason, count] of filteredDeaths) {
                    const percent = (count / totalDeaths) * 100;
                    deathStatsDiv.innerHTML += `<p><span class="text-red-500">${reason.padEnd(20, ' ')}</span>: ${count} (${percent.toFixed(1)}%)</p>`;
                }
            } else {
                deathStatsDiv.innerHTML = '<p>No deaths recorded yet.</p>';
            }
        }

        function populateLegend() {
            // *** SYNCED WITH life_simulation2.py (legend) ***
            const legendDiv = document.getElementById('legend');
            
            const groups = [
                {
                    title: 'Status & Interaction',
                    items: [
                        { char: 'A', color: COLORS.CYAN_BRIGHT, desc: 'Wander (Default)' },
                        { char: 'f', color: COLORS.CYAN_NORMAL, desc: 'Forage/Eat' },
                        { char: 's', color: COLORS.MAGENTA_DIM, desc: 'Sad/Crisis/Apathy' },
                        { char: 'o', color: COLORS.MAGENTA_BRIGHT, desc: 'Happy/Linger' },
                        { char: 'L', color: COLORS.MAGENTA_BRIGHT, desc: 'Seek Library' },
                        { char: 't', color: COLORS.WHITE_NORMAL, desc: 'Seek Social' },
                        { char: 'T', color: COLORS.WHITE_BRIGHT, desc: 'Communicate/Share Knowledge' },
                        { char: 'g', color: COLORS.WHITE_BRIGHT, desc: 'Share Resources' },
                    ]
                },
                {
                    title: 'Combat & Mating',
                    items: [
                        { char: 'X', color: COLORS.RED_BRIGHT, desc: 'Attack' },
                        { char: 'r', color: COLORS.RED_BRIGHT, desc: 'Retaliate' },
                        { char: 'V', color: COLORS.RED_BRIGHT, desc: 'Avenge Child Death' },
                        { char: 'm', color: COLORS.MAGENTA_BRIGHT, desc: 'Mate' },
                        { char: 'M', color: COLORS.MAGENTA_BRIGHT, desc: 'Seek Mate' }, // <-- NEW
                    ]
                },
                {
                    title: 'Building & Wood',
                    items: [
                        { char: 'w', color: COLORS.YELLOW_NORMAL, desc: 'Get Wood' },
                        { char: 'b', color: COLORS.YELLOW_BRIGHT, desc: 'Build Home' },
                        { char: 'E', color: COLORS.YELLOW_NORMAL, desc: 'Repair Home' },
                        { char: 'k', color: COLORS.BLUE_BRIGHT, desc: 'Claim Home' },
                        { char: 'B', color: COLORS.BLUE_NORMAL, desc: 'Seek Build Spot' },
                        { char: 'C', color: COLORS.BLUE_BRIGHT, desc: 'Seek Community' },
                        { char: 'c', color: COLORS.RED_NORMAL, desc: 'Build Fire' },
                        { char: 'R', color: COLORS.RED_BRIGHT, desc: 'Refuel Fire' },
                    ]
                },
                {
                    title: 'Farming & Resources',
                    items: [
                        { char: 'p', color: COLORS.GREEN_NORMAL, desc: 'Plant Food/Tree' },
                        { char: 'G', color: COLORS.GREEN_BRIGHT, desc: 'Go Home to Plant' },
                        { char: 'F', color: COLORS.GREEN_BRIGHT, desc: 'Food (Ready)' },
                        { char: 'P', color: COLORS.GREEN_NORMAL, desc: 'Plant (Growing)' },
                        { char: 'W', color: COLORS.YELLOW_BRIGHT, desc: 'Wood (Lumber)' },
                        { char: 'T', color: COLORS.GREEN_DIM, desc: 'Tree (Growing)' },
                    ]
                },
                {
                    title: 'Permanent Structures',
                    items: [
                        { char: 'H/h', color: COLORS.BLUE_BRIGHT, desc: 'Home (Healthy/Damaged)' },
                        { char: 'C', color: COLORS.RED_BRIGHT, desc: 'Active Campfire' },
                        { char: 'L', color: COLORS.LIBRARY, desc: 'Library Location' },
                        { char: 'Any', color: COLORS.WHITE_BRIGHT, desc: 'Agent with Wellbeing Buff' },
                    ]
                }
            ];
            
            let html = '';

            groups.forEach(group => {
                html += `<div class="w-full mt-2 mb-1 border-t border-gray-700 pt-2"><h3 class="font-semibold text-sm text-cyan-300">${group.title}</h3></div>`;
                group.items.forEach(item => {
                    html += `<p class="flex items-center min-w-[200px] lg:min-w-[250px]"><span style="color: ${item.color}; font-weight: bold; width: 30px;">${item.char}</span> ${item.desc}</p>`;
                });
            });

            legendDiv.innerHTML = html;
        }

        // --- NEW: Settings Management Functions ---

        function loadSettings() {
            try {
                const storedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);
                if (storedSettings) {
                    const parsedSettings = JSON.parse(storedSettings);
                    // Merge with defaults to ensure all keys exist
                    return { ...defaultSimSettings, ...parsedSettings };
                }
            } catch (e) {
                console.error("Failed to load settings from localStorage", e);
            }
            // Return a copy of the defaults if nothing is stored
            return { ...defaultSimSettings };
        }

        function saveSettings(settings) {
            try {
                localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
            } catch (e) {
                console.error("Failed to save settings to localStorage", e);
            }
        }
        
        function clearSettings() {
            try {
                localStorage.removeItem(SETTINGS_STORAGE_KEY);
            } catch (e) {
                console.error("Failed to clear settings from localStorage", e);
            }
        }

        function populateSettingsForm(settings) {
            for (const key in settings) {
                const input = document.getElementById(key);
                if (input) {
                    input.value = settings[key];
                }
            }
        }
        
        function getSettingsFromForm() {
            const newSettings = {};
            const form = document.getElementById('settingsForm');
            const inputs = form.querySelectorAll('input[type="number"]');
            
            inputs.forEach(input => {
                // Use parseFloat for all numbers to handle integers and floats
                const value = parseFloat(input.value);
                if (!isNaN(value)) {
                    newSettings[input.id] = value;
                } else {
                    // Fallback to default if input is invalid
                    newSettings[input.id] = defaultSimSettings[input.id];
                }
            });
            return newSettings;
        }
        
        function setupModalControls() {
            const modal = document.getElementById('settingsModal');
            const openBtn = document.getElementById('openSettingsBtn');
            const closeBtn = document.getElementById('closeSettingsBtn');
            const saveBtn = document.getElementById('saveSettingsBtn');
            const resetBtn = document.getElementById('resetSettingsBtn');
            
            openBtn.onclick = () => modal.classList.remove('hidden');
            closeBtn.onclick = () => modal.classList.add('hidden');
            
            // Close if clicking outside the modal content
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                }
            };
            
            resetBtn.onclick = () => {
                if (confirm('Are you sure you want to reset all settings to their defaults? This will clear your saved settings and restart the simulation.')) {
                    clearSettings(); // Clears settings from localStorage
                    modal.classList.add('hidden'); // Close the modal
                    location.reload(); // Reload the page
                }
            };
            
            saveBtn.onclick = () => {
                simSettings = getSettingsFromForm();
                saveSettings(simSettings);
                modal.classList.add('hidden');
                location.reload(); 
            };
        }


        // --- MAIN INITIALIZATION ---
        let world, renderer, interval;

        function initializeSimulation() {
            // Stop any existing loop
            if (interval) clearInterval(interval);
            
            // World now reads from the global simSettings
            world = new World(simSettings.WORLD_WIDTH, simSettings.WORLD_HEIGHT);
            
            // 2. Add starting agents and resources
            for (let i = 0; i < simSettings.STARTING_AGENTS; i++) {
                world.addAgent(); 
            }
            for (let i = 0; i < simSettings.STARTING_FOOD; i++) {
                const tile = world.getRandomEmptyTile();
                if (tile) {
                    const posKey = arrayToKey(tile);
                    world.food[posKey] = true;
                    world.foodFreshness[posKey] = simSettings.FOOD_FRESHNESS;
                }
            }
            for (let i = 0; i < simSettings.STARTING_WOOD; i++) {
                const tile = world.getRandomEmptyTile();
                if (tile) {
                    world.wood[arrayToKey(tile)] = true;
                }
            }
            
            // Re-create renderer in case world size changed
            renderer = new Renderer(world, 'worldCanvas');
            
            // Initial stats calculation to populate the display
            world.calculateStats();
            updateStatsDisplay(world);

            // Start the simulation loop
            interval = setInterval(gameLoop, simSettings.SIM_SPEED);
            
            console.log("Simulation initialized. Starting loop.");
        }

        function gameLoop() {
            // *** SYNCED WITH life_simulation2.py (main loop conditions) ***
            try {
                world.update();
                renderer.render();
                updateStatsDisplay(world);

                // --- MODIFIED SIM END CONDITION ---
                if (world.stats.population === 0 && world.turn > 100) {
                    console.log("--- SIMULATION END: All agents have died. ---");
                    clearInterval(interval);
                }
                if (world.agents.length > (simSettings.WORLD_WIDTH * simSettings.WORLD_HEIGHT * 0.5)) {
                    console.log("--- SIMULATION END: Overpopulation! ---");
                    clearInterval(interval);
                }
                // --- END MODIFIED SIM END CONDITION ---
            } catch (e) {
                console.error("Error in game loop:", e);
                clearInterval(interval); // Stop loop on critical error
            }
        }

        window.onload = () => {
            // 1. Load settings first
            simSettings = loadSettings();
            
            // 2. Populate the form with these settings
            populateSettingsForm(simSettings);
            
            // 3. Set up modal buttons
            setupModalControls();
            
            // 4. Populate the legend
            populateLegend();
            
            // 5. Start the simulation
            initializeSimulation();
        };

    </script>
</body>
</html>