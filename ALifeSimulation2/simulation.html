<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A-Life Simulation (Enhanced AI)</title>
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <script>
        // Function to dynamically load a script and return a Promise
        function loadScript(url) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.onload = resolve;
                script.onerror = () => reject();
                document.head.appendChild(script);
            });
        }

        const externalCdn = "https://cdn.tailwindcss.com";
        const localCdn = "tailwind-cdn.js"; 

        loadScript(externalCdn)
            .catch(() => {
                console.warn("External Tailwind CDN failed to load. Falling back to local 'tailwind-cdn.js'.");
                return loadScript(localCdn);
            })
            .then(() => {
                 // Once Tailwind is loaded (either CDN or local), apply config
                 tailwind.config = {
                     theme: {
                         extend: {
                             fontFamily: {
                                 sans: ['Inter', 'sans-serif'],
                                 mono: ['Consolas', 'Monaco', 'monospace'],
                             },
                         }
                     }
                 };
            })
            .catch(() => {
                 console.error("Failed to load Tailwind CSS from both CDN and local file. Styling may be incorrect.");
            });
    </script>
    <style>
        /* Custom styles for the grid visualization */
        #worldCanvas {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #0d1117; /* Default Dark background for console feel */
            border-radius: 0.5rem;
            /* CRITICAL: Ensures characters are drawn without interpolation/blurring */
            image-rendering: pixelated; 
            
            /* Ensure the canvas size defined by JS is respected and centered */
            display: block; 
            margin: 0 auto; 
            cursor: pointer; /* Indicate it's clickable */
        }

        #statsPanel {
            overflow-y: visible; /* Ensure it expands naturally */
        }

        body, html {
            height: 100%;
            margin: 0;
            background-color: #1f2937;
        }

        /* --- START WORLD-ONLY LIGHT MODE STYLES (New) --- */
        
        /* The canvas wrapper and canvas itself */
        .world-light-mode #canvasWrapper {
            background-color: #ffffff !important; /* bg-white */
            border: 1px solid #d1d5db; /* border-gray-300 */
        }
        
        .world-light-mode #worldCanvas {
            background-color: #ffffff !important; /* White background for world container */
        }
        
        /* Agent characters will have their colors inverted in the JS Renderer, 
           but the default text color for the '.' background character needs
           to be inverted directly for visibility. */
        .world-light-mode .dim-background-char {
            color: #d1d5db; /* A lighter gray for dim background dots */
        }

        /* --- END WORLD-ONLY LIGHT MODE STYLES --- */


        #canvasWrapper {
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }

        @media (min-width: 1024px) {
            #canvasWrapper {
                width: 100%;
                margin: 0;
            }
        }
        
        /* NEW: Settings Modal Styles */
        .modal {
            background-color: rgba(0, 0, 0, 0.6);
        }
        
        .modal-content {
            max-height: 90vh;
        }
        
        .hidden {
            display: none;
        }
        
        /* Style for number inputs and select in the modal */
        #settingsForm input[type="number"], #settingsForm select {
            background-color: #374151; /* bg-gray-700 */
            border: 1px solid #4b5563; /* border-gray-600 */
            color: white;
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.5rem 0.75rem; /* px-3 py-2 */
            width: 100%;
        }
        
        #settingsForm label {
            display: block;
            margin-bottom: 0.5rem; /* mb-2 */
            font-weight: 500; /* font-medium */
            color: #d1d5db; /* text-gray-300 */
        }
        
        #settingsForm fieldset {
            border: 1px solid #4b5563; /* border-gray-600 */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 1rem; /* p-4 */
            margin-bottom: 1.5rem; /* mb-6 */
        }
        
        #settingsForm legend {
            padding: 0 0.5rem; /* px-2 */
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: #60a5fa; /* text-blue-400 */
        }
        
        /* Style for developer toggle */
        #developerToggle {
            cursor: pointer;
            user-select: none;
        }

        /* Style for sub-headings within a fieldset */
        .fieldset-subheader {
            font-size: 1rem; /* text-md */
            font-weight: 600; /* font-semibold */
            color: #9ca3af; /* text-gray-400 */
            border-bottom: 1px solid #4b5563; /* border-gray-600 */
            padding-bottom: 0.5rem; /* pb-2 */
            margin-top: 1rem; /* mt-4 */
            margin-bottom: 1rem; /* mb-4 */
        }
        .fieldset-subheader:first-of-type {
            margin-top: 0.25rem; /* mt-1 */
        }
        
        /* Agent Detail Panel Styles */
        #agentDetailPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 60;
            background-color: #1f2937;
            border: 2px solid #60a5fa;
            border-radius: 0.75rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            max-width: 400px;
            width: 90%;
            padding: 1rem;
            font-size: 0.875rem;
        }
        
    </style>
</head>
<body class="p-4 sm:p-8 bg-gray-800 text-white min-h-screen">

    <div id="agentDetailPanel" class="hidden">
        <div class="flex justify-between items-center border-b border-gray-700 pb-2 mb-2">
            <h3 class="text-xl font-bold text-cyan-400">Agent #<span id="detailAgentId"></span></h3>
            <button id="closeDetailBtn" class="text-gray-400 hover:text-white font-bold">&times;</button>
        </div>
        <div id="detailContent" class="space-y-2 font-mono text-sm">
            <p>Age: <span id="detailAge"></span> | State: <span id="detailState"></span></p>
            <p>Energy: <span id="detailEnergy"></span> | Social: <span id="detailSocial"></span> | Love: <span id="detailLove"></span></p>
            <h4 class="font-semibold text-yellow-400 mt-3">Genes (Traits)</h4>
            <div id="detailGenes" class="grid grid-cols-2 gap-x-2"></div>
            <h4 class="font-semibold text-green-400 mt-3">Skills (Learned)</h4>
            <div id="detailSkills" class="grid grid-cols-2 gap-x-2"></div>
            <h4 class="font-semibold text-red-400 mt-3">Status</h4>
            <div id="detailStatus"></div>
        </div>
    </div>
    <div id="settingsModal" class="modal hidden fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="modal-content bg-gray-800 border border-gray-700 rounded-lg shadow-2xl w-full max-w-3xl flex flex-col">
            <div class="flex justify-between items-center p-4 border-b border-gray-700">
                <h2 class="text-2xl font-bold text-white">Simulation Settings</h2>
                <button id="closeSettingsBtn" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            
            <form id="settingsForm" class="p-6 overflow-y-auto flex-1 min-h-0" autocomplete="off">
                <div>
                    
                    <fieldset>
                        <legend>Display</legend>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div class="flex items-center space-x-4 sm:col-span-2">
                                <label for="DISPLAY_WORLD_LIGHT_MODE" class="flex-1 !mb-0">Toggle World Light Mode</label>
                                <input type="checkbox" id="DISPLAY_WORLD_LIGHT_MODE" name="DISPLAY_WORLD_LIGHT_MODE" class="h-6 w-6 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                            </div>
                            <div class="flex items-center space-x-4 sm:col-span-2">
                                <label for="DISPLAY_EMOJI_MODE" class="flex-1 !mb-0">Toggle AI Thought Bubbles (Emojis)</label>
                                <input type="checkbox" id="DISPLAY_EMOJI_MODE" name="DISPLAY_EMOJI_MODE" class="h-6 w-6 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
                            </div>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Simulation & World</legend>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="SIM_SPEED">Sim Speed (ms)</label>
                                <input type="number" id="SIM_SPEED" name="SIM_SPEED" step="1">
                            </div>
                            <div>
                                <label for="STARTING_AGENTS">Starting Agents</label>
                                <input type="number" id="STARTING_AGENTS" name="STARTING_AGENTS" step="1">
                            </div>
                            <div>
                                <label for="WORLD_WIDTH">World Width</label>
                                <input type="number" id="WORLD_WIDTH" name="WORLD_WIDTH" step="1">
                            </div>
                            <div>
                                <label for="WORLD_HEIGHT">World Height</label>
                                <input type="number" id="WORLD_HEIGHT" name="WORLD_HEIGHT" step="1">
                            </div>
                            <div>
                                <label for="STARTING_FOOD">Starting Food</label>
                                <input type="number" id="STARTING_FOOD" name="STARTING_FOOD" step="1">
                            </div>
                            <div>
                                <label for="STARTING_WOOD">Starting Wood</label>
                                <input type="number" id="STARTING_WOOD" name="STARTING_WOOD" step="1">
                            </div>
                            <div>
                                <label for="CRITICAL_FOOD_COUNT">Critical Food</label>
                                <input type="number" id="CRITICAL_FOOD_COUNT" name="CRITICAL_FOOD_COUNT" step="1">
                            </div>
                             <div class="sm:col-span-2">
                                <label for="GLOBAL_SKILL_FOCUS">Global Skill Focus (Small Learning Multiplier)</label>
                                <select id="GLOBAL_SKILL_FOCUS" name="GLOBAL_SKILL_FOCUS">
                                    <option value="none">None</option>
                                    <option value="farming">Farming</option>
                                    <option value="foraging">Foraging</option>
                                    <option value="building">Building</option>
                                    <option value="navigation">Navigation</option>
                                    <option value="combat">Combat</option>
                                    <option value="social">Social</option>
                                </select>
                            </div>
                        </div>
                    </fieldset>

<fieldset>
                        <legend>Mating, Combat & Population Control</legend>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="MAX_POPULATION_TARGET">Max Population Target (Hard Cap)</label>
                                <input type="number" id="MAX_POPULATION_TARGET" name="MAX_POPULATION_TARGET" step="1">
                            </div>
                            <div>
                                <label for="LOW_POPULATION_THRESHOLD">Low Pop. Mate Boost Threshold</label>
                                <input type="number" id="LOW_POPULATION_THRESHOLD" name="LOW_POPULATION_THRESHOLD" step="1">
                            </div>
                            <div>
                                <label for="MIN_POPULATION_TARGET">Min. Pop. Target (News Trigger)</label>
                                <input type="number" id="MIN_POPULATION_TARGET" name="MIN_POPULATION_TARGET" step="1">
                            </div>
                            <div>
                                <label for="MAX_CHILDREN_PER_BIRTH">Max Children Per Birth</label>
                                <input type="number" id="MAX_CHILDREN_PER_BIRTH" name="MAX_CHILDREN_PER_BIRTH" step="1">
                            </div>

                            <div class="fieldset-subheader sm:col-span-2">Mating & Energy Costs</div>
                            <div>
                                <label for="MATE_ENERGY_COST">Mate Energy Cost</label>
                                <input type="number" id="MATE_ENERGY_COST" name="MATE_ENERGY_COST" step="1">
                            </div>
                            <div>
                                <label for="MATE_COOLDOWN">Mate Cooldown (Turns)</label>
                                <input type="number" id="MATE_COOLDOWN" name="MATE_COOLDOWN" step="10">
                            </div>

                            <div class="fieldset-subheader sm:col-span-2">Combat Parameters</div>
                            <div>
                                <label for="ATTACK_DAMAGE_BASE">Attack Damage Base</label>
                                <input type="number" id="ATTACK_DAMAGE_BASE" name="ATTACK_DAMAGE_BASE" step="1">
                            </div>
                            <div>
                                <label for="ATTACK_COST_BASE">Attack Cost Base</label>
                                <input type="number" id="ATTACK_COST_BASE" name="ATTACK_COST_BASE" step="1">
                            </div>
                            <div>
                                <label for="ADULT_ENERGY_RETURN_ON_ATTACK">Energy Return on Attack</label>
                                <input type="number" id="ADULT_ENERGY_RETURN_ON_ATTACK" name="ADULT_ENERGY_RETURN_ON_ATTACK" step="1">
                            </div>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Resources & Farming</legend>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="FOOD_SPAWN_RATE">Food Spawn Rate</label>
                                <input type="number" id="FOOD_SPAWN_RATE" name="FOOD_SPAWN_RATE" step="1">
                            </div>
                            <div>
                                <label for="WOOD_SPAWN_RATE">Wood Spawn Rate</label>
                                <input type="number" id="WOOD_SPAWN_RATE" name="WOOD_SPAWN_RATE" step="1">
                            </div>
                            <div>
                                <label for="FOOD_FRESHNESS">Food Freshness</label>
                                <input type="number" id="FOOD_FRESHNESS" name="FOOD_FRESHNESS" step="1">
                            </div>
                            <div>
                                <label for="GROW_TIME">Grow Time (Food)</label>
                                <input type="number" id="GROW_TIME" name="GROW_TIME" step="1">
                            </div>
                            <div>
                                <label for="TREE_GROW_TIME">Grow Time (Tree)</label>
                                <input type="number" id="TREE_GROW_TIME" name="TREE_GROW_TIME" step="1">
                            </div>
                            <div>
                                <label for="WOOD_SEED_CHANCE">Wood Seed Chance</label>
                                <input type="number" id="WOOD_SEED_CHANCE" name="WOOD_SEED_CHANCE" step="0.01">
                            </div>
                            <div>
                                <label for="FOOD_SEED_BASE_CHANCE">Food Seed Chance</label>
                                <input type="number" id="FOOD_SEED_BASE_CHANCE" name="FOOD_SEED_BASE_CHANCE" step="0.01">
                            </div>
                            
                            <div class="fieldset-subheader sm:col-span-2">Fruit Parameters</div>
                            <div>
                                <label for="STARTING_FRUIT_BUSHES">Starting Fruit Bushes</label>
                                <input type="number" id="STARTING_FRUIT_BUSHES" name="STARTING_FRUIT_BUSHES" step="1">
                            </div>
                            <div>
                                <label for="FRUIT_SPAWN_RATE">Fruit Spawn Rate</label>
                                <input type="number" id="FRUIT_SPAWN_RATE" name="FRUIT_SPAWN_RATE" step="1">
                            </div>
                            <div>
                                <label for="FRUIT_GROW_TIME">Fruit Grow Time</label>
                                <input type="number" id="FRUIT_GROW_TIME" name="FRUIT_GROW_TIME" step="1">
                            </div>
                            <div>
                                <label for="FRUIT_SEED_BASE_CHANCE">Fruit Seed Chance</label>
                                <input type="number" id="FRUIT_SEED_BASE_CHANCE" name="FRUIT_SEED_BASE_CHANCE" step="0.01">
                            </div>
                            <div>
                                <label for="MAX_FRUIT_CARRIED">Max Fruit Carried</label>
                                <input type="number" id="MAX_FRUIT_CARRIED" name="MAX_FRUIT_CARRIED" step="1">
                            </div>
                            <div>
                                <label for="STARTING_FRUIT_SEEDS_MAX">Max Start Fruit Seeds</label>
                                <input type="number" id="STARTING_FRUIT_SEEDS_MAX" name="STARTING_FRUIT_SEEDS_MAX" step="1">
                            </div>
                            <div class="fieldset-subheader sm:col-span-2">Fruit Benefits</div>
                            <div>
                                <label for="FRUIT_BENEFIT_ENERGY_VAL">Energy Fruit Value</label>
                                <input type="number" id="FRUIT_BENEFIT_ENERGY_VAL" name="FRUIT_BENEFIT_ENERGY_VAL" step="10">
                            </div>
                            <div>
                                <label for="FRUIT_BENEFIT_SOCIAL_ENERGY_VAL">Social Fruit Energy</label>
                                <input type="number" id="FRUIT_BENEFIT_SOCIAL_ENERGY_VAL" name="FRUIT_BENEFIT_SOCIAL_ENERGY_VAL" step="10">
                            </div>
                            <div>
                                <label for="FRUIT_BENEFIT_SOCIAL_SOCIAL_VAL">Social Fruit Social</label>
                                <input type="number" id="FRUIT_BENEFIT_SOCIAL_SOCIAL_VAL" name="FRUIT_BENEFIT_SOCIAL_SOCIAL_VAL" step="10">
                            </div>
                            <div>
                                <label for="FRUIT_BENEFIT_SPEED_ENERGY_VAL">Speed Fruit Energy</label>
                                <input type="number" id="FRUIT_BENEFIT_SPEED_ENERGY_VAL" name="FRUIT_BENEFIT_SPEED_ENERGY_VAL" step="1">
                            </div>
                            <div>
                                <label for="FRUIT_BENEFIT_SPEED_DURATION">Speed Fruit Duration</label>
                                <input type="number" id="FRUIT_BENEFIT_SPEED_DURATION" name="FRUIT_BENEFIT_SPEED_DURATION" step="1">
                            </div>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Structures</legend>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="CAMPFIRE_BURN_TIME">Campfire Burn Time</label>
                                <input type="number" id="CAMPFIRE_BURN_TIME" name="CAMPFIRE_BURN_TIME" step="1">
                            </div>
                            <div>
                                <label for="CAMPFIRE_WOOD_COST">Campfire Wood Cost</label>
                                <input type="number" id="CAMPFIRE_WOOD_COST" name="CAMPFIRE_WOOD_COST" step="1">
                            </div>
                            <div>
                                <label for="CAMPFIRE_REFUEL_THRESHOLD">Campfire Refuel</label>
                                <input type="number" id="CAMPFIRE_REFUEL_THRESHOLD" name="CAMPFIRE_REFUEL_THRESHOLD" step="1">
                            </div>
                            <div>
                                <label for="HOME_DURABILITY_START">Home Durability</label>
                                <input type="number" id="HOME_DURABILITY_START" name="HOME_DURABILITY_START" step="1">
                            </div>
                            <div>
                                <label for="HOME_DECAY_RATE">Home Decay Rate</label>
                                <input type="number" id="HOME_DECAY_RATE" name="HOME_DECAY_RATE" step="1">
                            </div>
                        </div>
                    </fieldset>
                    
                    <fieldset>
                        <legend>Age & Love & Pause</legend>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="ADULT_AGE">Adult Age</label>
                                <input type="number" id="ADULT_AGE" name="ADULT_AGE" step="1">
                            </div>
                            <div>
                                <label for="OLD_AGE">Old Age</label>
                                <input type="number" id="OLD_AGE" name="OLD_AGE" step="1">
                            </div>
                            <div>
                                <label for="MAX_AGE">Max Age</label>
                                <input type="number" id="MAX_AGE" name="MAX_AGE" step="1">
                            </div>
                            
                            <div class="fieldset-subheader sm:col-span-2">Love & Apathy Controls (Developer)</div>
                            <div>
                                <label for="STARTING_LOVE">Starting Love</label>
                                <input type="number" id="STARTING_LOVE" name="STARTING_LOVE" step="0.1">
                            </div>
                            <div>
                                <label for="LOVE_GAIN_EAT">Love Gain (Eat)</label>
                                <input type="number" id="LOVE_GAIN_EAT" name="LOVE_GAIN_EAT" step="0.1">
                            </div>
                            <div>
                                <label for="LOVE_GAIN_SOCIAL">Love Gain (Social)</label>
                                <input type="number" id="LOVE_GAIN_SOCIAL" name="LOVE_GAIN_SOCIAL" step="0.1">
                            </div>
                            <div>
                                <label for="LOVE_GAIN_REST">Love Gain (Rest)</label>
                                <input type="number" id="LOVE_GAIN_REST" name="LOVE_GAIN_REST" step="0.1">
                            </div>
                            <div>
                                <label for="LOVE_LOSS_STRUGGLE">Love Loss (Struggle)</label>
                                <input type="number" id="LOVE_LOSS_STRUGGLE" name="LOVE_LOSS_STRUGGLE" step="0.1">
                            </div>
                            <div>
                                <label for="PASSIVE_LOVE_GAIN">Passive Love Gain</label>
                                <input type="number" id="PASSIVE_LOVE_GAIN" name="PASSIVE_LOVE_GAIN" step="0.01">
                            </div>
                            <div class="fieldset-subheader sm:col-span-2">Pause Thresholds</div>
                            <div>
                                <label for="PAUSE_ENERGY_THRESHOLD">Pause Energy</label>
                                <input type="number" id="PAUSE_ENERGY_THRESHOLD" name="PAUSE_ENERGY_THRESHOLD" step="1">
                            </div>
                            <div>
                                <label for="PAUSE_SOCIAL_THRESHOLD">Pause Social</label>
                                <input type="number" id="PAUSE_SOCIAL_THRESHOLD" name="PAUSE_SOCIAL_THRESHOLD" step="1">
                            </div>
                        </div>
                    </fieldset>
                    
                    <fieldset>
                        <legend>Apathy & Vengeance</legend>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="APATHY_DURATION">Apathy Duration</label>
                                <input type="number" id="APATHY_DURATION" name="APATHY_DURATION" step="1">
                            </div>
                            <div>
                                <label for="APATHY_METABOLISM_PENALTY">Apathy Metabolism Penalty</label>
                                <input type="number" id="APATHY_METABOLISM_PENALTY" name="APATHY_METABOLISM_PENALTY" step="0.1">
                            </div>
                            <div>
                                <label for="APATHY_SOCIAL_LOSS_MULTIPLIER">Apathy Social Loss Multiplier</label>
                                <input type="number" id="APATHY_SOCIAL_LOSS_MULTIPLIER" name="APATHY_SOCIAL_LOSS_MULTIPLIER" step="0.1">
                            </div>
                            <div>
                                <label for="VENGEANCE_DURATION">Vengeance Duration</label>
                                <input type="number" id="VENGEANCE_DURATION" name="VENGEANCE_DURATION" step="1">
                            </div>
                        </div>
                    </fieldset>

                    <fieldset>
                        <legend>Environment & Sickness</legend>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="ENV_HEALTH_MAX">Env. Health Max</label>
                                <input type="number" id="ENV_HEALTH_MAX" name="ENV_HEALTH_MAX" step="0.1">
                            </div>
                            <div>
                                <label for="ENV_PASSIVE_RECOVERY_RATE">Env. Recovery</label>
                                <input type="number" id="ENV_PASSIVE_RECOVERY_RATE" name="ENV_PASSIVE_RECOVERY_RATE" step="0.01">
                            </div>
                            <div>
                                <label for="ENV_DECAY_FOOD_GATHER">Env. Decay (Food)</label>
                                <input type="number" id="ENV_DECAY_FOOD_GATHER" name="ENV_DECAY_FOOD_GATHER" step="0.01">
                            </div>
                            <div>
                                <label for="ENV_DECAY_WOOD_GATHER">Env. Decay (Wood)</label>
                                <input type="number" id="ENV_DECAY_WOOD_GATHER" name="ENV_DECAY_WOOD_GATHER" step="0.01">
                            </div>
                            <div>
                                <label for="ENV_HEAL_PLANT_BASE">Env. Heal (Plant Base)</label>
                                <input type="number" id="ENV_HEAL_PLANT_BASE" name="ENV_HEAL_PLANT_BASE" step="0.1">
                            </div>
                            
                            <div class="fieldset-subheader sm:col-span-2">Pollution & Density</div>
                            <div>
                                <label for="ENV_DECAY_CAMPFIRE_POLLUTION">Campfire Pollution</label>
                                <input type="number" id="ENV_DECAY_CAMPFIRE_POLLUTION" name="ENV_DECAY_CAMPFIRE_POLLUTION" step="0.01">
                            </div>
                            <div>
                                <label for="ENV_OVERPOPULATION_RADIUS">Overpop. Radius</label>
                                <input type="number" id="ENV_OVERPOPULATION_RADIUS" name="ENV_OVERPOPULATION_RADIUS" step="1">
                            </div>
                            <div>
                                <label for="ENV_OVERPOPULATION_THRESHOLD">Overpop. Threshold</label>
                                <input type="number" id="ENV_OVERPOPULATION_THRESHOLD" name="ENV_OVERPOPULATION_THRESHOLD" step="1">
                            </div>
                            <div>
                                <label for="ENV_OVERPOPULATION_DECAY">Overpop. Decay</label>
                                <input type="number" id="ENV_OVERPOPULATION_DECAY" name="ENV_OVERPOPULATION_DECAY" step="0.01">
                            </div>
                            
                            <div class="fieldset-subheader sm:col-span-2">Sickness</div>
                            <div>
                                <label for="ENV_SICKNESS_THRESHOLD">Sickness Health %</label>
                                <input type="number" id="ENV_SICKNESS_THRESHOLD" name="ENV_SICKNESS_THRESHOLD" step="1">
                            </div>
                            <div>
                                <label for="ENV_SICKNESS_CHANCE">Sickness Chance</label>
                                <input type="number" id="ENV_SICKNESS_CHANCE" name="ENV_SICKNESS_CHANCE" step="0.0001">
                            </div>
                            <div>
                                <label for="ENV_SICKNESS_DURATION">Sickness Duration</label>
                                <input type="number" id="ENV_SICKNESS_DURATION" name="ENV_SICKNESS_DURATION" step="1">
                            </div>
                            <div>
                                <label for="ENV_SICKNESS_METABOLISM_PENALTY">Sickness Metabolism Penalty</label>
                                <input type="number" id="ENV_SICKNESS_METABOLISM_PENALTY" name="ENV_SICKNESS_METABOLISM_PENALTY" step="0.1">
                            </div>
                        </div>
                    </fieldset>

                    <fieldset id="developerSettings" class="hidden">
                        <legend class="flex items-center space-x-2 text-lg text-red-400 font-bold">
                            <span class="text-xl">‚ö†Ô∏è</span><span>Developer Overrides (Core Physics)</span>
                        </legend>
                        
                        <div class="fieldset-subheader sm:col-span-2">Agent Energy & Movement Physics</div>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="STARTING_ENERGY">Starting Energy</label>
                                <input type="number" id="STARTING_ENERGY" name="STARTING_ENERGY" step="10">
                            </div>
                            <div>
                                <label for="MOVE_BASE_ENERGY_COST">Move Base Energy Cost</label>
                                <input type="number" id="MOVE_BASE_ENERGY_COST" name="MOVE_BASE_ENERGY_COST" step="0.01">
                            </div>
                            <div>
                                <label for="NAV_MIN_COST_MULTIPLIER">Nav. Min Cost Multiplier</label>
                                <input type="number" id="NAV_MIN_COST_MULTIPLIER" name="NAV_MIN_COST_MULTIPLIER" step="0.01">
                            </div>
                            <div>
                                <label for="STUCK_TIMER_DURATION">Stuck Timer Duration (Turns)</label>
                                <input type="number" id="STUCK_TIMER_DURATION" name="STUCK_TIMER_DURATION" step="1">
                            </div>
                        </div>

                        <div class="fieldset-subheader sm:col-span-2">Child & Home Energy Management</div>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="CHILD_METABOLISM_CAP">Child Metabolism Cap</label>
                                <input type="number" id="CHILD_METABOLISM_CAP" name="CHILD_METABOLISM_CAP" step="0.05">
                            </div>
                            <div>
                                <label for="CHILD_DEATH_THRESHOLD">Child Death Threshold</label>
                                <input type="number" id="CHILD_DEATH_THRESHOLD" name="CHILD_DEATH_THRESHOLD" step="1">
                            </div>
                            <div>
                                <label for="HOME_METABOLISM_MULTIPLIER">Home Metabolism Multiplier</label>
                                <input type="number" id="HOME_METABOLISM_MULTIPLIER" name="HOME_METABOLISM_MULTIPLIER" step="0.05">
                            </div>
                            <div>
                                <label for="CAMPFIRE_METABOLISM_MULTIPLIER">Campfire Metabolism Multiplier</label>
                                <input type="number" id="CAMPFIRE_METABOLISM_MULTIPLIER" name="CAMPFIRE_METABOLISM_MULTIPLIER" step="0.05">
                            </div>
                            <div>
                                <label for="CHILD_PARENTAL_COST">Child Parental Cost</label>
                                <input type="number" id="CHILD_PARENTAL_COST" name="CHILD_PARENTAL_COST" step="0.1">
                            </div>
                        </div>

                        <div class="fieldset-subheader sm:col-span-2">Inventory Limits & World Returns</div>
                        <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                            <div>
                                <label for="MAX_FOOD_CARRY">Max Food Carry</label>
                                <input type="number" id="MAX_FOOD_CARRY" name="MAX_FOOD_CARRY" step="1">
                            </div>
                            <div>
                                <label for="MAX_WOOD_CARRY">Max Wood Carry</label>
                                <input type="number" id="MAX_WOOD_CARRY" name="MAX_WOOD_CARRY" step="1">
                            </div>
                            <div>
                                <label for="MAX_FOOD_SEEDS_CARRIED">Max Food Seeds</label>
                                <input type="number" id="MAX_FOOD_SEEDS_CARRIED" name="MAX_FOOD_SEEDS_CARRIED" step="1">
                            </div>
                            <div>
                                <label for="MAX_WOOD_SEEDS_CARRIED">Max Wood Seeds</label>
                                <input type="number" id="MAX_WOOD_SEEDS_CARRIED" name="MAX_WOOD_SEEDS_CARRIED" step="1">
                            </div>
                             <div>
                                <label for="HOME_WOOD_RETURN_ON_DECAY">Home Wood Return on Decay</label>
                                <input type="number" id="HOME_WOOD_RETURN_ON_DECAY" name="HOME_WOOD_RETURN_ON_DECAY" step="1">
                            </div>
                            <div>
                                <label for="PROXIMITY_CHAT_RADIUS">Chat Radius</label>
                                <input type="number" id="PROXIMITY_CHAT_RADIUS" name="PROXIMITY_CHAT_RADIUS" step="0.1">
                            </div>
                        </div>
                        <div class="fieldset-subheader sm:col-span-2">Learning & Skill Impact Multipliers</div>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="GLOBAL_SKILL_BOOST">Global Skill Boost Amount</label>
                                <input type="number" id="GLOBAL_SKILL_BOOST" name="GLOBAL_SKILL_BOOST" step="0.00001">
                            </div>
                            <div>
                                <label for="SKILL_FORAGE_ENERGY_BONUS_BASE">Forage Energy Bonus Base</label>
                                <input type="number" id="SKILL_FORAGE_ENERGY_BONUS_BASE" name="SKILL_FORAGE_ENERGY_BONUS_BASE" step="1">
                            </div>
                            <div>
                                <label for="SKILL_COMBAT_DAMAGE_BONUS_BASE">Combat Damage Bonus Base</label>
                                <input type="number" id="SKILL_COMBAT_DAMAGE_BONUS_BASE" name="SKILL_COMBAT_DAMAGE_BONUS_BASE" step="1">
                            </div>
                            <div>
                                <label for="SKILL_NAV_COST_REDUCTION">Nav. Cost Reduction (per skill pt)</label>
                                <input type="number" id="SKILL_NAV_COST_REDUCTION" name="SKILL_NAV_COST_REDUCTION" step="0.01">
                            </div>
                            <div>
                                <label for="SKILL_BUILD_COST_REDUCTION">Build Cost Reduction (per skill pt)</label>
                                <input type="number" id="SKILL_BUILD_COST_REDUCTION" name="SKILL_BUILD_COST_REDUCTION" step="0.1">
                            </div>
                            <div>
                                <label for="SKILL_COMBAT_COST_REDUCTION">Combat Cost Reduction (per skill pt)</label>
                                <input type="number" id="SKILL_COMBAT_COST_REDUCTION" name="SKILL_COMBAT_COST_REDUCTION" step="0.1">
                            </div>
                            <div>
                                <label for="SKILL_SOCIAL_GAIN_BONUS">Social Gain Bonus (per skill pt)</label>
                                <input type="number" id="SKILL_SOCIAL_GAIN_BONUS" name="SKILL_SOCIAL_GAIN_BONUS" step="0.5">
                            </div>
                            <div>
                                <label for="SOCIAL_GAIN_BASE">Chat Social Gain Base</label>
                                <input type="number" id="SOCIAL_GAIN_BASE" name="SOCIAL_GAIN_BASE" step="1">
                            </div>
                            <div>
                                <label for="SOCIAL_GAIN_PARTNER_BASE">Chat Social Gain Partner Base</label>
                                <input type="number" id="SOCIAL_GAIN_PARTNER_BASE" name="SOCIAL_GAIN_PARTNER_BASE" step="1">
                            </div>
                        </div>

                        <div class="fieldset-subheader sm:col-span-2">Gene Configuration Limits (Evolution Control)</div>
                        <div class="grid grid-cols-2 sm:grid-cols-4 gap-x-3 gap-y-3">
                            <div class="font-semibold text-gray-400 text-sm hidden sm:block">Gene</div>
                            <div class="font-semibold text-gray-400 text-sm">Min</div>
                            <div class="font-semibold text-gray-400 text-sm">Max</div>
                            <div class="font-semibold text-gray-400 text-sm">Mutate Rate</div>
                            
                            <label for="GENE_VISION_MIN" class="self-center col-span-2 sm:col-span-1">Vision</label>
                            <input type="number" id="GENE_VISION_MIN" name="GENE_VISION_MIN" step="0.1">
                            <input type="number" id="GENE_VISION_MAX" name="GENE_VISION_MAX" step="0.1">
                            <input type="number" id="GENE_VISION_MUTATE_RATE" name="GENE_VISION_MUTATE_RATE" step="0.01">
                            
                            <label for="GENE_SPEED_MIN" class="self-center col-span-2 sm:col-span-1">Speed</label>
                            <input type="number" id="GENE_SPEED_MIN" name="GENE_SPEED_MIN" step="0.1">
                            <input type="number" id="GENE_SPEED_MAX" name="GENE_SPEED_MAX" step="0.1">
                            <input type="number" id="GENE_SPEED_MUTATE_RATE" name="GENE_SPEED_MUTATE_RATE" step="0.01">
                            
                            <label for="GENE_METABOLISM_MIN" class="self-center col-span-2 sm:col-span-1">Metabolism</label>
                            <input type="number" id="GENE_METABOLISM_MIN" name="GENE_METABOLISM_MIN" step="0.1">
                            <input type="number" id="GENE_METABOLISM_MAX" name="GENE_METABOLISM_MAX" step="0.1">
                            <input type="number" id="GENE_METABOLISM_MUTATE_RATE" name="GENE_METABOLISM_MUTATE_RATE" step="0.01">

                            <label for="GENE_AGGRESSION_MIN" class="self-center col-span-2 sm:col-span-1">Aggression</label>
                            <input type="number" id="GENE_AGGRESSION_MIN" name="GENE_AGGRESSION_MIN" step="0.1">
                            <input type="number" id="GENE_AGGRESSION_MAX" name="GENE_AGGRESSION_MAX" step="0.1">
                            <input type="number" id="GENE_AGGRESSION_MUTATE_RATE" name="GENE_AGGRESSION_MUTATE_RATE" step="0.01">

                            <label for="GENE_BUILDER_MIN" class="self-center col-span-2 sm:col-span-1">Builder</label>
                            <input type="number" id="GENE_BUILDER_MIN" name="GENE_BUILDER_MIN" step="0.1">
                            <input type="number" id="GENE_BUILDER_MAX" name="GENE_BUILDER_MAX" step="0.1">
                            <input type="number" id="GENE_BUILDER_MUTATE_RATE" name="GENE_BUILDER_MUTATE_RATE" step="0.01">
                            
                            <label for="GENE_MATING_DRIVE_MIN" class="self-center col-span-2 sm:col-span-1">Mating Drive</label>
                            <input type="number" id="GENE_MATING_DRIVE_MIN" name="GENE_MATING_DRIVE_MIN" step="1">
                            <input type="number" id="GENE_MATING_DRIVE_MAX" name="GENE_MATING_DRIVE_MAX" step="1">
                            <input type="number" id="GENE_MATING_DRIVE_MUTATE_RATE" name="GENE_MATING_DRIVE_MUTATE_RATE" step="0.1">
                            
                            <label for="GENE_SOCIABILITY_MIN" class="self-center col-span-2 sm:col-span-1">Sociability</label>
                            <input type="number" id="GENE_SOCIABILITY_MIN" name="GENE_SOCIABILITY_MIN" step="0.1">
                            <input type="number" id="GENE_SOCIABILITY_MAX" name="GENE_SOCIABILITY_MAX" step="0.1">
                            <input type="number" id="GENE_SOCIABILITY_MUTATE_RATE" name="GENE_SOCIABILITY_MUTATE_RATE" step="0.01">
                            
                            <label for="GENE_FARMING_MIN" class="self-center col-span-2 sm:col-span-1">Farming</label>
                            <input type="number" id="GENE_FARMING_MIN" name="GENE_FARMING_MIN" step="0.1">
                            <input type="number" id="GENE_FARMING_MAX" name="GENE_FARMING_MAX" step="0.1">
                            <input type="number" id="GENE_FARMING_MUTATE_RATE" name="GENE_FARMING_MUTATE_RATE" step="0.01">

                            <label for="GENE_PERSONALITY_MIN" class="self-center col-span-2 sm:col-span-1">Personality</label>
                            <input type="number" id="GENE_PERSONALITY_MIN" name="GENE_PERSONALITY_MIN" step="0.1">
                            <input type="number" id="GENE_PERSONALITY_MAX" name="GENE_PERSONALITY_MAX" step="0.1">
                            <input type="number" id="GENE_PERSONALITY_MUTATE_RATE" name="GENE_PERSONALITY_MUTATE_RATE" step="0.01">
                            
                            <label for="GENE_NAVIGATION_MIN" class="self-center col-span-2 sm:col-span-1">Navigation</label>
                            <input type="number" id="GENE_NAVIGATION_MIN" name="GENE_NAVIGATION_MIN" step="0.1">
                            <input type="number" id="GENE_NAVIGATION_MAX" name="GENE_NAVIGATION_MAX" step="0.1">
                            <input type="number" id="GENE_NAVIGATION_MUTATE_RATE" name="GENE_NAVIGATION_MUTATE_RATE" step="0.01">
                        </div>

                    </fieldset>
                    <div id="developerToggle" class="flex items-center justify-between p-3 mt-4 bg-gray-700 rounded-lg shadow-md hover:bg-gray-600">
                        <span class="font-bold text-red-400">Developer Mode</span>
                        <input type="checkbox" id="DEVELOPER_MODE_TOGGLE" class="h-5 w-5 text-red-600 focus:ring-red-500 border-gray-300 rounded">
                    </div>
                    
                </div>
            </form>
            
            <div class="flex justify-end items-center p-4 bg-gray-900 border-t border-gray-700 rounded-b-lg space-x-4">
                <button id="resetSettingsBtn" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-lg shadow-md">
                    Reset to Default
                </button>
                <button id="saveSettingsBtn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-lg shadow-md">
                    Save & Restart
                </button>
            </div>
        </div>
    </div>
    <div class="w-full">
        <div class="flex flex-col sm:flex-row justify-between sm:items-center mb-4">
            <div>
                <h1 class="text-4xl font-bold text-cyan-400">A-Life: Web Simulation (Enhanced)</h1>
                <p class="text-gray-400 mb-6">A JavaScript implementation of the Python Life Simulation. See evolution in action!</p>
            </div>
            
            <div class="flex flex-col sm:flex-row space-x-4">
                <div class="flex space-x-4 mb-4 sm:mb-0">
                    <button id="openSettingsBtn" class="px-5 py-2.5 bg-gray-700 hover:bg-gray-600 text-white font-medium rounded-lg shadow-md">
                        Settings
                    </button>
                    
                    <button id="interventionDropFood" class="px-5 py-2.5 bg-green-600 hover:bg-green-700 text-white font-medium rounded-lg shadow-md">
                        Drop Supplies üçé
                    </button>
                    
                    <button id="interventionCrisis" class="px-5 py-2.5 bg-red-600 hover:bg-red-700 text-white font-medium rounded-lg shadow-md">
                        Trigger Crisis ‚ö†Ô∏è
                    </button>
                </div>
                
                <a href="agent_mechanics_guide.html" class="px-5 py-2.5 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg shadow-md hidden sm:block">
                    How it Works
                </a>
            </div>
        </div>

        <div class="flex space-x-4 mb-4 items-center">
            <button id="pauseBtn" class="px-4 py-2 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold rounded-lg shadow-md">
                ‚è∏Ô∏è Pause
            </button>
            <button id="speedNormalBtn" class="px-3 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg">
                1x
            </button>
            <button id="speedFastBtn" class="px-3 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded-lg">
                5x
            </button>
            <span id="currentSpeedDisplay" class="text-sm text-gray-400">Speed: 150ms</span>
        </div>

        <div class="flex flex-col lg:grid lg:grid-cols-3 lg:gap-6">

            <div class="order-1 lg:col-span-2 min-w-0 relative"> 
                <div id="canvasWrapper" class="bg-gray-900 p-2 rounded-lg shadow-2xl">
                    <canvas id="worldCanvas"></canvas>
                </div>
            </div>

            <div id="statsPanel" class="mt-6 lg:mt-0 lg:col-span-1 lg:row-start-1 lg:row-span-2 order-2 bg-gray-900 p-6 rounded-lg shadow-2xl font-mono text-xs">
                <div class="mb-4">
                    <p class="text-yellow-400 text-sm">Turn: <span id="turnCounter" class="font-bold text-base">0</span></p>
                    <p class="text-yellow-400 text-sm">Generation: <span id="generationCounter" class="font-bold text-base">0</span></p>
                </div>

                <div class="space-y-4">
                    <h2 class="text-base font-semibold text-cyan-400">Overview</h2>
                    <p>Population: <span id="statPopulation" class="text-white">0</span> | Homes: <span id="statHomes" class="text-white">0</span> | Fires: <span id="statFires" class="text-white">0</span></p>
                    <p class="text-yellow-400 text-sm">Environmental Health: <span id="statEnvHealth" class="font-bold text-base text-green-400">100.0%</span></p>

                    <h2 class="text-base font-semibold text-cyan-400">Average Genes (Evolution)</h2>
                    <div id="geneStats"></div>

                    <h2 class="text-base font-semibold text-cyan-400">Average Skills (Learning)</h2>
                    <div id="skillStats"></div>

                    <h2 class="text-base font-semibold text-cyan-400">Global Knowledge Library</h2>
                    <div id="knowledgeStats"></div>

                    <h2 class="text-base font-semibold text-cyan-400">Death Analysis</h2>
                    <div id="deathStats"></div>
                    
                    <h2 class="text-base font-semibold text-red-400">Recent Events (Death Log)</h2>
                    <div id="deathLogDisplay" class="h-24 overflow-y-auto border-t border-gray-700 pt-2 text-gray-400 text-xs">
                        </div>
                </div>
            </div>

            <div class="mt-4 p-4 bg-gray-900 rounded-lg text-sm font-mono order-3 lg:col-span-2 lg:mt-0">
                <h2 class="text-lg font-semibold mb-2 text-yellow-300">Legend</h2>
                <div id="legend" class="flex flex-wrap gap-x-6 gap-y-1">
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- CONSTANTS MAPPING FROM PYTHON (SYNCHRONIZED) ---
        
        const SETTINGS_STORAGE_KEY = 'aLifeSimSettings';
        
        // --- Lists of genes and skills for iteration (SYNCHRONIZED) ---
        const GENE_LIST = ['vision', 'speed', 'metabolism', 'aggression', 'builder', 'mating_drive', 'sociability', 'farming', 'personality', 'navigation']; 
        const SKILL_LIST = ['foraging', 'social', 'building', 'navigation', 'combat', 'farming'];
        
        // --- PERSONALITY CONSTANTS (SYNCHRONIZED) ---
        const PERSONALITY_COOPERATIVE = 1;
        const PERSONALITY_ISOLATED = 2;
        const PERSONALITY_JUDGMENTAL = 3; 
        const PERSONALITY_AGGRESSIVE_COOPERATOR = 4;

        const PERSONALITY_CONFLICTS = {
            [PERSONALITY_JUDGMENTAL]: [PERSONALITY_ISOLATED],
            [PERSONALITY_AGGRESSIVE_COOPERATOR]: [PERSONALITY_JUDGMENTAL]
        };
        // --- END PERSONALITY ---
        
        // --- EMOJI MAPPING (NEW: for Thought Bubbles) ---
        const EMOJI_MAP = {
            'WANDERING': 'üòå', 
            'FORAGING': 'üçé',
            'FORAGING_FRUIT': 'üçá',
            'BUILDING': 'üî®',
            'WANDERING_TO_BUILD': '‚û°Ô∏è',
            'SEEKING_COMMUNITY': 'üèòÔ∏è',
            'SEEKING_REMOTE_SPOT': 'üèïÔ∏è',
            'GETTING_WOOD': 'üå≥',
            'PLANTING': 'üå±',
            'PLANTING_WOOD': 'üå≤',
            'GOING_HOME_TO_FARM': 'üè†üå±',
            'GOING_HOME_TO_PLANT_WOOD': 'üè†üå≤',
            'SHARING': 'ü§ù',
            'BUILDING_CAMPFIRE': 'üî•',
            'REPAIRING_HOME': 'üîß',
            'CLAIMING_HOME': 'üîë',
            'REFUELING_CAMPFIRE': 'ü™µ',
            'MATING': '‚ù§Ô∏è',
            'SEEKING_MATE': 'üëÄ‚ù§Ô∏è', 
            'ATTACKING': 'üí•',
            'RETALIATING': 'üí¢',
            'AVENGING': 'üíÄ', 
            'SEEKING_SOCIAL': 'üí¨',
            'COMMUNICATING': 'üó£Ô∏è',
            'SEEKING_LIBRARY': 'üìö',
            'SOCIAL_SAD': 'üòî',
            'SOCIAL_HAPPY': 'üòä',
            'SICK': 'ü§¢',
            'APATHY': 'üò¥',
        };

        // These are the hard-coded defaults (SYNCHRONIZED WITH PYTHON life_simulation.py)
          const defaultSimSettings = {
            // --- DISPLAY SETTINGS (New to Emoji Version) ---
            DISPLAY_WORLD_LIGHT_MODE: false, 
            DISPLAY_EMOJI_MODE: true, 
            DEVELOPER_MODE_TOGGLE: false, 
            
            // --- CRITICAL FIXES (Missing in uploaded file) ---
            STARTING_SOCIAL_MAX: 100, // REQUIRED for social logic
            STARTING_SOCIAL_MIN: 50,  // REQUIRED for social logic

            // --- SIMULATION LIFE STAGE CONSTANTS ---
            ADULT_AGE: 300,
            OLD_AGE: 1500,
            MAX_AGE: 2000,
            
            // Love Parameters
            STARTING_LOVE: 10, 
            LOVE_GAIN_EAT: 2.0,
            LOVE_GAIN_SOCIAL: 2.0, 
            LOVE_GAIN_REST: 0.5,
            LOVE_LOSS_STRUGGLE: 5, 
            PASSIVE_LOVE_GAIN: 0.1,

            // PAUSE THRESHOLDS
            PAUSE_ENERGY_THRESHOLD: 100,
            PAUSE_SOCIAL_THRESHOLD: 80, 

            // --- ENVIRONMENTAL DEGRADATION CONSTANTS ---
            ENV_HEALTH_MAX: 100.0,
            ENV_PASSIVE_RECOVERY_RATE: 0.20,
            ENV_DECAY_FOOD_GATHER: 0.01,
            ENV_DECAY_WOOD_GATHER: 0.01,
            ENV_HEAL_PLANT_BASE: 5.0,
            ENV_DECAY_CAMPFIRE_POLLUTION: 0.01,
            ENV_OVERPOPULATION_RADIUS: 5,      
            ENV_OVERPOPULATION_THRESHOLD: 10,   
            ENV_OVERPOPULATION_DECAY: 0.01,
            ENV_SICKNESS_THRESHOLD: 20.0,      
            ENV_SICKNESS_CHANCE: 0.0001,        
            ENV_SICKNESS_DURATION: 100,        
            ENV_SICKNESS_METABOLISM_PENALTY: 0.2, 

            // --- APATHY & VENGEANCE SYSTEM ---
            APATHY_DURATION: 100,
            APATHY_METABOLISM_PENALTY: 0.5,
            APATHY_SOCIAL_LOSS_MULTIPLIER: 2.0,
            VENGEANCE_DURATION: 50,
            
// --- POPULATION & CRITICAL THRESHOLDS ---
            MIN_POPULATION_TARGET: 16, // News Trigger
            LOW_POPULATION_THRESHOLD: 4, // Agents mate more easily below this count
            CRITICAL_FOOD_COUNT: 70, 
            MAX_POPULATION_TARGET: 150, // Hard Cap
            MAX_CHILDREN_PER_BIRTH: 2,

            // --- SIMULATION PARAMETERS ---
            WORLD_WIDTH: 70,
            WORLD_HEIGHT: 30,
            STARTING_AGENTS: 15,
            STARTING_FOOD: 250,  
            STARTING_WOOD: 150,  
            SIM_SPEED: 150, 

            // Resources spawn every N turns
            FOOD_SPAWN_RATE: 20,
            WOOD_SPAWN_RATE: 50,

            // --- FRUIT PARAMETERS ---
            STARTING_FRUIT_BUSHES: 10,      
            FRUIT_SPAWN_RATE: 300,          
            FRUIT_GROW_TIME: 20,            
            FRUIT_SEED_BASE_CHANCE: 0.7,    
            MAX_FRUIT_CARRIED: 3,          
            STARTING_FRUIT_SEEDS_MAX: 1,    
            FRUIT_BENEFIT_ENERGY_VAL: 150,       
            FRUIT_BENEFIT_SOCIAL_ENERGY_VAL: 100, 
            FRUIT_BENEFIT_SOCIAL_SOCIAL_VAL: 100, 
            FRUIT_BENEFIT_SPEED_ENERGY_VAL: 50,  
            FRUIT_BENEFIT_SPEED_DURATION: 30,     

            // Farming Parameters
            FOOD_FRESHNESS: 300,
            GROW_TIME: 15, 

            // Tree Parameters
            TREE_GROW_TIME: 20, 
            WOOD_SEED_CHANCE: 0.7,
            FOOD_SEED_BASE_CHANCE: 1.2,

            // Campfire Parameters
            CAMPFIRE_BURN_TIME: 500,
            CAMPFIRE_WOOD_COST: 4, 
            CAMPFIRE_REFUEL_THRESHOLD: 150, 

            // Home Durability
            HOME_DURABILITY_START: 5,
            HOME_DECAY_RATE: 800,

            // --- CORE PHYSICS (Developer Controls) ---
            STARTING_ENERGY: 250, 
            CHILD_METABOLISM_CAP: 0.25,
            CHILD_DEATH_THRESHOLD: 10,
            ADULT_ENERGY_RETURN_ON_ATTACK: 10,
            CHILD_PARENTAL_COST: 0.2,
            HOME_METABOLISM_MULTIPLIER: 0.5,
            CAMPFIRE_METABOLISM_MULTIPLIER: 0.9,
            HOME_ENERGY_GAIN_RATE: 2.0,
            HOME_SOCIAL_GAIN_RATE: 0.05,
            HOME_MAX_ENERGY_THRESHOLD: 150,
            CAMPFIRE_SOCIAL_GAIN_RATE: 0.05,
            ADULT_FORAGE_THRESHOLD: 70,
            CHILD_FORAGE_THRESHOLD: 120,
            SOCIAL_SEEK_THRESHOLD: 60,
            MATE_ENERGY_BASE_CHECK: 100, // Important check threshold
            MOVE_BASE_ENERGY_COST: 0.05,
            NAV_MIN_COST_MULTIPLIER: 0.25,
            STUCK_TIMER_DURATION: 5,
            HOME_WOOD_RETURN_ON_DECAY: 3,

            // Inventory & Limits
            MAX_FOOD_CARRY: 3,
            MAX_WOOD_CARRY: 4,
            MAX_FOOD_SEEDS_CARRIED: 6,
            STARTING_FOOD_SEEDS_MAX: 3,
            MAX_WOOD_SEEDS_CARRIED: 4,
            STARTING_WOOD_SEEDS_MAX: 2,
            STARTING_FRUIT_SEEDS_MAX: 1,
            PROXIMITY_CHAT_RADIUS: 1.5, 

            // Mating & Combat
            HOME_WOOD_COST: 4,
            FOOD_ENERGY_GAIN_BASE: 180,
            MATE_ENERGY_COST: 60, 
            MATE_COOLDOWN: 200, 
            MAX_CHILDREN_PER_BIRTH: 2,
            ATTACK_DAMAGE_BASE: 10,
            ATTACK_COST_BASE: 5,
            
            // Learning & Social Multipliers
            ISOLATION_SOCIAL_LOSS_RATE: 0.15, 
            GLOBAL_KNOWLEDGE_LEARN_RATE: 0.00005, 
            SKILL_SHARING_RATE: 0.0005,
            LIBRARY_SOCIAL_GAIN: 1.0, 
            SOCIAL_GAIN_BASE: 10, 
            SOCIAL_GAIN_PARTNER_BASE: 5, 
            SKILL_FORAGE_ENERGY_BONUS_BASE: 20,
            SKILL_COMBAT_DAMAGE_BONUS_BASE: 8,

            // Global Skill Focus
            GLOBAL_SKILL_FOCUS: 'farming',
            GLOBAL_SKILL_BOOST: 0.00005, 
            
            // --- GENE PARAMETERS (Critical Fix for Mating) ---
            GENE_VISION_MIN: 3.0, GENE_VISION_MAX: 10.0, GENE_VISION_MUTATE_RATE: 0.05, 
            GENE_SPEED_MIN: 1.0, GENE_SPEED_MAX: 2.0, GENE_SPEED_MUTATE_RATE: 0.05, 
            GENE_METABOLISM_MIN: 0.5, GENE_METABOLISM_MAX: 1.0, GENE_METABOLISM_MUTATE_RATE: 0.05, 
            GENE_AGGRESSION_MIN: 0.0, GENE_AGGRESSION_MAX: 0.5, GENE_AGGRESSION_MUTATE_RATE: 0.05, 
            GENE_BUILDER_MIN: 0.0, GENE_BUILDER_MAX: 0.8, GENE_BUILDER_MUTATE_RATE: 0.05,
            
            // FIX: Lowered from 123-160. Agents will now actually decide to mate.
            GENE_MATING_DRIVE_MIN: 60.0, GENE_MATING_DRIVE_MAX: 80.0, GENE_MATING_DRIVE_MUTATE_RATE: 2.0,
            
            GENE_SOCIABILITY_MIN: 0.0, GENE_SOCIABILITY_MAX: 1.0, GENE_SOCIABILITY_MUTATE_RATE: 0.05,
            GENE_FARMING_MIN: 0.0, GENE_FARMING_MAX: 1.0, GENE_FARMING_MUTATE_RATE: 0.05,
            GENE_PERSONALITY_MIN: 1.0, GENE_PERSONALITY_MAX: 4.0, GENE_PERSONALITY_MUTATE_RATE: 0.1,
            GENE_NAVIGATION_MIN: 0.0, GENE_NAVIGATION_MAX: 3.0, GENE_NAVIGATION_MUTATE_RATE: 0.05,

            // --- SKILL MAXES ---
            SKILL_FORAGE_MAX: 10.0,
            SKILL_SOCIAL_MAX: 10.0,
            SKILL_BUILD_MAX: 4.0, 
            SKILL_NAV_MAX: 3.0, 
            SKILL_COMBAT_MAX: 10.0,
            SKILL_FARM_MAX: 10.0,

            // --- SKILL GAIN RATES ---
            SKILL_GAIN_FORAGE: 0.005, 
            SKILL_GAIN_FARMING: 0.01, 
            SKILL_GAIN_COMBAT: 0.05, 
            SKILL_GAIN_BUILD_HOME: 0.02, 
            SKILL_GAIN_BUILD_FIRE: 0.01, 
            SKILL_GAIN_REPAIR_HOME: 0.01, 
            SKILL_GAIN_SOCIAL_CHAT: 0.0005, 
            SKILL_GAIN_SOCIAL_LIBRARY: 0.005, 
            SKILL_GAIN_NAVIGATION: 0.0001, 
            
            SKILL_FORAGE_SEED_BONUS: 0.02, 
            SKILL_BUILD_COST_REDUCTION: 0.1, 
            SKILL_NAV_COST_REDUCTION: 0.10, 
            SKILL_COMBAT_COST_REDUCTION: 0.5, 
            SKILL_SOCIAL_GAIN_BONUS: 5.0, 
            SKILL_FARM_HEAL_MULTIPLIER: 0.05, 
            GLOBAL_KNOWLEDGE_UPTAKE_RATE: 0.00005, 
        };
        
        let simSettings = {};
        let SKILL_MAXES = {};
        
        // Base Colors - will be modified by applyDisplaySettings
        const BASE_COLORS = {
            CYAN_BRIGHT: '#22d3ee', // A
            CYAN_NORMAL: '#06b6d4', // f
            MAGENTA_BRIGHT: '#d946ef', // m, L (Seek Library), M (Seek Mate), P (Social Fruit), o (Happy)
            MAGENTA_DIM: '#a855f7', // s, b (Growing Bush)
            WHITE_BRIGHT: '#ffffff', // T, g, wellbeing buff
            WHITE_NORMAL: '#f3f4f6', // t, .
            YELLOW_BRIGHT: '#fcd34d', // b, W
            YELLOW_NORMAL: '#f59e0b', // w, E
            RED_BRIGHT: '#f87171', // X, r, V, R, C
            RED_NORMAL: '#ef4444', // c, R (Energy Fruit)
            BLUE_BRIGHT: '#60a5fa', // H, C, k, Speed Buff
            BLUE_NORMAL: '#3b82f6', // B, h, B (Speed Fruit)
            BLUE_DIM: '#1d4ed8', // S(remote spot)
            GREEN_BRIGHT: '#4ade80', // F, G
            GREEN_NORMAL: '#10b981', // p, P, Sickness Buff
            GREEN_DIM: '#059669', // T (Tree)
            LIBRARY: '#a855f7', // L (Structure)
        };

        // Inverted Colors for World Light Mode
        const INVERTED_COLORS = {
            CYAN_BRIGHT: '#064e3b', // Darker Cyan
            CYAN_NORMAL: '#0891b2', // Dark Cyan
            MAGENTA_BRIGHT: '#7e22ce', // Darker Magenta
            MAGENTA_DIM: '#4c1d95', // Dark Magenta Dim
            WHITE_BRIGHT: '#000000', // Black
            WHITE_NORMAL: '#374151', // Dark Gray
            YELLOW_BRIGHT: '#b45309', // Dark Yellow
            YELLOW_NORMAL: '#854d0e', // Darker Yellow
            RED_BRIGHT: '#b91c1c', // Dark Red
            RED_NORMAL: '#991b1b', // Darker Red
            BLUE_BRIGHT: '#2563eb', // Dark Blue
            BLUE_NORMAL: '#1e40af', // Darker Blue
            BLUE_DIM: '#1e3a8a', // Darkest Blue
            GREEN_BRIGHT: '#16a34a', // Dark Green
            GREEN_NORMAL: '#065f46', // Darker Green
            GREEN_DIM: '#047857', // Dark Green Dim
            LIBRARY: '#4c1d95', // Dark Magenta Dim
        };

        let COLORS = { ...BASE_COLORS }; // The currently active color map
        
        // --- CHAR MAP (SYNCHRONIZED) ---
        // Note: The CHAR_MAP uses the KEYS of the COLORS object.
        const CHAR_MAP = {
            'WANDERING': { char: 'A', color: 'CYAN_BRIGHT', dim: false },
            'FORAGING': { char: 'f', color: 'CYAN_NORMAL', dim: false },
            'FORAGING_FRUIT': { char: 'f', color: 'CYAN_NORMAL', dim: false }, 
            'BUILDING': { char: 'b', color: 'YELLOW_BRIGHT', dim: false },
            'WANDERING_TO_BUILD': { char: 'B', color: 'BLUE_NORMAL', dim: false },
            'SEEKING_COMMUNITY': { char: 'C', color: 'BLUE_BRIGHT', dim: false },
            'SEEKING_REMOTE_SPOT': { char: 'S', color: 'BLUE_DIM', dim: true },
            'GETTING_WOOD': { char: 'w', color: 'YELLOW_NORMAL', dim: false },
            'PLANTING': { char: 'p', color: 'GREEN_NORMAL', dim: false },
            'PLANTING_WOOD': { char: 'p', color: 'GREEN_NORMAL', dim: false },
            'GOING_HOME_TO_FARM': { char: 'G', color: 'GREEN_BRIGHT', dim: false },
            'GOING_HOME_TO_PLANT_WOOD': { char: 'G', color: 'GREEN_BRIGHT', dim: false },
            'SHARING': { char: 'g', color: 'WHITE_BRIGHT', dim: false },
            'BUILDING_CAMPFIRE': { char: 'c', color: 'RED_NORMAL', dim: false },
            'REPAIRING_HOME': { char: 'E', color: 'YELLOW_NORMAL', dim: false },
            'CLAIMING_HOME': { char: 'k', color: 'BLUE_BRIGHT', dim: false },
            'REFUELING_CAMPFIRE': { char: 'R', color: 'RED_BRIGHT', dim: false },
            'MATING': { char: 'm', color: 'MAGENTA_BRIGHT', dim: false },
            'SEEKING_MATE': { char: 'M', color: 'MAGENTA_BRIGHT', dim: false }, 
            'ATTACKING': { char: 'X', color: 'RED_BRIGHT', dim: false },
            'RETALIATING': { char: 'r', color: 'RED_BRIGHT', dim: false },
            'AVENGING': { char: 'V', color: 'RED_BRIGHT', dim: false }, 
            'SEEKING_SOCIAL': { char: 't', color: 'WHITE_NORMAL', dim: false },
            'COMMUNICATING': { char: 'T', color: 'WHITE_BRIGHT', dim: false },
            'SEEKING_LIBRARY': { char: 'L', color: 'MAGENTA_BRIGHT', dim: false },
            'SOCIAL_SAD': { char: 's', color: 'MAGENTA_DIM', dim: true },
            'SOCIAL_HAPPY': { char: 'o', color: 'MAGENTA_BRIGHT', dim: false },
        };
        
        // --- UTILITY FUNCTIONS ---

        function clamp(value, minVal, maxVal) {
            return Math.max(minVal, Math.min(value, maxVal));
        }

        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }
        
        function arrayToKey(arr) {
            return `${arr[0]},${arr[1]}`;
        }
        
        function keyToArray(key) {
            return key.split(',').map(Number);
        }
        
        // --- NEW: Simple A* Pathfinding (for Agent.moveTowards) ---
        function findPath(world, start, end) {
            const width = world.width;
            const height = world.height;
            const startKey = arrayToKey(start);
            const endKey = arrayToKey(end);

            const openSet = [startKey];
            const cameFrom = {};
            const gScore = { [startKey]: 0 };
            const fScore = { [startKey]: getDistance(start[0], start[1], end[0], end[1]) };

            while (openSet.length > 0) {
                // Find the node with the lowest fScore
                let currentKey = openSet[0];
                for (const key of openSet) {
                    if ((fScore[key] || Infinity) < (fScore[currentKey] || Infinity)) {
                        currentKey = key;
                    }
                }

                const current = keyToArray(currentKey);

                if (currentKey === endKey) {
                    const path = [];
                    let temp = currentKey;
                    while (temp !== startKey) {
                        path.push(temp);
                        temp = cameFrom[temp];
                    }
                    path.reverse();
                    // Return only the next step
                    return path[0] ? keyToArray(path[0]) : end; 
                }

                openSet.splice(openSet.indexOf(currentKey), 1);

                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;

                        const neighbor = [current[0] + dx, current[1] + dy];
                        const neighborKey = arrayToKey(neighbor);

                        if (neighbor[0] < 0 || neighbor[0] >= width || neighbor[1] < 0 || neighbor[1] >= height) continue;

                        // Check if the tile is a hard obstacle (agents still need to check soft obstacles like resources)
                        if (world.isHardObstacle(neighbor[0], neighbor[1])) continue;

                        const tentativeGScore = gScore[currentKey] + getDistance(current[0], current[1], neighbor[0], neighbor[1]);

                        if (tentativeGScore < (gScore[neighborKey] || Infinity)) {
                            cameFrom[neighborKey] = currentKey;
                            gScore[neighborKey] = tentativeGScore;
                            fScore[neighborKey] = tentativeGScore + getDistance(neighbor[0], neighbor[1], end[0], end[1]);

                            if (!openSet.includes(neighborKey)) {
                                openSet.push(neighborKey);
                            }
                        }
                    }
                }
            }

            return null; // No path found
        }
        // --- END Simple A* Pathfinding ---

        // --- AGENT CLASS (SYNCHRONIZED & DEBUGGED) ---

        class Agent {
            constructor(x, y, world, genes = null) {
                this.world = world;
                this.x = x;
                this.y = y;
                this.char = 'A';
                this.id = this.world.getNextAgentId();
                
                // Physical Needs
                this.energy = simSettings.STARTING_ENERGY; 
                this.wood_carried = 0;
                this.food_carried = 0;
                this.fruit_carried = []; // New: List of fruit type strings
                this.mate_cooldown = 0;
                // --- SYNCHRONIZED SEED INVENTORY ---
                this.seeds_carried = Math.floor(Math.random() * simSettings.STARTING_FOOD_SEEDS_MAX); 
                this.wood_seeds_carried = Math.floor(Math.random() * simSettings.STARTING_WOOD_SEEDS_MAX); 
                this.fruit_seeds_carried = Math.floor(Math.random() * simSettings.STARTING_FRUIT_SEEDS_MAX); 
                // --- END SYNCHRONIZED SEED INVENTORY ---

                this.social = Math.random() * (simSettings.STARTING_SOCIAL_MAX - simSettings.STARTING_SOCIAL_MIN) + simSettings.STARTING_SOCIAL_MIN;
                
                this.home_location = null;
                this.campfire_location = null; 
                
                // Buffs/Debuffs
                this.social_buff_timer = 0; 
                this.contentment_buff_timer = 0; 
                this.apathy_timer = 0; 
                this.sickness_timer = 0; // NEW: Sickness Timer
                this.speed_buff_timer = 0; 
                
                this.state = "WANDERING"; 
                this.exploration_vector = [0, 0]; 
                this.stuck_timer = 0; // <<< FREEZE FIX: Added Stuck Timer
                
                // Agent Memory
                this.memory = {
                    'food': new Set(),
                    'wood': new Set(),
                    'fruit': new Set(), 
                    'library': null,
                    'global_news': {} // SYNCHRONIZED: News memory for social propagation
                };
                
                // Struggle & Retaliation
                this.struggle_timer = 0; 
                this.was_attacked_by = null; 
                this.avenging_target_id = null; 
                this.vengeance_timer = 0; 
                
                // Age Tracking and Parental Tracking
                this.age = 0; 
                this.children_ids = new Set(); 
                this.parent_ids = new Set(); 
                
                // Love System
                this.love = simSettings.STARTING_LOVE;
                
                this.skills = {
                    'foraging': 0.0, 'social': 0.0, 'building': 0.0,
                    'navigation': 0.0, 'combat': 0.0, 'farming': 0.0
                };
                
                if (genes) {
                    this.genes = genes;
                } else {
                    this.genes = this.createRandomGenes(this.world.agents.length < simSettings.STARTING_AGENTS);
                }
            }

            createRandomGenes(stabilize = false) {
                const genes = {};
                for (const gene of GENE_LIST) {
                    const geneKey = gene.toUpperCase();
                    const minVal = simSettings[`GENE_${geneKey}_MIN`];
                    const maxVal = simSettings[`GENE_${geneKey}_MAX`];
                    
                    if (stabilize) {
                        if (gene === 'metabolism') {
                            genes[gene] = Math.random() * (simSettings.GENE_METABOLISM_MAX - simSettings.GENE_METABOLISM_MIN) + simSettings.GENE_METABOLISM_MIN;
                        } else if (gene === 'speed') {
                            genes[gene] = Math.random() * (simSettings.GENE_SPEED_MAX - simSettings.GENE_SPEED_MIN) + simSettings.GENE_SPEED_MIN;
                        } else if (gene === 'personality') {
                            if (Math.random() < 0.8) {
                                genes[gene] = Math.floor(Math.random() * (PERSONALITY_ISOLATED - PERSONALITY_COOPERATIVE + 1)) + PERSONALITY_COOPERATIVE;
                            } else {
                                genes[gene] = Math.floor(Math.random() * (PERSONALITY_AGGRESSIVE_COOPERATOR - PERSONALITY_JUDGMENTAL + 1)) + PERSONALITY_JUDGMENTAL;
                            }
                        } else {
                            genes[gene] = Math.random() * (maxVal - minVal) + minVal;
                        }
                    } else {
                        genes[gene] = Math.random() * (maxVal - minVal) + minVal;
                    }
                }
                return genes;
            }

            getPersonality() {
                return Math.floor(clamp(this.genes.personality || 1, 1, 4));
            }
            
            // --- NEW: Helper to get current status icons ---
            getStatusIcons() {
                let icons = [];
                if (this.sickness_timer > 0) icons.push("ü§¢");
                if (this.apathy_timer > 0) icons.push("üò¥");
                if (this.speed_buff_timer > 0) icons.push("üí®");
                if (this.energy < 40) icons.push(" exhaustion");
                if (this.social < 30) icons.push(" loneliness");
                if (this.was_attacked_by) icons.push(" injured");
                if (this.avenging_target_id) icons.push(" vengeance");
                return icons.join(', ');
            }
            // --- END NEW: Helper ---


            update() {
                this.age += 1;
                
                if (this.age >= simSettings.MAX_AGE) {
                    this.die('MAX_AGE');
                    return;
                }
                if (this.age >= simSettings.OLD_AGE && this.energy < 100) { 
                    this.die('NATURAL_DEATH_OLD');
                    return;
                }
                
                let metabolismCost = this.genes['metabolism'];
                let livingChildrenUnderAge = 0;

                // --- Parental Care Cost (SYNCHRONIZED) ---
                for (const childId of Array.from(this.children_ids)) {
                    const child = this.world.getAgentById(childId);
                    if (child) {
                        if (child.age < simSettings.ADULT_AGE) {
                            livingChildrenUnderAge++;
                        } else {
                            this.children_ids.delete(childId);
                        }
                    } else {
                        this.children_ids.delete(childId);
                    }
                }
                const parentalCost = livingChildrenUnderAge * simSettings.CHILD_PARENTAL_COST;

                if (this.age < simSettings.ADULT_AGE) {
                    // Python Fix 2: Cap the child's effective metabolism rate
                    metabolismCost = Math.min(parentalCost, simSettings.CHILD_METABOLISM_CAP);
                    // Python Fix 1: Lower the critical death threshold
                    if (this.energy < simSettings.CHILD_DEATH_THRESHOLD) { 
                        this.die('STARVATION_CHILD');
                        return;
                    }
                } else {
                    metabolismCost += parentalCost;
                }
                // --- End Parental Care Cost ---

                const currentPosKey = arrayToKey([this.x, this.y]);
                if (this.world.homes[currentPosKey]) {
                    const homeData = this.world.homes[currentPosKey];
                    const ownerId = homeData.owner_id;
                    const isOwner = (this.id === ownerId);
                    let isFamily = false;

                    if (ownerId !== null) {
                        const ownerAgent = this.world.getAgentById(ownerId);
                        if (ownerAgent && ownerAgent.children_ids.has(this.id)) {
                            isFamily = true;
                        }
                    }

                    if (isOwner || isFamily) {
                        // Use HOME_METABOLISM_MULTIPLIER
                        metabolismCost *= simSettings.HOME_METABOLISM_MULTIPLIER;
                        // Use HOME_MAX_ENERGY_THRESHOLD
                        if (this.energy < simSettings.HOME_MAX_ENERGY_THRESHOLD) {
                            this.energy = clamp(this.energy + simSettings.HOME_ENERGY_GAIN_RATE, 0, simSettings.HOME_MAX_ENERGY_THRESHOLD);
                        }
                        this.social = clamp(this.social + simSettings.HOME_SOCIAL_GAIN_RATE, 0, 100);
                    }
                }

                if (this.campfire_location && !this.world.campfires[this.campfire_location]) {
                    this.campfire_location = null;
                }

                const nearbyCampfirePosKey = this.world.getNearest(this.x, this.y, 2, this.world.campfires);
                // SYNCHRONIZED: Added check for agent NOT standing on campfire tile
                if (nearbyCampfirePosKey && nearbyCampfirePosKey !== currentPosKey) { 
                    // Use CAMPFIRE_METABOLISM_MULTIPLIER
                    metabolismCost *= simSettings.CAMPFIRE_METABOLISM_MULTIPLIER;
                    this.social = clamp(this.social + simSettings.CAMPFIRE_SOCIAL_GAIN_RATE, 0, 100);
                    this.love = clamp(this.love + simSettings.PASSIVE_LOVE_GAIN, 0, simSettings.STARTING_LOVE); 
                }

                // --- Buff/Debuff Applications ---
                if (this.social_buff_timer > 0) {
                    metabolismCost *= 0.8; 
                    this.social_buff_timer--;
                }
                
                if (this.apathy_timer > 0) {
                    metabolismCost += simSettings.APATHY_METABOLISM_PENALTY; 
                    this.apathy_timer--;
                }
                
                if (this.sickness_timer > 0) {
                    metabolismCost += simSettings.ENV_SICKNESS_METABOLISM_PENALTY;
                    this.sickness_timer--;
                    // The main death check is below, but this logic aligns with Python's flow
                }

                if (this.speed_buff_timer > 0) {
                    this.speed_buff_timer--;
                }

                if (this.vengeance_timer > 0) {
                    this.vengeance_timer--;
                    if (this.vengeance_timer === 0) {
                        this.avenging_target_id = null;
                    }
                }
                
                // --- FREEZE FIX: Update Stuck Timer ---
                if (this.stuck_timer > 0) {
                    this.stuck_timer--;
                }
                // --- END FREEZE FIX ---

                // --- End Buff/Debuff Applications ---


                this.energy -= metabolismCost;
                
                if (this.mate_cooldown > 0) {
                    this.mate_cooldown--;
                }
                
                // --- Social Loss/Gain ---
                let socialLossMultiplier = 1.0;
                if (this.apathy_timer > 0) {
                    socialLossMultiplier = simSettings.APATHY_SOCIAL_LOSS_MULTIPLIER; 
                }

                if (this.contentment_buff_timer > 0) {
                    this.contentment_buff_timer--;
                } else {
                    const visionRadius = Math.floor(this.genes['vision']);
                    const nearbyAgents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                    
                    // Check if isolating (no nearby agents AND no nearby campfire buff)
                    const isIsolated = (nearbyAgents.length === 0 && (!nearbyCampfirePosKey || nearbyCampfirePosKey === currentPosKey)); 
                    
                    if (isIsolated) { 
                        this.social -= this.genes['sociability'] * simSettings.ISOLATION_SOCIAL_LOSS_RATE * socialLossMultiplier;
                    } else {
                        this.social += 0.1;
                    }
                    this.social = clamp(this.social, 0, 100);
                }
                // --- End Social Loss/Gain ---

                // --- Global Skill Focus Boost (NEW) ---
                if (simSettings.GLOBAL_SKILL_FOCUS !== 'none') {
                     const skill = simSettings.GLOBAL_SKILL_FOCUS;
                     this.skills[skill] = clamp(this.skills[skill] + simSettings.GLOBAL_SKILL_BOOST, 0, SKILL_MAXES[skill]);
                }
                // --- End Global Skill Focus Boost ---


                // --- Struggle and Love ---
                if (this.energy < 30 || this.social < 20) {
                    this.struggle_timer++;
                    this.love = clamp(this.love - simSettings.LOVE_LOSS_STRUGGLE, 0, simSettings.STARTING_LOVE);
                } else {
                    this.struggle_timer = 0;
                    this.love = clamp(this.love + simSettings.PASSIVE_LOVE_GAIN, 0, simSettings.STARTING_LOVE);
                }

                // Apathy Trigger
                if (this.love <= 0 && this.apathy_timer === 0) {
                    this.apathy_timer = simSettings.APATHY_DURATION;
                }
                // --- End Struggle and Love ---
                
                // --- Global Knowledge Retrieval (The Library Effect) ---
                for (const skillKey in this.skills) {
                    const globalValue = this.world.globalSkillKnowledge[skillKey] || 0.0;
                    const currentSkill = this.skills[skillKey];
                    // SYNCHRONIZED: Use Python's 0.0001 uptake rate for global knowledge
                    if (currentSkill < globalValue) {
                        this.skills[skillKey] = clamp(currentSkill + simSettings.GLOBAL_KNOWLEDGE_UPTAKE_RATE, 0, SKILL_MAXES[skillKey]);
                    }
                }
                // --- End Global Knowledge Retrieval ---

                if (this.energy <= 0) {
                    if (!this.world.agents.includes(this)) {
                        return;
                    }
                    // SYNCHRONIZED: Check if sickness overrides starvation reason
                    if (this.sickness_timer > 0) {
                        this.die('STARVATION_SICKNESS');
                    } else {
                        this.die('STARVATION_ADULT');
                    }
                    return;
                }

                this.decideState();
                this.executeAction();
            }

            decideState() {
                const visionRadius = Math.floor(this.genes['vision']);
                const currentPosKey = arrayToKey([this.x, this.y]);
                
                // --- FREEZE FIX: Stuck Check Override (New Priority -3) ---
                if (this.stuck_timer > 0) {
                    this.state = "WANDERING"; // Force genuine random exploration
                    return;
                }
                // --- END FREEZE FIX ---

                // --- NEW: Opportunistic Socializing ---
                // Uses PROXIMITY_CHAT_RADIUS developer setting
                const nearbyAgents = this.world.getNearestAgents(this.x, this.y, simSettings.PROXIMITY_CHAT_RADIUS, this);
                if (nearbyAgents.length > 0) {
                    if (!(this.apathy_timer > 0 || this.was_attacked_by || this.avenging_target_id || this.sickness_timer > 0)) {
                        const target = nearbyAgents[Math.floor(Math.random() * nearbyAgents.length)];
                        
                        if (!(target.was_attacked_by || target.avenging_target_id || target.state === "COMMUNICATING")) {
                            
                            let chance = 0.0;
                            
                            const isLingering = (this.state === "WANDERING" || this.state === "SOCIAL_HAPPY") &&
                                               this.energy > simSettings.PAUSE_ENERGY_THRESHOLD &&
                                               this.social > simSettings.PAUSE_SOCIAL_THRESHOLD;
                            
                            if (isLingering) {
                                chance = 0.6;
                            }
                            else if (["WANDERING", "FORAGING", "GETTING_WOOD", "FORAGING_FRUIT"].includes(this.state) && 
                                 this.social > 50 && this.genes['sociability'] > 0.5) {
                                
                                chance = 0.1;
                            }
                            
                            if (Math.random() < chance) {
                                this.communicate(target);
                                return;
                            }
                        }
                    }
                }
                // --- END: Opportunistic Socializing ---

                const foodInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.food);
                const fruitInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.fruits);
                
                const conserveEnergy = this.genes['metabolism'] < 0.8 && this.energy < 100;

                // --- SYNCHRONIZED NEWS CHECK ---
                const hasNewsOfFoodCrisis = this.memory.global_news.food_crisis || false;
                const hasNewsOfLowPop = this.memory.global_news.low_population || false;
                // --- END SYNCHRONIZED NEWS CHECK ---
                
                // Priority -2: Avenging (NEW)
                if (this.avenging_target_id !== null) {
                    const target = this.world.getAgentById(this.avenging_target_id);
                    if (target) {
                        this.state = "AVENGING";
                        return;
                    } else {
                        this.avenging_target_id = null;
                        this.vengeance_timer = 0;
                    }
                }
                
                // Priority -1: Retaliation
                if (this.was_attacked_by !== null) {
                    this.state = "RETALIATING"; 
                    return;
                }

                // Priority 0: Hopeless/Sad
                const totalFoodTargets = foodInSight.length + this.memory.food.size + fruitInSight.length + this.memory.fruit.size;
                if ((this.energy < 20 || this.social < 10) && totalFoodTargets === 0) {
                    this.state = "SOCIAL_SAD"; 
                    return;
                }
                
                // --- CRITICAL SURVIVAL OVERRIDES (MODIFIED: Use local news) ---
                
                // Mandate 1: Plant if Food Crisis or Low Pop News, AND I have seeds
                if ((hasNewsOfFoodCrisis || hasNewsOfLowPop) && (this.seeds_carried > 0 || this.fruit_seeds_carried > 0)) { 
                    if (this.home_location) {
                        const [hx, hy] = keyToArray(this.home_location);
                        const dist = getDistance(this.x, this.y, hx, hy);
                        if (dist > 5) { 
                            this.state = "GOING_HOME_TO_FARM"; 
                        } else {
                            this.state = "PLANTING"; 
                        }
                    } else {
                        this.state = "PLANTING"; 
                    }
                    return;
                }

                // Mandate 2: Share if others are desperately needy
                if (this.energy > 100 && this.social > 50 && (this.wood_carried > 3 || this.food_carried >= 1 || this.fruit_carried.length > 0)) { 
                    const nearbyAgents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                    const needyAgents = nearbyAgents.filter(a => a.energy < 40 && a.food_carried < 1 && a.fruit_carried.length === 0); 
                    if (needyAgents.length > 0) {
                        this.state = "SHARING"; 
                        return;
                    }
                }

// Mandate 3: Seek Mate if population news is active OR if population is critically low visible
const populationIsCritical = this.world.agents.length < simSettings.MIN_POPULATION_TARGET;

if ((hasNewsOfLowPop || populationIsCritical) && 
    this.world.agents.length < simSettings.MAX_POPULATION_TARGET && 
    this.age >= simSettings.ADULT_AGE &&
    this.energy > this.genes['mating_drive'] && 
    this.mate_cooldown === 0) {
    
    this.state = "SEEKING_MATE";
    return; 
}
                
                // Environmental Crisis Priority (SYNCHRONIZED: Only react if sick OR if environmental health is low and I have no other tasks)
                const envLowThreshold = simSettings.ENV_SICKNESS_THRESHOLD;
                if (this.world.environmentalHealth < envLowThreshold) {
                    // Agent only reacts if they are currently sick, making the effect local/delayed
                    if (this.sickness_timer > 0) { 
                    
                        // 1. Prioritize Planting (Healing) if I have seeds
                        if (this.seeds_carried > 0 || this.fruit_seeds_carried > 0 || this.wood_seeds_carried > 0) {
                            this.state = "PLANTING"; 
                            return;
                        }
                        
                        // 2. Halt Wood/Food Gathering (Polluting actions) if not critically starving
                        else if (["GETTING_WOOD", "FORAGING"].includes(this.state) && this.energy > 50) {
                            this.state = "WANDERING"; // Wander to explore/reduce impact
                            return;
                        }
                    }
                }
                // --- END CRITICAL SURVIVAL OVERRIDES ---

                // Priority 1: Survival (Energy)
                // Uses developer settings for forage thresholds
                let forageThreshold = simSettings.ADULT_FORAGE_THRESHOLD;
                if (this.age < simSettings.ADULT_AGE) forageThreshold = simSettings.CHILD_FORAGE_THRESHOLD;

                // If low on energy OR full enough to eat carried food
                if (this.energy < forageThreshold || ((this.food_carried > 0 || this.fruit_carried.length > 0) && this.energy < 150)) { 
                    
                    // NEW: Opportunistic Fruit Seeking (re-checked as priority 1.2 in Python)
                    // If I need social, seek social fruit. (But only if healthy > 120 and not sick)
                    if (this.social < 40 && this.energy > 120 && this.sickness_timer === 0) {
                        const socialFruits = this.world.getNearestFruitOfType(this.x, this.y, visionRadius, this.memory.fruit, 'social');
                        if (socialFruits.length > 0) {
                            this.state = "FORAGING_FRUIT";
                            return;
                        }
                    }
                    // If wandering, chance to seek speed fruit. (But not if sick)
                    if (this.state === "WANDERING" && this.speed_buff_timer === 0 && Math.random() < 0.1 && this.sickness_timer === 0) {
                        const speedFruits = this.world.getNearestFruitOfType(this.x, this.y, visionRadius, this.memory.fruit, 'speed');
                        if (speedFruits.length > 0) {
                            this.state = "FORAGING_FRUIT";
                            return;
                        }
                    }
                    // End Opportunistic Fruit Seeking

                    this.state = "FORAGING";
                    return;
                }
                
                // Priority 1.5: Campfire Refuel
                const nearbyCampfirePosKey = this.world.getNearest(this.x, this.y, visionRadius, this.world.campfires);
                if (nearbyCampfirePosKey) {
                    const campfireTimer = this.world.campfires[nearbyCampfirePosKey];
                    if (campfireTimer < simSettings.CAMPFIRE_REFUEL_THRESHOLD) {
                        if (this.wood_carried < 1) {
                            this.state = "GETTING_WOOD";
                            return;
                        } else {
                            this.state = "REFUELING_CAMPFIRE";
                            return;
                        }
                    }
                }

                // Priority 2: Home Repair
                if (this.home_location) {
                    const homeData = this.world.homes[this.home_location];
                    const isOwner = homeData && homeData.owner_id === this.id;
                    if (homeData && homeData.durability < simSettings.HOME_DURABILITY_START && isOwner) { 
                        if (this.wood_carried < 1) {
                            this.state = "GETTING_WOOD";
                            return;
                        } else {
                            this.state = "REPAIRING_HOME";
                            return;
                        }
                    }
                }
                
                // Priority 3: Social Need (MODIFIED: Priority Campfire)
                // Use developer setting for social seeking threshold
                if (this.social < simSettings.SOCIAL_SEEK_THRESHOLD && this.genes['sociability'] > 0.2 && this.sickness_timer === 0) {
                    this.state = "SEEKING_SOCIAL"; 
                    return;
                }
                
                // Priority 4: Claim or Build Home
                if (this.home_location === null) {
                    const emptyHomePos = this.world.getEmptyHome();
                    if (emptyHomePos) {
                        this.state = "CLAIMING_HOME";
                        return;
                    }
                    
                    if ((Object.keys(this.world.homes).length < this.world.agents.length) && (this.genes['builder'] > Math.random())) {
                        if (conserveEnergy) {
                            this.state = "FORAGING";
                            return;
                        }
                        
                        let woodCostNeeded = Math.max(1, simSettings.HOME_WOOD_COST - Math.floor(this.skills['building'] * simSettings.SKILL_BUILD_COST_REDUCTION));
                        
                        if (this.wood_carried < woodCostNeeded) {
                            this.state = "GETTING_WOOD";
                            return;
                        }

                        const communityRadius = visionRadius + 5; 
                        const nearbyHomes = this.world.getNearestInSet(this.x, this.y, communityRadius, this.world.homes);
                        const isSocial = this.genes['sociability'] > 0.5;
                        
                        if (this.isClearTile(this.x, this.y)) {
                            if (isSocial) {
                                if (nearbyHomes.length > 0 || Object.keys(this.world.homes).length === 0) {
                                    this.state = "BUILDING";
                                } else {
                                    this.state = "SEEKING_COMMUNITY";
                                }
                            } else {
                                if (nearbyHomes.length === 0) {
                                    this.state = "BUILDING";
                                } else {
                                    this.state = "SEEKING_REMOTE_SPOT";
                                }
                            }
                        } else {
                            if (isSocial) {
                                if (nearbyHomes.length > 0 || Object.keys(this.world.homes).length === 0) {
                                    this.state = "WANDERING_TO_BUILD"; 
                                } else {
                                    this.state = "SEEKING_COMMUNITY"; 
                                }
                            } else {
                                if (nearbyHomes.length === 0) {
                                    this.state = "WANDERING_TO_BUILD";
                                } else {
                                    this.state = "SEEKING_REMOTE_SPOT"; 
                                }
                            }
                        }
                        return;
                    }
                }
                
                // Priority 5: Farming (Food/Fruit Seeds)
                if ((this.seeds_carried > 0 || this.fruit_seeds_carried > 0) && this.energy > 80 && this.genes['farming'] > Math.random()) {
                    if (this.home_location) {
                        const [hx, hy] = keyToArray(this.home_location);
                        const dist = getDistance(this.x, this.y, hx, hy);
                        if (dist > 5) { 
                            this.state = "GOING_HOME_TO_FARM"; 
                        } else {
                            this.state = "PLANTING"; 
                        }
                    } else {
                        this.state = "PLANTING"; 
                    }
                    return;
                }

                // Priority 5.5: Planting Trees
                if (this.wood_seeds_carried > 0 && this.energy > 80 &&
                    (Object.keys(this.world.wood).length < simSettings.STARTING_WOOD) && (this.genes['builder'] > Math.random())) { 
                    
                    if (this.home_location) {
                        const [hx, hy] = keyToArray(this.home_location);
                        const dist = getDistance(this.x, this.y, hx, hy);
                        if (dist > 5) {
                            this.state = "GOING_HOME_TO_PLANT_WOOD"; 
                        } else {
                            this.state = "PLANTING_WOOD";
                        }
                    } else {
                        this.state = "PLANTING_WOOD";
                    }
                    return;
                }
                    
                // Priority 6: Build Campfire
                const nearbyActiveFire = this.world.getNearest(this.x, this.y, visionRadius + 5, this.world.campfires);

                if (this.energy > 120 && this.social > 50 && 
                    this.genes['builder'] > 0.5 && 
                    nearbyActiveFire === null &&
                    this.campfire_location === null) { 
                        
                    if (conserveEnergy) {
                        this.state = "FORAGING";
                        return;
                    }

                    let woodCostNeeded = Math.max(1, simSettings.CAMPFIRE_WOOD_COST - Math.floor(this.skills['building'] * simSettings.SKILL_BUILD_COST_REDUCTION));
                    
                    if (this.wood_carried >= woodCostNeeded) {
                         this.state = "BUILDING_CAMPFIRE";
                         return;
                    } else if (this.wood_carried < woodCostNeeded) {
                         this.state = "GETTING_WOOD";
                         return;
                    }
                }
                
                // Priority 7: Share Resources (Standard Share)
                if (this.energy > 100 && this.social > 50 && (this.wood_carried > 3 || this.food_carried >= 1 || this.fruit_carried.length > 0)) {
                    const nearbyAgents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);
                    const needyAgents = nearbyAgents.filter(a => a.energy < 70 && a.food_carried < 1 && a.fruit_carried.length === 0); 
                    if (needyAgents.length > 0) {
                        this.state = "SHARING"; 
                        return;
                    }
                }
                
                // Default State: Wandering
                this.state = "WANDERING";
            }

            executeAction() {
                const visionRadius = Math.floor(this.genes['vision']);
                const currentPosKey = arrayToKey([this.x, this.y]);
                
                // Update Library Memory
                if (this.memory.library === null) {
                    const [lx, ly] = this.world.libraryLocation;
                    if (getDistance(this.x, this.y, lx, ly) <= visionRadius) {
                        this.memory.library = [lx, ly];
                    }
                }

                const foodInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.food);
                const woodInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.wood);
                const fruitInSight = this.world.getNearestInSet(this.x, this.y, visionRadius, this.world.fruits); 
                const agents = this.world.getNearestAgents(this.x, this.y, visionRadius, this);

                const bestFoodTarget = this.getClosestCombinedTarget('food', foodInSight);
                const bestWoodTarget = this.getClosestCombinedTarget('wood', woodInSight);
                const bestFruitTarget = this.getClosestCombinedTarget('fruit', fruitInSight); 

                // --- Handle "Anger" (Aggression) ---
                const agentsOnTile = this.world.agents.filter(a => a.x === this.x && a.y === this.y && a !== this);
                if (agentsOnTile.length > 0) {
                    const target = agentsOnTile[Math.floor(Math.random() * agentsOnTile.length)];
                    
                    const baseAggression = this.genes['aggression'];
                    const struggleBonus = Math.min(this.struggle_timer * 0.0005, 0.5); 
                    const dynamicAggression = baseAggression + struggleBonus;
                    
                    // SYNCHRONIZED: Combat Lock Check (love <= 0 and energy > 80)
                    if (this.love <= 0 && this.energy > 80 && Math.random() < dynamicAggression) {
                        this.attack(target, 'COMBAT_AGGRESSION');
                        return; 
                    }
                }
                // --- End Aggression ---
                
                switch (this.state) {
                    case "FORAGING":
                        // SYNCHRONIZED: Eat if energy < 150 (Food Energy Gain Base)
                        if ((this.food_carried > 0 || this.fruit_carried.length > 0) && this.energy < simSettings.HOME_MAX_ENERGY_THRESHOLD) {
                            
                            const needyNeighbors = agents.filter(a => a.energy < 40 && a.food_carried < 1 && a.fruit_carried.length === 0);
                            
                            if (needyNeighbors.length === 0) {
                                // SYNCHRONIZED: Prioritize Food over Fruit if starving
                                if (this.food_carried > 0) {
                                    this.consumeFood();
                                } else if (this.fruit_carried.length > 0) {
                                    this.consumeFruit();
                                }
                            } else {
                                this.state = "SHARING";
                                return;
                            }
                            
                        } 
                        else if (this.world.food[currentPosKey] && this.food_carried < simSettings.MAX_FOOD_CARRY) {
                            this.pickupFood();
                        }
                        // SYNCHRONIZED: Pick up fruit only if food is not on tile
                        else if (this.world.fruits[currentPosKey] && this.fruit_carried.length < simSettings.MAX_FRUIT_CARRIED && !this.world.food[currentPosKey]) {
                            this.pickupFruit();
                        }
                        else if (bestFoodTarget) { 
                            this.moveTowards(bestFoodTarget[0], bestFoodTarget[1]);
                            if (getDistance(this.x, this.y, bestFoodTarget[0], bestFoodTarget[1]) < 2.0 && !this.world.food[arrayToKey(bestFoodTarget)]) {
                                this.memory.food.delete(arrayToKey(bestFoodTarget));
                            }
                            // --- FIX: Stale memory guard ---
                            if (getDistance(this.x, this.y, bestFoodTarget[0], bestFoodTarget[1]) < 5.0 && this.struggle_timer > 5) {
                                if (!this.world.food[arrayToKey(bestFoodTarget)]) {
                                    this.memory.food.delete(arrayToKey(bestFoodTarget));
                                }
                            }
                            // --- END FIX ---
                        }
                        // SYNCHRONIZED: Fallback to fruit if no food
                        else if (bestFruitTarget) {
                            this.moveTowards(bestFruitTarget[0], bestFruitTarget[1]);
                            if (getDistance(this.x, this.y, bestFruitTarget[0], bestFruitTarget[1]) < 2.0 && !this.world.fruits[arrayToKey(bestFruitTarget)]) {
                                this.memory.fruit.delete(arrayToKey(bestFruitTarget));
                            }
                            // --- FIX: Stale memory guard ---
                            if (getDistance(this.x, this.y, bestFruitTarget[0], bestFruitTarget[1]) < 5.0 && this.struggle_timer > 5) {
                                if (!this.world.fruits[arrayToKey(bestFruitTarget)]) {
                                    this.memory.fruit.delete(arrayToKey(bestFruitTarget));
                                }
                            }
                            // --- END FIX ---
                        }
                        else {
                            this.moveExploring(); 
                        }
                        break;
                        
                    case "FORAGING_FRUIT":
                        if (this.fruit_carried.length > 0 && this.energy < simSettings.HOME_MAX_ENERGY_THRESHOLD) {
                            this.consumeFruit();
                        } else if (this.world.fruits[currentPosKey] && this.fruit_carried.length < simSettings.MAX_FRUIT_CARRIED) {
                            this.pickupFruit();
                        } else {
                            let targetPos = null;

                            // Find target based on need
                            const socialFruits = this.world.getNearestFruitOfType(this.x, this.y, visionRadius, this.memory.fruit, 'social');
                            if (this.social < 40 && socialFruits.length > 0) {
                                targetPos = socialFruits[0];
                            }
                            if (targetPos === null && this.speed_buff_timer === 0) {
                                const speedFruits = this.world.getNearestFruitOfType(this.x, this.y, visionRadius, this.memory.fruit, 'speed');
                                if (speedFruits.length > 0) {
                                    targetPos = speedFruits[0];
                                }
                            }
                            if (targetPos === null && bestFruitTarget) {
                                targetPos = bestFruitTarget;
                            }

                            if (targetPos) {
                                this.moveTowards(targetPos[0], targetPos[1]);
                                if (getDistance(this.x, this.y, targetPos[0], targetPos[1]) < 2.0 && !this.world.fruits[arrayToKey(targetPos)]) {
                                    this.memory.fruit.delete(arrayToKey(targetPos));
                                }
                                // --- FIX: Stale memory guard ---
                                if (getDistance(this.x, this.y, targetPos[0], targetPos[1]) < 5.0 && this.struggle_timer > 5) {
                                    if (!this.world.fruits[arrayToKey(targetPos)]) {
                                        this.memory.fruit.delete(arrayToKey(targetPos));
                                    }
                                }
                                // --- END FIX ---
                            } else {
                                this.state = "WANDERING"; 
                            }
                        }
                        break;

                    case "GETTING_WOOD":
                        const currentWoodPosKey = arrayToKey([this.x, this.y]);
                        if (this.wood_carried >= simSettings.MAX_WOOD_CARRY) {
                            this.state = "WANDERING";
                            return;
                        }
                        if (this.world.wood[currentWoodPosKey] && this.wood_carried < simSettings.MAX_WOOD_CARRY) {
                            this.takeWood();
                        } else if (bestWoodTarget) { 
                            this.moveTowards(bestWoodTarget[0], bestWoodTarget[1]);
                            if (getDistance(this.x, this.y, bestWoodTarget[0], bestWoodTarget[1]) < 2.0 && !this.world.wood[arrayToKey(bestWoodTarget)]) {
                                this.memory.wood.delete(arrayToKey(bestWoodTarget));
                            }
                            // --- FIX: Stale memory guard ---
                            if (getDistance(this.x, this.y, bestWoodTarget[0], bestWoodTarget[1]) < 5.0 && this.struggle_timer > 5) {
                                if (!this.world.wood[arrayToKey(bestWoodTarget)]) {
                                    this.memory.wood.delete(arrayToKey(bestWoodTarget));
                                }
                            }
                            // --- END FIX ---
                        } else {
                            this.moveExploring();
                        }
                        break;

                    case "BUILDING":
                        if (this.isClearTile(this.x, this.y)) {
                            this.buildHome();
                        } else {
                            // --- FIX: Use moveExploring for deterministic pathing ---
                            this.moveExploring(); 
                        }
                        break;

                    case "REPAIRING_HOME":
                        if (this.home_location) {
                            const [hx, hy] = keyToArray(this.home_location);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist < 2.0) {
                                if (this.wood_carried > 0) {
                                    this.world.homes[this.home_location].durability = simSettings.HOME_DURABILITY_START;
                                    this.wood_carried--;
                                    this.skills.building = clamp(this.skills.building + simSettings.SKILL_GAIN_REPAIR_HOME, 0, SKILL_MAXES.building);
                                    this.state = "WANDERING";
                                } else {
                                    this.state = "GETTING_WOOD";
                                }
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "REFUELING_CAMPFIRE":
                        const nearbyCampfireKey = this.world.getNearest(this.x, this.y, 2, this.world.campfires); // Use radius 2 check for refuel
                        if (nearbyCampfireKey) {
                            const [cx, cy] = keyToArray(nearbyCampfireKey);
                            const dist = getDistance(this.x, this.y, cx, cy);
                            if (dist < 2.0) {
                                if (this.wood_carried > 0) {
                                    this.world.campfires[nearbyCampfireKey] = simSettings.CAMPFIRE_BURN_TIME;
                                    this.wood_carried--;
                                    this.state = "WANDERING";
                                } else {
                                    this.state = "GETTING_WOOD";
                                }
                            } else {
                                this.moveTowards(cx, cy);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "CLAIMING_HOME":
                        const emptyHomePos = this.world.getEmptyHome();
                        if (emptyHomePos) {
                            const [hx, hy] = keyToArray(emptyHomePos);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist < 2.0) {
                                this.world.homes[emptyHomePos].owner_id = this.id;
                                this.home_location = emptyHomePos;
                                this.state = "WANDERING";
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "WANDERING_TO_BUILD":
                        this.moveRandomly(0.5, 0.0);
                        break;

                    case "SEEKING_COMMUNITY":
                        const allHomes = this.world.getNearestInSet(this.x, this.y, 999, this.world.homes); 
                        if (allHomes.length > 0) {
                            const [hx, hy] = keyToArray(allHomes[0]);
                            this.moveTowards(hx, hy);
                        } else {
                            this.moveExploring();
                        }
                        break;

                    case "SEEKING_REMOTE_SPOT":
                        this.moveExploring();
                        break;
                    
                    case "GOING_HOME_TO_FARM":
                        if (this.home_location) {
                            const [hx, hy] = keyToArray(this.home_location);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist <= 5.0) {
                                this.state = "PLANTING"; 
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "PLANTING";
                        }
                        break;

                    case "PLANTING":
                        if (this.isClearTile(this.x, this.y)) {
                            // SYNCHRONIZED: Prioritize Fruit > Food > Tree planting
                            if (this.fruit_seeds_carried > 0) {
                                this.plantFruitSeed();
                            } else if (this.seeds_carried > 0) {
                                this.plantSeed();
                            } else if (this.wood_seeds_carried > 0) {
                                this.plantTree();
                            } else {
                                this.state = "WANDERING";
                            }
                        } else {
                            this.moveRandomly(0.5, 0.0);
                        }
                        break;

                    case "GOING_HOME_TO_PLANT_WOOD":
                        if (this.home_location) {
                            const [hx, hy] = keyToArray(this.home_location);
                            const dist = getDistance(this.x, this.y, hx, hy);
                            if (dist <= 5.0) {
                                this.state = "PLANTING_WOOD";
                            } else {
                                this.moveTowards(hx, hy);
                            }
                        } else {
                            this.state = "PLANTING_WOOD";
                        }
                        break;

                    case "PLANTING_WOOD":
                        if (this.isClearTile(this.x, this.y)) {
                            this.plantTree();
                        } else {
                            this.moveRandomly(0.5, 0.0);
                        }
                        break;
                        
                    case "BUILDING_CAMPFIRE":
                        if (this.isClearTile(this.x, this.y)) {
                            this.buildCampfire();
                        } else {
                            this.moveRandomly(0.5, 0.0);
                        }
                        break;

                    case "SHARING":
                        const needyAgents = agents.filter(a => a.energy < 40 && a.food_carried < 1 && a.fruit_carried.length === 0); 
                        let target = needyAgents.length > 0 ? needyAgents[0] : null;

                        if (target === null) {
                            const standardNeedyAgents = agents.filter(a => a.energy < 70 && a.food_carried < 1 && a.fruit_carried.length === 0);
                            target = standardNeedyAgents.length > 0 ? standardNeedyAgents[0] : null;
                        }

                        if (target) {
                            if (getDistance(this.x, this.y, target.x, target.y) < simSettings.PROXIMITY_CHAT_RADIUS) {
                                // SYNCHRONIZED: Share Fruit > Food > Wood
                                if (this.fruit_carried.length > 0 && target.fruit_carried.length < simSettings.MAX_FRUIT_CARRIED) {
                                    const fruitType = this.fruit_carried.pop();
                                    target.fruit_carried.push(fruitType);
                                } else if (this.food_carried >= 1 && target.food_carried < simSettings.MAX_FOOD_CARRY) {
                                    this.food_carried--;
                                    target.food_carried++;
                                } else if (this.wood_carried >= 1 && target.wood_carried < simSettings.MAX_WOOD_CARRY) {
                                    this.wood_carried--;
                                    target.wood_carried++;
                                } 
                                this.state = "WANDERING"; 
                            } else {
                                this.moveTowards(target.x, target.y);
                            }
                        } else {
                            this.state = "WANDERING";
                        }
                        break;

                    case "RETALIATING":
                        const attacker = this.world.getAgentById(this.was_attacked_by);
                        if (attacker) {
                            const dist = getDistance(this.x, this.y, attacker.x, attacker.y);
                            if (dist < 2.0) {
                                this.attack(attacker, 'COMBAT_RETALIATION');
                                this.was_attacked_by = null;
                            } else {
                                this.moveTowards(attacker.x, attacker.y);
                            }
                        } else {
                            this.was_attacked_by = null;
                            this.state = "WANDERING";
                        }
                        break;
                    
                    case "AVENGING":
                        const targetParent = this.world.getAgentById(this.avenging_target_id);
                        if (targetParent) {
                            const potentialRecruits = this.world.getNearestAgents(this.x, this.y, visionRadius, this)
                                .filter(a => a.id !== targetParent.id && a.avenging_target_id === null);
                            
                            // SYNCHRONIZED: Recruit logic
                            for (const recruit of potentialRecruits) {
                                const roll = Math.random();
                                let chance = recruit.genes.aggression * 0.5;
                                const p = recruit.getPersonality();
                                
                                if (p === PERSONALITY_AGGRESSIVE_COOPERATOR) {
                                    chance += 0.4;
                                } else if (p === PERSONALITY_COOPERATIVE) {
                                    chance += 0.1;
                                } else if (p === PERSONALITY_ISOLATED) {
                                    chance -= 0.3;
                                }
                                
                                if (roll < chance) {
                                    recruit.state = "AVENGING";
                                    recruit.avenging_target_id = this.avenging_target_id;
                                    recruit.vengeance_timer = simSettings.VENGEANCE_DURATION;
                                }
                            }
                            // END SYNCHRONIZED: Recruit logic

                            const dist = getDistance(this.x, this.y, targetParent.x, targetParent.y);
                            if (dist < 2.0) {
                                this.attack(targetParent, 'COMBAT_VENDETTA');
                            } else {
                                this.moveTowards(targetParent.x, targetParent.y);
                            }
                        } else {
                            this.avenging_target_id = null;
                            this.vengeance_timer = 0;
                            this.state = "WANDERING";
                        }
                        break;
                    
                    case "SEEKING_MATE":
                        let eligiblePartners = [];
                        const nearbyMates = this.world.getNearestAgents(this.x, this.y, visionRadius, this);

                        for (const agent of nearbyMates) {
                            if (agent.age >= simSettings.ADULT_AGE &&
                               agent.energy > agent.genes['mating_drive'] &&
                               agent.mate_cooldown === 0) {
                                eligiblePartners.push(agent);
                            }
                        }

                        if (eligiblePartners.length > 0) {
                            eligiblePartners.sort((a, b) => 
                                getDistance(this.x, this.y, a.x, a.y) - getDistance(this.x, this.y, b.x, b.y)
                            );
                            const target = eligiblePartners[0];

                            if (getDistance(this.x, this.y, target.x, target.y) < 2.0) {
                                this.mate(target);
                            } else {
                                this.moveTowards(target.x, target.y);
                            }
                        } else {
                            this.moveExploring();
                        }
                        break;
                    
                    case "SEEKING_SOCIAL":
                        const visionRadiusSocial = visionRadius + 5;
                        const nearbyCampfire = this.world.getNearest(this.x, this.y, visionRadiusSocial, this.world.campfires); 
                        
                        let targetAgent = null;
                        
                        // Check for agent targets (Radius 3)
                        const happyAgents = this.world.getNearestAgents(this.x, this.y, 3, this);
                        const happyAndPausing = happyAgents.filter(
                            a => a.energy > simSettings.PAUSE_ENERGY_THRESHOLD && a.social > simSettings.PAUSE_SOCIAL_THRESHOLD
                        );
                        
                        if (happyAndPausing.length > 0) {
                            happyAndPausing.sort((a, b) => b.social - a.social);
                            targetAgent = happyAndPausing[0];
                        }
                        else if (agents.length > 0) {
                            agents.sort((a, b) => 
                                getDistance(this.x, this.y, a.x, a.y) - getDistance(this.x, this.y, b.x, b.y)
                            );
                            targetAgent = agents[0];
                        }
                            
                        // Priority 1: Agent
                        if (targetAgent) {
                            if (getDistance(this.x, this.y, targetAgent.x, targetAgent.y) < simSettings.PROXIMITY_CHAT_RADIUS) {
                                this.communicate(targetAgent);
                            } else {
                                this.moveTowards(targetAgent.x, targetAgent.y);
                            }
                        } 
                        // Priority 2: Campfire
                        else if (nearbyCampfire) {
                            const [cx, cy] = keyToArray(nearbyCampfire);
                            const dist = getDistance(this.x, this.y, cx, cy);
                            if (dist < 2.0) {
                                this.state = "SOCIAL_HAPPY"; // Linger by the fire, then look for chat partners in SOCIAL_HAPPY
                            } else {
                                this.moveTowards(cx, cy);
                            }
                        } 
                        // Priority 3: Library
                        else {
                            if (this.memory.library) {
                                const [lx, ly] = this.memory.library;
                                this.moveTowards(lx, ly);
                                this.state = "SEEKING_LIBRARY"; 
                            } else {
                                this.moveExploring();
                            }
                        }
                        break;
                    
                    case "SOCIAL_HAPPY": 
                        if (this.energy > simSettings.PAUSE_ENERGY_THRESHOLD && this.social > simSettings.PAUSE_SOCIAL_THRESHOLD) {
                            
                            const nearbyCampfireStory = this.world.getNearest(this.x, this.y, 2, this.world.campfires);
                            // SYNCHRONIZED: Call broadcast_skill_to_library from Python
                            if (nearbyCampfireStory && nearbyCampfireStory !== currentPosKey && Math.random() < 0.1) {
                                this.broadcastSkillToLibrary();
                            }
                            
                            if (Math.random() < 0.2 && this.memory.library) { 
                                const [lx_w, ly_w] = this.memory.library;
                                if (getDistance(this.x, this.y, lx_w, ly_w) > 5.0) { 
                                    this.moveTowards(lx_w, ly_w);
                                    this.state = "SEEKING_LIBRARY"; 
                                    return;
                                }
                            }
                        } else {
                            this.moveRandomly(0.5, 0.0); 
                        }
                        break; 
                    
                    case "SEEKING_LIBRARY":
                        // SYNCHRONIZED: Use 0.001 navigation gain for movement
                        this.skills.navigation = clamp(this.skills.navigation + simSettings.SKILL_GAIN_NAVIGATION, 0, SKILL_MAXES.navigation);
                        
                        const [lx, ly] = this.memory.library;
                        
                        if (getDistance(this.x, this.y, lx, ly) < 2.0) {
                            // SYNCHRONIZED: Use 0.01 social gain for library arrival
                            this.skills.social = clamp(this.skills.social + simSettings.SKILL_GAIN_SOCIAL_LIBRARY, 0, SKILL_MAXES.social);
                            this.social = clamp(this.social + simSettings.LIBRARY_SOCIAL_GAIN, 0, 100);
                            this.state = "WANDERING";
                        } else {
                            this.moveTowards(lx, ly);
                        }
                        break;

                    case "SOCIAL_SAD":
                        this.love = clamp(this.love + simSettings.LOVE_GAIN_REST, 0, simSettings.STARTING_LOVE);
                        if (this.energy < 20 && bestFoodTarget) {
                            this.moveTowards(bestFoodTarget[0], bestFoodTarget[1]);
                        } else if (this.energy < 20 && bestFruitTarget) {
                            this.moveTowards(bestFruitTarget[0], bestFruitTarget[1]);
                        } else if (this.social < 10) {
                            const nearestCampfireSad = this.world.getNearest(this.x, this.y, visionRadius, this.world.campfires);
                            if (agents.length > 0) {
                                this.moveTowards(agents[0].x, agents[0].y);
                            } else if (nearestCampfireSad) {
                                const [cx, cy] = keyToArray(nearestCampfireSad);
                                this.moveTowards(cx, cy);
                            } else {
                                if (this.memory.library) {
                                    const [lx, ly] = this.memory.library;
                                    this.moveTowards(lx, ly);
                                    this.state = "SEEKING_LIBRARY";
                                } else {
                                    this.moveExploring();
                                }
                            }
                        } else {
                            this.moveExploring();
                        }
                        break;

                    case "WANDERING":
                        if (this.energy > simSettings.PAUSE_ENERGY_THRESHOLD && this.social > simSettings.PAUSE_SOCIAL_THRESHOLD) {
                            
                            const nearbyCampfireStory = this.world.getNearest(this.x, this.y, 2, this.world.campfires);
                            // SYNCHRONIZED: Call broadcast_skill_to_library from Python
                            if (nearbyCampfireStory && nearbyCampfireStory !== currentPosKey && Math.random() < 0.1) {
                                this.broadcastSkillToLibrary();
                            }
                            
                            if (Math.random() < 0.2 && this.memory.library) { 
                                const [lx_w, ly_w] = this.memory.library;
                                if (getDistance(this.x, this.y, lx_w, ly_w) > 5.0) { 
                                    this.moveTowards(lx_w, ly_w);
                                    this.state = "SEEKING_LIBRARY"; 
                                    return;
                                }
                            }
                        } else {
                            foodInSight.forEach(posKey => this.memory.food.add(posKey));
                            woodInSight.forEach(posKey => this.memory.wood.add(posKey));
                            fruitInSight.forEach(posKey => this.memory.fruit.add(posKey)); 
                            this.moveExploring();
                        }
                        break;
                    
                    case "MATING":
                    case "COMMUNICATING":
                        break;
                }
            }
            
            isClearTile(x, y) {
                const posKey = arrayToKey([x, y]);
                const pos = [x, y];
                if (posKey === arrayToKey(this.world.libraryLocation)) {
                    return false;
                }
                if (this.world.homes[posKey]) return false;
                if (this.world.food[posKey]) return false;
                if (this.world.wood[posKey]) return false;
                if (this.world.growingPlants[posKey]) return false;
                if (this.world.growingTrees[posKey]) return false;
                if (this.world.campfires[posKey]) return false;
                if (this.world.fruits[posKey]) return false;
                if (this.world.growingFruitBushes[posKey]) return false;
                // CHECK AGENTS ON TILE (SYNCHRONIZED with Python planting logic)
                for (const agent of this.world.agents) {
                    if (agent.x === x && agent.y === y && agent !== this) {
                         const pos = [x, y];
                         // EXCEPTION 1: Library
                         if (posKey === arrayToKey(this.world.libraryLocation)) {
                             continue;
                         } 
                         // EXCEPTION 2: Shared Home
                         if (this.home_location === posKey) {
                             const homeData = this.world.homes[posKey];
                             if (homeData) {
                                 const ownerId = homeData.owner_id;
                                 const ownerAgent = this.world.getAgentById(ownerId);
                                 const isFamily = (ownerId !== null) && (ownerAgent && ownerAgent.children_ids.has(agent.id));
                                 if (ownerId === agent.id || isFamily) {
                                     continue;
                                 }
                             }
                         }
                         return false;
                    }
                }
                return true;
            }

            isObstacle(x, y) {
                const posKey = arrayToKey([x, y]);
                const currentPosKey = arrayToKey([this.x, this.y]);
                
                // 1. Structures and Resources
                if (this.world.campfires[posKey]) return true; // Cannot stand ON the fire
                if (posKey === arrayToKey(this.world.libraryLocation)) return true; // Library is a hard obstacle
                
                // 2. Homes/Building (only other agents' homes are obstacles)
                if (this.world.homes[posKey]) {
                    const homeData = this.world.homes[posKey];
                    if (homeData.owner_id !== this.id && homeData.owner_id !== null) {
                        return true;
                    }
                }
                
                // 3. Other Agents (Agents are only obstacles if not at home/library)
                for (const agent of this.world.agents) {
                    if (agent !== this && agent.x === x && agent.y === y) {
                        
                        // EXCEPTION: Shared Home
                        if (this.home_location === posKey) {
                            const homeData = this.world.homes[posKey];
                            if (homeData) {
                                const ownerId = homeData.owner_id;
                                const ownerAgent = this.world.getAgentById(ownerId);
                                const isFamily = (ownerId !== null) && (this.id === ownerId || (ownerAgent && ownerAgent.children_ids.has(this.id)));
                                
                                if (isFamily) continue;
                            }
                        }
                        
                        return true;
                    }
                }
                
                return false;
            }

            moveTowards(targetX, targetY) {
                this.exploration_vector = [0, 0];
                let steps = Math.floor(this.genes['speed']);
                if (this.speed_buff_timer > 0) steps += 2; 
                if (steps < 1) steps = 1;
                
                for (let i = 0; i < steps; i++) {
                    const nextStep = findPath(this.world, [this.x, this.y], [targetX, targetY]);
                    
                    if (nextStep) {
                        const [nextX, nextY] = nextStep;
                        
                        // Check for dynamic obstacles (e.g., other agents, non-permanent resources)
                        if (!this.isObstacle(nextX, nextY)) {
                            this.x = nextX;
                            this.y = nextY;
                        } else {
                            // Obstacle encountered, set stuck timer and break to force re-evaluation
                            this.stuck_timer = simSettings.STUCK_TIMER_DURATION;
                            
                            // CRITICAL FIX: Forget the blocked target so a new path is chosen
                            const targetKey = arrayToKey([targetX, targetY]);
                            if (["FORAGING", "FORAGING_FRUIT"].includes(this.state)) {
                                this.memory.food.delete(targetKey);
                                this.memory.fruit.delete(targetKey);
                            } else if (this.state === "GETTING_WOOD") {
                                this.memory.wood.delete(targetKey);
                            }
                            break;
                        }

                    } else {
                        // No path found (A* returned null) - revert to random movement or break
                        this.stuck_timer = simSettings.STUCK_TIMER_DURATION;
                        break;
                    }
                    
                    this.skills.navigation = clamp(this.skills.navigation + simSettings.SKILL_GAIN_NAVIGATION, 0, SKILL_MAXES.navigation); 
                    // Use developer settings for energy calculation:
                    const costMultiplier = 1.0 - (this.skills.navigation * simSettings.SKILL_NAV_COST_REDUCTION); 
                    const finalMultiplier = Math.max(simSettings.NAV_MIN_COST_MULTIPLIER, costMultiplier); // Use NAV_MIN_COST_MULTIPLIER
                    
                    this.energy -= simSettings.MOVE_BASE_ENERGY_COST * finalMultiplier; // Use MOVE_BASE_ENERGY_COST
                }
            }

            moveRandomly(speedFactor, persistentChance) {
                let steps = Math.floor(this.genes['speed'] * speedFactor);
                if (this.speed_buff_timer > 0) steps += 2;
                if (steps < 1) steps = 1;

                for (let i = 0; i < steps; i++) {
                    let stuck = false;
                    if (this.exploration_vector[0] !== 0 || this.exploration_vector[1] !== 0) {
                        const newX = clamp(this.x + this.exploration_vector[0], 0, this.world.width - 1);
                        const newY = clamp(this.y + this.exploration_vector[1], 0, this.world.height - 1);
                        if (newX === this.x && newY === this.y) {
                            stuck = true; 
                        }
                    }

                    if (this.exploration_vector[0] === 0 && this.exploration_vector[1] === 0 || stuck || Math.random() > persistentChance) {
                        // Loop to find a valid non-zero vector
                        let attempts = 4;
                        while (attempts--) { 
                            this.exploration_vector = [Math.floor(Math.random() * 3) - 1, Math.floor(Math.random() * 3) - 1];
                            if (this.exploration_vector[0] !== 0 || this.exploration_vector[1] !== 0) {
                                break;
                            }
                            if (attempts === 0) {
                                return; // Cannot move
                            }
                        }
                    }
                    
                    const [dx, dy] = this.exploration_vector;
                    
                    const newX = clamp(this.x + dx, 0, this.world.width - 1);
                    const newY = clamp(this.y + dy, 0, this.world.height - 1);

                    if (!this.isObstacle(newX, newY)) {
                        this.x = newX;
                        this.y = newY;
                    } else {
                        this.exploration_vector = [0, 0];
                        break;
                    }
                    
                    this.skills.navigation = clamp(this.skills.navigation + simSettings.SKILL_GAIN_NAVIGATION, 0, SKILL_MAXES.navigation); 
                    const costMultiplier = 1.0 - (this.skills.navigation * simSettings.SKILL_NAV_COST_REDUCTION); 
                    const finalMultiplier = Math.max(simSettings.NAV_MIN_COST_MULTIPLIER, costMultiplier);
                    
                    this.energy -= simSettings.MOVE_BASE_ENERGY_COST * finalMultiplier;
                }
            }

            moveExploring() {
                this.moveRandomly(1.0, 0.8);
            }

            getClosestCombinedTarget(resourceType, visibleResources) {
                const possibleTargets = new Set();
                
                visibleResources.forEach(posKey => possibleTargets.add(posKey));
                this.memory[resourceType].forEach(posKey => possibleTargets.add(posKey));
                
                if (possibleTargets.size === 0) return null;
                    
                let nearestItem = null;
                let minDist = Infinity;
                
                for (const posKey of possibleTargets) {
                    const [ix, iy] = keyToArray(posKey);
                    const dist = getDistance(this.x, this.y, ix, iy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestItem = [ix, iy];
                    }
                }
                return nearestItem;
            }
            
            // --- RESOURCE METHODS (UPDATED for Environment/Skill/Fruit) ---

            consumeFood() {
                if (this.food_carried > 0) {
                    this.food_carried--;
                    this.skills.foraging = clamp(this.skills.foraging + simSettings.SKILL_GAIN_FORAGE, 0, SKILL_MAXES.foraging); 
                    // Use developer setting for energy bonus
                    const energyGain = simSettings.FOOD_ENERGY_GAIN_BASE + (this.skills.foraging * simSettings.SKILL_FORAGE_ENERGY_BONUS_BASE); // FIXED: Using correct constant
                    this.energy += energyGain;
                    this.love = clamp(this.love + simSettings.LOVE_GAIN_EAT, 0, simSettings.STARTING_LOVE);
                    
                    // Environmental Degradation
                    const decayAmount = simSettings.ENV_DECAY_FOOD_GATHER * (1.0 - (this.skills.foraging / SKILL_MAXES.foraging));
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth - decayAmount, 0, simSettings.ENV_HEALTH_MAX);

                    // Seed Chance
                    const foragingChance = simSettings.FOOD_SEED_BASE_CHANCE + (this.skills.foraging * simSettings.SKILL_FORAGE_SEED_BONUS);
                    // SYNCHRONIZED: Check max capacity before adding
                    if (Math.random() < foragingChance && this.seeds_carried < simSettings.MAX_FOOD_SEEDS_CARRIED) {
                        this.seeds_carried++;
                    }

                    this.state = "WANDERING";
                }
            }
            
            consumeFruit() {
                if (this.fruit_carried.length > 0) {
                    const fruitType = this.fruit_carried.pop();
                    this.skills.foraging = clamp(this.skills.foraging + simSettings.SKILL_GAIN_FORAGE, 0, SKILL_MAXES.foraging);
                    
                    // Apply Benefits based on type
                    if (fruitType === 'energy') {
                        this.energy += simSettings.FRUIT_BENEFIT_ENERGY_VAL;
                    } else if (fruitType === 'social') {
                        this.energy += simSettings.FRUIT_BENEFIT_SOCIAL_ENERGY_VAL;
                        this.social = clamp(this.social + simSettings.FRUIT_BENEFIT_SOCIAL_SOCIAL_VAL, 0, 100);
                    } else if (fruitType === 'speed') {
                        this.energy += simSettings.FRUIT_BENEFIT_SPEED_ENERGY_VAL;
                        this.speed_buff_timer = simSettings.FRUIT_BENEFIT_SPEED_DURATION;
                    }
                    
                    this.love = clamp(this.love + simSettings.LOVE_GAIN_EAT, 0, simSettings.STARTING_LOVE);

                    // Environmental Degradation
                    const decayAmount = simSettings.ENV_DECAY_FOOD_GATHER * (1.0 - (this.skills.foraging / SKILL_MAXES.foraging));
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth - decayAmount, 0, simSettings.ENV_HEALTH_MAX);

                    // Fruit Seed Chance
                    const foragingChance = simSettings.FRUIT_SEED_BASE_CHANCE + (this.skills.foraging * simSettings.SKILL_FORAGE_SEED_BONUS);
                     // SYNCHRONIZED: Check max capacity before adding (using STARTING_FRUIT_SEEDS_MAX for MAX_FRUIT_SEEDS_CARRIED as per Python code structure)
                    if (Math.random() < foragingChance && this.fruit_seeds_carried < simSettings.STARTING_FRUIT_SEEDS_MAX) {
                        this.fruit_seeds_carried++;
                    }

                    this.state = "WANDERING";
                }
            }

            pickupFood() {
                const posKey = arrayToKey([this.x, this.y]);
                if (this.world.food[posKey] && this.food_carried < simSettings.MAX_FOOD_CARRY) {
                    delete this.world.food[posKey];
                    delete this.world.foodFreshness[posKey];
                    this.food_carried++;
                    this.memory.food.delete(posKey);
                    this.state = "WANDERING";
                }
            }

            pickupFruit() {
                const posKey = arrayToKey([this.x, this.y]);
                if (this.world.fruits[posKey] && this.fruit_carried.length < simSettings.MAX_FRUIT_CARRIED) {
                    const fruitType = this.world.fruitTypes[posKey];
                    delete this.world.fruits[posKey];
                    delete this.world.fruitTypes[posKey];
                    this.fruit_carried.push(fruitType);
                    this.memory.fruit.delete(posKey);
                    this.state = "WANDERING";
                }
            }

            takeWood() {
                const posKey = arrayToKey([this.x, this.y]);
                if (this.world.wood[posKey] && this.wood_carried < simSettings.MAX_WOOD_CARRY) {
                    delete this.world.wood[posKey];
                    this.wood_carried++;
                    
                    // Environmental Degradation
                    const decayAmount = simSettings.ENV_DECAY_WOOD_GATHER * (1.0 - (this.skills.foraging / SKILL_MAXES.foraging));
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth - decayAmount, 0, simSettings.ENV_HEALTH_MAX);
                    
                    // Wood Seed Chance
                    // SYNCHRONIZED: Check max capacity before adding
                    if (Math.random() < simSettings.WOOD_SEED_CHANCE && this.wood_seeds_carried < simSettings.MAX_WOOD_SEEDS_CARRIED) {
                        this.wood_seeds_carried++;
                    }

                    this.memory.wood.delete(posKey);
                    this.state = "WANDERING";
                }
            }

            buildHome() {
                const posKey = arrayToKey([this.x, this.y]);
                // Use HOME_WOOD_COST developer setting
                let woodCost = Math.max(1, simSettings.HOME_WOOD_COST - Math.floor(this.skills.building * simSettings.SKILL_BUILD_COST_REDUCTION));
                
                if (this.wood_carried >= woodCost) {
                    this.wood_carried -= woodCost;
                    this.world.homes[posKey] = { owner_id: this.id, durability: simSettings.HOME_DURABILITY_START };
                    this.home_location = posKey; 
                    this.state = "WANDERING";
                    this.skills.building = clamp(this.skills.building + simSettings.SKILL_GAIN_BUILD_HOME, 0, SKILL_MAXES.building); 
                }
            }
            
            buildCampfire() {
                const posKey = arrayToKey([this.x, this.y]);
                 // Use CAMPFIRE_WOOD_COST developer setting
                let woodCost = Math.max(1, simSettings.CAMPFIRE_WOOD_COST - Math.floor(this.skills.building * simSettings.SKILL_BUILD_COST_REDUCTION));
                
                if (this.wood_carried >= woodCost) {
                    this.wood_carried -= woodCost;
                    this.world.campfires[posKey] = simSettings.CAMPFIRE_BURN_TIME;
                    this.campfire_location = posKey; 
                    this.skills.building = clamp(this.skills.building + simSettings.SKILL_GAIN_BUILD_FIRE, 0, SKILL_MAXES.building);
                    this.state = "WANDERING";
                }
            }
            
            attack(target, attack_type = 'COMBAT_AGGRESSION') {
                // Use developer settings for combat physics
                let energyCost = Math.max(2, simSettings.ATTACK_COST_BASE - (this.skills.combat * simSettings.SKILL_COMBAT_COST_REDUCTION));
                let damage = simSettings.ATTACK_DAMAGE_BASE + (this.skills.combat * simSettings.SKILL_COMBAT_DAMAGE_BONUS_BASE); // FIXED: Using correct constant
                
                this.state = "ATTACKING";
                this.energy -= energyCost;
                this.energy += simSettings.ADULT_ENERGY_RETURN_ON_ATTACK; // Use developer setting
                
                target.energy -= damage;
                this.skills.combat = clamp(this.skills.combat + simSettings.SKILL_GAIN_COMBAT, 0, SKILL_MAXES.combat); 
                
                this.love = clamp(this.love - 5.0, 0, simSettings.STARTING_LOVE); 

                target.was_attacked_by = this.id;
                
                if (target.energy <= 0) {
                    target.die(attack_type, this.id); // Pass attacker ID for log
                }
            }
            
            mate(partner) {
                // 1. Check Hard Population Cap
                if (this.world.agents.length >= simSettings.MAX_POPULATION_TARGET) {
                    this.state = "WANDERING";
                    partner.state = "WANDERING";
                    return; // Stop mating immediately
                }

                this.state = "MATING";
                partner.state = "MATING";
                
                this.energy -= simSettings.MATE_ENERGY_COST;
                partner.energy -= simSettings.MATE_ENERGY_COST;
                
                this.mate_cooldown = simSettings.MATE_COOLDOWN;
                partner.mate_cooldown = simSettings.MATE_COOLDOWN;
                
                let numChildren = Math.floor(Math.random() * simSettings.MAX_CHILDREN_PER_BIRTH) + 1; 
                
                for (let i = 0; i < numChildren; i++) {
                    // Check cap again before every individual child birth
                    if (this.world.agents.length >= simSettings.MAX_POPULATION_TARGET) break;

                    const newGenes = {};
                    for (const gene of GENE_LIST) {
                        const geneKey = gene.toUpperCase();
                        const minVal = simSettings[`GENE_${geneKey}_MIN`];
                        const maxVal = simSettings[`GENE_${geneKey}_MAX`];
                        const mutRate = simSettings[`GENE_${geneKey}_MUTATE_RATE`];

                        const avgGene = (this.genes[gene] + partner.genes[gene]) / 2;
                        const mutation = (Math.random() * 2 - 1) * mutRate * (maxVal - minVal);
                        newGenes[gene] = clamp(avgGene + mutation, minVal, maxVal);
                    }
                    
                    const newAgent = this.world.addAgent(this.x, this.y, newGenes);
                    if (newAgent) {
                        newAgent.skills = { 'foraging': 0.0, 'social': 0.0, 'building': 0.0, 'navigation': 0.0, 'combat': 0.0, 'farming': 0.0 };
                        newAgent.home_location = null;
                        newAgent.parent_ids = new Set([this.id, partner.id]);
                        
                        this.children_ids.add(newAgent.id);
                        partner.children_ids.add(newAgent.id);
                        
                        this.world.logDeath(this.world.turn, 'BIRTH', newAgent.id, this.id, partner.id); 
                    }
                }
                
                // Just a boost, so they might still want to talk to others soon
this.social = Math.min(this.social + 20, 100); 
partner.social = Math.min(partner.social + 20, 100);
            }

            shareSkills(partner) {
                const learningRate = simSettings.SKILL_SHARING_RATE; 
                
                for (const skill of SKILL_LIST) {
                    // Ensure global_news exists before continuing to skills
                    this.memory.global_news = this.memory.global_news || {};
                    partner.memory.global_news = partner.memory.global_news || {};
                    
                    const selfSkill = this.skills[skill];
                    const partnerSkill = partner.skills[skill];
                    const maxSkill = SKILL_MAXES[skill];
                    
                    if (selfSkill > partnerSkill) {
                        partner.skills[skill] = clamp(partner.skills[skill] + learningRate, 0, maxSkill);
                        // SYNCHRONIZED: Only broadcast if skill is > 2.0
                        if (selfSkill > 2.0) { 
                            this.world.globalSkillKnowledge[skill] = clamp((this.world.globalSkillKnowledge[skill] || 0.0) + simSettings.GLOBAL_KNOWLEDGE_LEARN_RATE, 0, maxSkill);
                        }
                    } else if (partnerSkill > selfSkill) {
                        this.skills[skill] = clamp(selfSkill + learningRate, 0, maxSkill);
                        // SYNCHRONIZED: Only broadcast if skill is > 2.0
                        if (partnerSkill > 2.0) {
                            this.world.globalSkillKnowledge[skill] = clamp((this.world.globalSkillKnowledge[skill] || 0.0) + simSettings.GLOBAL_KNOWLEDGE_LEARN_RATE, 0, maxSkill);
                        }
                    }
                }

                if (this.memory.library && !partner.memory.library) {
                    partner.memory.library = this.memory.library;
                } else if (partner.memory.library && !this.memory.library) {
                    this.memory.library = partner.memory.library;
                }
            }

            broadcastSkillToLibrary() {
                if (!this.skills) return;
                
                let highestSkillName = null;
                let highestSkillValue = 0;
                
                for (const skillName of SKILL_LIST) {
                    const value = this.skills[skillName];
                    if (value > highestSkillValue) {
                        highestSkillValue = value;
                        highestSkillName = skillName;
                    }
                }

                if (highestSkillName && highestSkillValue > 1.0) {
                    const currentGlobal = this.world.globalSkillKnowledge[highestSkillName] || 0.0;
                    if (highestSkillValue > currentGlobal) {
                         // SYNCHRONIZED: Use a different, higher value for fire broadcast to match Python
                         this.world.globalSkillKnowledge[highestSkillName] = clamp(currentGlobal + 0.005, 0, SKILL_MAXES[highestSkillName]);
                    }
                }
            }

            communicate(partner) {
                this.state = "COMMUNICATING";
                partner.state = "COMMUNICATING";
                
                const selfPersonality = this.getPersonality();
                const partnerPersonality = partner.getPersonality();
                
                // SYNCHRONIZED: Personality Conflict Check
                let conflictDetected = false;
                const selfConflicts = PERSONALITY_CONFLICTS[selfPersonality] || [];
                const partnerConflicts = PERSONALITY_CONFLICTS[partnerPersonality] || [];

                if (selfConflicts.includes(partnerPersonality)) {
                    conflictDetected = true;
                } else if (partnerConflicts.includes(selfPersonality)) {
                    conflictDetected = true;
                }
                    
                if (conflictDetected) {
                    let conflictChance = this.genes.aggression * 0.8;
                    if (selfPersonality === PERSONALITY_AGGRESSIVE_COOPERATOR) {
                         conflictChance = this.genes.aggression * 1.5;
                    }
                    
                    if (Math.random() < conflictChance) {
                        this.attack(partner, 'COMBAT_CONFLICT');
                        return;
                    }
                }
                // END SYNCHRONIZED: Personality Conflict Check

                this.energy -= 1.0; 
                partner.energy -= 1.0;

                this.skills.social = clamp(this.skills.social + simSettings.SKILL_GAIN_SOCIAL_CHAT, 0, SKILL_MAXES.social); 
                partner.skills.social = clamp(partner.skills.social + simSettings.SKILL_GAIN_SOCIAL_CHAT, 0, SKILL_MAXES.social); 
                
                // Use developer settings for social gain
                const socialGain = simSettings.SOCIAL_GAIN_BASE + (this.skills.social * simSettings.SKILL_SOCIAL_GAIN_BONUS);
                const partnerSocialGain = simSettings.SOCIAL_GAIN_PARTNER_BASE + (partner.skills.social * (simSettings.SKILL_SOCIAL_GAIN_BONUS / 2.0)); 
                
                this.social = clamp(this.social + socialGain, 0, 100);
                partner.social = clamp(partner.social + partnerSocialGain, 0, 100);
                
                this.social_buff_timer = 20; 
                partner.social_buff_timer = 20; 
                
                let loveGain = simSettings.LOVE_GAIN_SOCIAL;
                if (this.apathy_timer > 0) {
                    loveGain /= 2;
                }
                this.love = clamp(this.love + loveGain, 0, simSettings.STARTING_LOVE);
                    
                let loveGainPartner = simSettings.LOVE_GAIN_SOCIAL;
                if (partner.apathy_timer > 0) {
                    loveGainPartner /= 2;
                }
                partner.love = clamp(partner.love + loveGainPartner, 0, simSettings.STARTING_LOVE);
                
                // --- SYNCHRONIZED: NEWS SHARING LOGIC ---
                // 1. Food Crisis News
                if (Object.keys(this.world.food).length < simSettings.CRITICAL_FOOD_COUNT) {
                    // Propagate the news to the partner's memory
                    partner.memory.global_news = partner.memory.global_news || {};
                    partner.memory.global_news.food_crisis = true;
                    // The agent who started the chat is also reminded/refreshed of the news
                    this.memory.global_news = this.memory.global_news || {};
                    this.memory.global_news.food_crisis = true;
                }

                // 2. Population Crisis News
                if (this.world.agents.length < simSettings.MIN_POPULATION_TARGET) {
                    partner.memory.global_news = partner.memory.global_news || {};
                    partner.memory.global_news.low_population = true;
                    this.memory.global_news = this.memory.global_news || {};
                    this.memory.global_news.low_population = true;
                }
                // --- END SYNCHRONIZED: NEWS SHARING LOGIC ---


                this.shareSkills(partner);
                
                // SYNCHRONIZED: Seed combination logic
                if (Object.keys(this.world.food).length < simSettings.STARTING_FOOD && this.seeds_carried >= 1 && partner.seeds_carried >= 1) {
                    const totalSeeds = this.seeds_carried + partner.seeds_carried;
                    if (totalSeeds >= 3) {
                        this.seeds_carried = 0;
                        partner.seeds_carried = 0;
                        
                        const [lx, ly] = this.world.libraryLocation;
                        let plantLocKey = arrayToKey([lx, ly]);
                        
                        // Check if library is clear for planting
                        const libraryClear = this.world.isTileClearForPlanting([lx, ly]);
                        
                        // If library is not clear, try current spot
                        const currentPosKey = arrayToKey([this.x, this.y]);
                        if (!libraryClear) {
                            plantLocKey = currentPosKey;
                            const currentClear = this.world.isTileClearForPlanting(keyToArray(currentPosKey));
                            if (!currentClear) {
                                // If nowhere is clear, give up
                                this.state = "WANDERING";
                                partner.state = "WANDERING";
                                return;
                            }
                        }
                        
                        this.world.food[plantLocKey] = true;
                        this.world.foodFreshness[plantLocKey] = simSettings.FOOD_FRESHNESS;
                        
                        this.state = "FORAGING";
                        partner.state = "FORAGING";
                        return;
                    }
                }
                
                if (this.age >= simSettings.ADULT_AGE && this.energy > this.genes['mating_drive'] && this.mate_cooldown === 0 && 
                   partner.age >= simSettings.ADULT_AGE && partner.energy > partner.genes['mating_drive'] && partner.mate_cooldown === 0) {
                    this.mate(partner);
                }
            }

            plantSeed() {
                if (this.seeds_carried > 0) {
                    this.seeds_carried--;
                    this.energy -= 10;
                    
                    const posKey = arrayToKey([this.x, this.y]);
                    this.world.growingPlants[posKey] = simSettings.GROW_TIME;
                    
                    this.skills.farming = clamp(this.skills.farming + simSettings.SKILL_GAIN_FARMING, 0, SKILL_MAXES.farming);
                    
                    const healAmount = simSettings.ENV_HEAL_PLANT_BASE * (this.skills.farming / SKILL_MAXES.farming); // Python uses skill/10.0, so this matches.
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth + healAmount, 0, simSettings.ENV_HEALTH_MAX);

                    this.state = "WANDERING";
                }
            }

            plantTree() {
                if (this.wood_seeds_carried > 0) {
                    this.wood_seeds_carried--;
                    this.energy -= 10;
                    
                    const posKey = arrayToKey([this.x, this.y]);
                    this.world.growingTrees[posKey] = simSettings.TREE_GROW_TIME;
                    
                    this.skills.farming = clamp(this.skills.farming + simSettings.SKILL_GAIN_FARMING, 0, SKILL_MAXES.farming);
                    
                    const healAmount = simSettings.ENV_HEAL_PLANT_BASE * (this.skills.farming / SKILL_MAXES.farming);
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth + healAmount, 0, simSettings.ENV_HEALTH_MAX);

                    this.state = "WANDERING";
                }
            }
            
            plantFruitSeed() {
                 if (this.fruit_seeds_carried > 0) {
                    this.fruit_seeds_carried--;
                    this.energy -= 10;
                    
                    const posKey = arrayToKey([this.x, this.y]);
                    this.world.growingFruitBushes[posKey] = simSettings.FRUIT_GROW_TIME;
                    // Assign a random type for the new bush
                    this.world.fruitTypes[posKey] = ['energy', 'social', 'speed'][Math.floor(Math.random() * 3)];
                    
                    this.skills.farming = clamp(this.skills.farming + simSettings.SKILL_GAIN_FARMING, 0, SKILL_MAXES.farming);
                    
                    const healAmount = simSettings.ENV_HEAL_PLANT_BASE * (this.skills.farming / SKILL_MAXES.farming);
                    this.world.environmentalHealth = clamp(this.world.environmentalHealth + healAmount, 0, simSettings.ENV_HEALTH_MAX);

                    this.state = "WANDERING";
                }
            }

            die(reason = 'UNKNOWN', attackerId = null) {
                
                // --- NEW: Vengeance System on Child Death (SYNCHRONIZED) ---
                if (this.age < simSettings.ADULT_AGE && this.parent_ids.size > 0 && reason.startsWith('COMBAT')) {
                    const witnesses = [];
                    for (const agent of this.world.agents) {
                        if (agent.id === this.id || this.parent_ids.has(agent.id)) {
                            continue;
                        }
                        
                        const visionRadius = Math.floor(agent.genes['vision']);
                        const dist = getDistance(agent.x, agent.y, this.x, this.y);
                        
                        if (dist <= visionRadius) {
                            witnesses.push(agent);
                        }
                    }
                    
                    if (witnesses.length > 0) {
                        const attacker = this.world.getAgentById(attackerId);
                        if (attacker) {
                            for (const witness of witnesses) {
                                witness.state = "AVENGING";
                                witness.avenging_target_id = attacker.id;
                                witness.vengeance_timer = simSettings.VENGEANCE_DURATION;
                            }
                        }
                    }
                }
                // --- END Vengeance System ---
                
                this.world.logDeath(this.world.turn, reason, this.id, null, null, attackerId); // Log death event
                
                this.world.deathCauses[reason] = (this.world.deathCauses[reason] || 0) + 1;
                
                const deathLocation = [this.x, this.y];
                const deathLocationKey = arrayToKey(deathLocation);
                
                // Drop all carried items
                for (let i = 0; i < this.wood_carried; i++) {
                    this.world.wood[deathLocationKey] = true;
                }
                
                for (let i = 0; i < this.food_carried; i++) {
                    this.world.food[deathLocationKey] = true;
                    this.world.foodFreshness[deathLocationKey] = simSettings.FOOD_FRESHNESS;
                }

                // Drop carried fruit
                for (const fruitType of this.fruit_carried) {
                    this.world.addFruit(deathLocation, fruitType);
                }

                // Auto-plant seeds
                this.world.autoPlantOnDeath(
                    deathLocation, 
                    this.seeds_carried, 
                    this.wood_seeds_carried, 
                    this.fruit_seeds_carried
                );
                
                // Remove self from parent's child list
                const dyingAgentId = this.id;
                for (const parent_id of this.parent_ids) {
                    const parent = this.world.getAgentById(parent_id);
                    if (parent && parent.children_ids.has(dyingAgentId)) {
                        parent.children_ids.delete(dyingAgentId);
                    }
                }
                
                this.world.agents = this.world.agents.filter(a => a.id !== this.id);
                
                if (this.home_location && this.world.homes[this.home_location] && this.world.homes[this.home_location].owner_id === this.id) {
                    this.world.homes[this.home_location].owner_id = null;
                }
            }
        }

        // --- WORLD CLASS (SYNCHRONIZED & DEBUGGED) ---

        class World {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.turn = 0;
                this.nextAgentId = 0;
                
                this.agents = [];
                this.food = {};
                this.wood = {};
                
                this.fruits = {};
                this.fruitTypes = {}; 
                this.growingFruitBushes = {}; 
                
                this.environmentalHealth = simSettings.ENV_HEALTH_MAX;
                
                this.generationCount = 0;
                
                // NEW: Death Log for Narrative Feedback
                this.deathLog = [];
                this.MAX_DEATH_LOG = 10; 
                
                this.deathCauses = {
                    'MAX_AGE': 0, 
                    'STARVATION_ADULT': 0, 
                    'STARVATION_CHILD': 0, 
                    'NATURAL_DEATH_OLD': 0, 
                    'STARVATION_SICKNESS': 0, // NEW: Sickness death
                    'UNKNOWN': 0,
                    'COMBAT_VENDETTA': 0,
                    'COMBAT_CONFLICT': 0,
                    'COMBAT_RETALIATION': 0,
                    'COMBAT_AGGRESSION': 0
                };
                this.homes = {};
                this.growingPlants = {};
                this.growingTrees = {};
                this.foodFreshness = {};
                this.campfires = {};

                this.globalSkillKnowledge = {
                    'foraging': 0.0, 'social': 0.0, 'building': 0.0,
                    'navigation': 0.0, 'combat': 0.0, 'farming': 0.0
                };
                this.libraryLocation = [Math.floor(this.width / 2), Math.floor(this.height / 2)];

                this.stats = {};
            }
            
            // --- NEW: Logging Function ---
            logDeath(turn, reason, agentId, parent1Id, parent2Id, attackerId) {
                let message = `Turn ${turn}: `;
                
                if (reason === 'BIRTH') {
                    message += `üë∂ Agent #${agentId} was born. (Parents #${parent1Id}, #${parent2Id})`;
                } else {
                    const attackerText = attackerId ? ` by Agent #${attackerId}` : '';
                    message += `‚ò†Ô∏è Agent #${agentId} died of ${reason.replace('_', ' ')}${attackerText}.`;
                }

                this.deathLog.unshift(message);
                if (this.deathLog.length > this.MAX_DEATH_LOG) {
                    this.deathLog.pop();
                }
            }
            
            isHardObstacle(x, y) {
                const posKey = arrayToKey([x, y]);
                
                if (posKey === arrayToKey(this.libraryLocation)) return true;
                if (this.campfires[posKey]) return true;
                
                // Other agents' homes are hard obstacles
                if (this.homes[posKey]) {
                    if (this.homes[posKey].owner_id !== null) {
                        return true;
                    }
                }

                return false;
            }

            getNextAgentId() {
                return ++this.nextAgentId;
            }

            getAgentById(agentId) {
                return this.agents.find(a => a.id === agentId);
            }

            getEmptyHome() {
                for (const pos in this.homes) {
                    if (this.homes[pos].owner_id === null) {
                        return pos;
                    }
                }
                return null;
            }

            addAgent(x = null, y = null, genes = null) {
                x = x === null ? Math.floor(Math.random() * this.width) : x;
                y = y === null ? Math.floor(Math.random() * this.height) : y;
                
                const agent = new Agent(x, y, this, genes);
                this.agents.push(agent);
                return agent;
            }
            
            addFruit([x, y], fruitType) {
                const posKey = arrayToKey([x, y]);
                // SYNCHRONIZED: Logic for adding fruit to a clear tile
                if (!this.isTileClearForPlanting([x, y], true)) {
                    const nearbyEmpty = this.getEmptyTilesNear([x, y], 1);
                    if (nearbyEmpty.length > 0) {
                        const newPosKey = arrayToKey(nearbyEmpty[0]);
                        this.fruits[newPosKey] = true;
                        this.fruitTypes[newPosKey] = fruitType;
                        return;
                    } else {
                        return;
                    }
                }
                this.fruits[posKey] = true;
                this.fruitTypes[posKey] = fruitType;
            }
            
            getNearestFruitOfType(x, y, radius, memory, targetType) {
                const results = [];
                
                // Check visible area
                for(const posKey in this.fruits) {
                    if (this.fruitTypes[posKey] === targetType) {
                        const [ix, iy] = keyToArray(posKey);
                        if (getDistance(x, y, ix, iy) <= radius) {
                             results.push([ix, iy]);
                        }
                    }
                }
                // Check memory (memory stores posKey strings)
                for (const posKey of memory) {
                    if (this.fruitTypes[posKey] === targetType) {
                        const [ix, iy] = keyToArray(posKey);
                         results.push([ix, iy]);
                    }
                }
                
                if (results.length === 0) return [];
                    
                results.sort((a, b) => 
                    getDistance(x, y, a[0], a[1]) - getDistance(x, y, b[0], b[1])
                );
                
                return results;
            }

            spawnResources() {
                const foodYieldMultiplier = this.environmentalHealth / simSettings.ENV_HEALTH_MAX;
                const foodSpawnCount = Math.floor(5 * foodYieldMultiplier);
                const woodSpawnCount = Math.floor(3 * foodYieldMultiplier);
                const fruitSpawnCount = Math.floor(2 * foodYieldMultiplier); 
                const maxFood = this.width * this.height * 0.1;
                const maxWood = this.width * this.height * 0.05;
                const maxFruit = this.width * this.height * 0.05;

                if (this.turn % simSettings.FOOD_SPAWN_RATE === 0) {
                    for (let i = 0; i < foodSpawnCount; i++) { 
                        if (Object.keys(this.food).length < maxFood) {
                            const tile = this.getRandomEmptyTile();
                            if (tile) {
                                const posKey = arrayToKey(tile);
                                this.food[posKey] = true;
                                this.foodFreshness[posKey] = simSettings.FOOD_FRESHNESS;
                            }
                        }
                    }
                }

                if (this.turn % simSettings.WOOD_SPAWN_RATE === 0) {
                    for (let i = 0; i < woodSpawnCount; i++) { 
                        if (Object.keys(this.wood).length < maxWood) {
                            const tile = this.getRandomEmptyTile();
                            if (tile) {
                                this.wood[arrayToKey(tile)] = true;
                            }
                        }
                    }
                }

                if (this.turn % simSettings.FRUIT_SPAWN_RATE === 0) {
                     for (let i = 0; i < fruitSpawnCount; i++) {
                         if (Object.keys(this.fruits).length < maxFruit) {
                             const tile = this.getRandomEmptyTile();
                             if (tile) {
                                 this.addFruit(tile, ['energy', 'social', 'speed'][Math.floor(Math.random() * 3)]);
                             }
                         }
                     }
                }
            }

            updateWorldObjects() {
                this.environmentalHealth = clamp(this.environmentalHealth + simSettings.ENV_PASSIVE_RECOVERY_RATE, 0, simSettings.ENV_HEALTH_MAX);
                const libraryPosKey = arrayToKey(this.libraryLocation);
                const isTileClear = (pos) => this.isTileClearForPlanting(pos);

                // Update Growing Plants (Food)
                for (const pos in this.growingPlants) {
                    this.growingPlants[pos]--;
                    if (this.growingPlants[pos] <= 0) {
                        delete this.growingPlants[pos];
                        if (isTileClear(keyToArray(pos))) {
                            this.food[pos] = true;
                            this.foodFreshness[pos] = simSettings.FOOD_FRESHNESS;
                        }
                    }
                }
                
                // Update Growing Trees (Wood)
                for (const pos in this.growingTrees) {
                    this.growingTrees[pos]--;
                    if (this.growingTrees[pos] <= 0) {
                        delete this.growingTrees[pos];
                        if (isTileClear(keyToArray(pos))) {
                            this.wood[pos] = true;
                        }
                    }
                }

                // Update Growing Fruit Bushes
                for (const pos in this.growingFruitBushes) {
                    this.growingFruitBushes[pos]--;
                    if (this.growingFruitBushes[pos] <= 0) {
                        delete this.growingFruitBushes[pos];
                        const fruitType = this.fruitTypes[pos];
                        if (fruitType && isTileClear(keyToArray(pos))) {
                             this.fruits[pos] = true;
                        } else {
                            // If the tile is no longer clear (e.g., home was built), discard the type info too
                            delete this.fruitTypes[pos];
                        }
                    }
                }
                
                // Update Food Spoilage
                for (const posKey of Object.keys(this.foodFreshness)) {
                    this.foodFreshness[posKey]--;
                    if (this.foodFreshness[posKey] <= 0) {
                        delete this.foodFreshness[posKey];
                        delete this.food[posKey];         
                    }
                }
                
                // Update Campfires (and Pollution)
                for (const pos in this.campfires) {
                    this.campfires[pos]--;
                    if (this.campfires[pos] <= 0) {
                        delete this.campfires[pos];
                    } else {
                         this.environmentalHealth = clamp(this.environmentalHealth - simSettings.ENV_DECAY_CAMPFIRE_POLLUTION, 0, simSettings.ENV_HEALTH_MAX);
                    }
                }
                
                // Update Home Decay
                if (this.turn % simSettings.HOME_DECAY_RATE === 0) {
                    for (const pos in this.homes) {
                        this.homes[pos].durability--;
                        if (this.homes[pos].durability <= 0) {
                            
                            // Return wood to the tile
                            for (let i = 0; i < simSettings.HOME_WOOD_RETURN_ON_DECAY; i++) { // Uses developer setting
                                this.wood[pos] = true;
                            }
                                
                            const ownerId = this.homes[pos].owner_id;
                            if (ownerId !== null) {
                                const agent = this.getAgentById(ownerId);
                                if (agent) {
                                    agent.home_location = null;
                                }
                            }
                            delete this.homes[pos];
                        }
                    }
                }
            }

            updateEnvironmentFeedback() {
                // 1. Check for Sickness
                if (this.environmentalHealth < simSettings.ENV_SICKNESS_THRESHOLD) {
                    for (const agent of this.agents) {
                        if (agent.sickness_timer === 0 && Math.random() < simSettings.ENV_SICKNESS_CHANCE) {
                            agent.sickness_timer = simSettings.ENV_SICKNESS_DURATION;
                        }
                    }
                }
                    
                // 2. Check for Overpopulation Density Decay
                for (let i = 0; i < 5; i++) { 
                    if (this.agents.length === 0) break;
                    const agent = this.agents[Math.floor(Math.random() * this.agents.length)];
                    
                    let nearbyCount = 0;
                    for (const otherAgent of this.agents) {
                        if (agent.id === otherAgent.id) continue;
                        if (getDistance(agent.x, agent.y, otherAgent.x, otherAgent.y) < simSettings.ENV_OVERPOPULATION_RADIUS) {
                            nearbyCount++;
                        }
                    }
                        
                    if (nearbyCount > simSettings.ENV_OVERPOPULATION_THRESHOLD) {
                        this.environmentalHealth = clamp(this.environmentalHealth - simSettings.ENV_OVERPOPULATION_DECAY, 0, simSettings.ENV_HEALTH_MAX);
                        break; 
                    }
                }
            }

            isTileClearForPlanting(pos, checkAgents = false) {
                const posKey = arrayToKey(pos);
                const [x, y] = pos;
                
                if (!(x >= 0 && x < this.width && y >= 0 && y < this.height)) return false;

                if (posKey === arrayToKey(this.libraryLocation)) return false;
                if (this.homes[posKey]) return false;
                if (this.food[posKey]) return false;
                if (this.wood[posKey]) return false;
                if (this.growingPlants[posKey]) return false;
                if (this.growingTrees[posKey]) return false;
                if (this.campfires[posKey]) return false;
                if (this.fruits[posKey]) return false;
                if (this.growingFruitBushes[posKey]) return false;
                
                if (checkAgents && this.agents.some(agent => agent.x === x && agent.y === y)) return false;

                return true;
            }

            getEmptyTilesNear(originPos, maxCount) {
                const emptyTiles = [];
                const [ox, oy] = originPos;
                let radius = 1;
                
                if (this.isTileClearForPlanting(originPos)) {
                    emptyTiles.push(originPos);
                    if (emptyTiles.length === maxCount) return emptyTiles;
                }

                while (emptyTiles.length < maxCount && radius < 10) { 
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dy = -radius; dy <= radius; dy++) {
                             const checkPos = [ox + dx, oy + dy];
                             if (this.isTileClearForPlanting(checkPos)) {
                                 const posKey = arrayToKey(checkPos);
                                 if (!emptyTiles.some(tile => arrayToKey(tile) === posKey)) {
                                     emptyTiles.push(checkPos);
                                 }
                                 if (emptyTiles.length === maxCount) return emptyTiles;
                             }
                        }
                    }
                    radius++;
                }
                return emptyTiles;
            }

            autoPlantOnDeath(originPos, foodSeeds, woodSeeds, fruitSeeds) {
                const totalSeeds = foodSeeds + woodSeeds + fruitSeeds;
                if (totalSeeds === 0) return;
                
                const emptyTiles = this.getEmptyTilesNear(originPos, totalSeeds);
                
                let tileIndex = 0;
                
                for (let i = 0; i < foodSeeds; i++) {
                    if (tileIndex < emptyTiles.length) {
                        const posKey = arrayToKey(emptyTiles[tileIndex++]);
                        this.growingPlants[posKey] = simSettings.GROW_TIME;
                    } else break;
                }
                for (let i = 0; i < woodSeeds; i++) {
                    if (tileIndex < emptyTiles.length) {
                        const posKey = arrayToKey(emptyTiles[tileIndex++]);
                        this.growingTrees[posKey] = simSettings.TREE_GROW_TIME;
                    } else break;
                }
                for (let i = 0; i < fruitSeeds; i++) {
                    if (tileIndex < emptyTiles.length) {
                        const posKey = arrayToKey(emptyTiles[tileIndex++]);
                        this.growingFruitBushes[posKey] = simSettings.FRUIT_GROW_TIME;
                        this.fruitTypes[posKey] = ['energy', 'social', 'speed'][Math.floor(Math.random() * 3)];
                    } else break;
                }
            }


            getRandomEmptyTile() {
                const attempts = 10;
                for (let i = 0; i < attempts; i++) {
                    const x = Math.floor(Math.random() * this.width);
                    const y = Math.floor(Math.random() * this.height);
                    const pos = [x, y];
                    
                    if (this.isTileClearForPlanting(pos, true)) {
                        return pos;
                    }
                }
                return null; 
            }

            update() {
// FEATURE IMPLEMENTATION: Extinction Protocol (Infinite Game)
if (this.agents.length === 0) {
    const rescueCount = simSettings.LOW_POPULATION_THRESHOLD;
    console.log(`Extinction event detected. Respawing ${rescueCount} agents.`);

    for (let i = 0; i < rescueCount; i++) {
         const newAgent = this.addAgent();
         if (newAgent) {
             newAgent.age = simSettings.ADULT_AGE;
             newAgent.energy = simSettings.STARTING_ENERGY * 1.5; 
             newAgent.social = 40; 
             
             // --- NEW: INJECT KNOWLEDGE ---
             // Force them to know the population is low immediately
             newAgent.memory.global_news.low_population = true;
             // -----------------------------

             this.logDeath(this.turn, 'EXTINCTION_EVENT_RESPAWN', newAgent.id, null, null);
         }
    }
}

                this.turn++;
                
                if (this.turn % simSettings.MAX_AGE === 0) {
                    this.generationCount++;
                }
                
                for (let i = this.agents.length - 1; i >= 0; i--) {
                    const agent = this.agents[i];
                    if (this.agents.includes(agent)) {
                        agent.update();
                    }
                }
                
                this.spawnResources();
                this.updateWorldObjects();
                this.updateEnvironmentFeedback();
                this.calculateStats();
            }

            calculateStats() {
                const adultAgents = this.agents.filter(agent => agent.age >= simSettings.ADULT_AGE);
                let agentsForStats = adultAgents.length > 0 ? adultAgents : this.agents;
                
                if (agentsForStats.length === 0) {
                    this.stats = { population: 0, homes_built: 0, active_campfires: 0 };
                    for (const gene of GENE_LIST) {
                        this.stats[`avg_${gene}`] = 0;
                    }
                    for (const skill of SKILL_LIST) {
                        this.stats[`avg_${skill}_skill`] = 0;
                    }
                    
                    let totalDeaths = 0;
                    for (const reason in this.deathCauses) {
                        if (reason !== 'TOTAL_DEATHS' && reason !== 'UNKNOWN') {
                            totalDeaths += this.deathCauses[reason];
                        }
                    }
                    this.deathCauses.TOTAL_DEATHS = totalDeaths;
                    
                    if (this.deathCauses.hasOwnProperty('UNKNOWN')) {
                        delete this.deathCauses['UNKNOWN'];
                    }
                    return;
                }
                    
                const numAgents = agentsForStats.length;
                    
                this.stats.population = this.agents.length;
                this.stats.homes_built = Object.keys(this.homes).length;
                this.stats.active_campfires = Object.keys(this.campfires).length;
                
                for (const gene of GENE_LIST) {
                    const avgKey = `avg_${gene}`;
                    const total = agentsForStats.reduce((sum, agent) => sum + agent.genes[gene], 0);
                    this.stats[avgKey] = total / numAgents;
                }
                    
                for (const skill of SKILL_LIST) {
                    const avgKey = `avg_${skill}_skill`;
                    const total = agentsForStats.reduce((sum, agent) => sum + agent.skills[skill], 0);
                    this.stats[avgKey] = total / numAgents;
                }
                    
                let totalDeaths = 0;
                for (const reason in this.deathCauses) {
                    if (reason !== 'TOTAL_DEATHS' && reason !== 'UNKNOWN') {
                        totalDeaths += this.deathCauses[reason];
                    }
                }
                this.deathCauses.TOTAL_DEATHS = totalDeaths;
                
                if (this.deathCauses.hasOwnProperty('UNKNOWN')) {
                    delete this.deathCauses['UNKNOWN'];
                }
            }

            getNearest(x, y, radius, itemMap) {
                let nearestItemKey = null;
                let minDist = Infinity;
                
                const items = itemMap instanceof Array ? itemMap : Object.keys(itemMap);
                
                for (const posKey of items) {
                    const [ix, iy] = keyToArray(posKey);
                    const dist = getDistance(x, y, ix, iy);
                    if (dist <= radius && dist < minDist) {
                        minDist = dist;
                        nearestItemKey = posKey;
                    }
                }
                return nearestItemKey;
            }

            getNearestInSet(x, y, radius, itemMap) {
                const foundItemKeys = [];
                
                for (const posKey in itemMap) {
                    const [ix, iy] = keyToArray(posKey);
                    const dist = getDistance(x, y, ix, iy);
                    if (dist <= radius) {
                        foundItemKeys.push(posKey);
                    }
                }
                return foundItemKeys;
            }

            getNearestAgents(x, y, radius, excludeSelf = null) {
                const nearbyAgents = [];
                for (const agent of this.agents) {
                    if (agent === excludeSelf) continue;
                    const dist = getDistance(x, y, agent.x, agent.y);
                    if (dist <= radius) {
                        nearbyAgents.push(agent);
                    }
                }
                return nearbyAgents;
            }
        }


        // --- RENDERING AND MAIN LOOP ---

class Renderer {
            constructor(world, canvasId) {
                this.world = world;
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.selectedAgentId = null; 

                this.cellSize = 20;
                
                this.resizeCanvas();
                let resizeTimer;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimer);
                    resizeTimer = setTimeout(() => this.resizeCanvas(), 100);
                });
                
                this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));

                this.font = `${this.cellSize * 0.75}px Consolas, monospace`;
            }

            resizeCanvas() {
                const containerWidth = this.canvas.parentElement.clientWidth;
                if (containerWidth === 0) {
                    setTimeout(() => this.resizeCanvas(), 100);
                    return;
                }
                let newCellSize = Math.floor(containerWidth / this.world.width);
                this.cellSize = Math.max(newCellSize, 8); 

                this.canvas.width = this.world.width * this.cellSize;
                this.canvas.height = this.world.height * this.cellSize;
                
                this.font = `${this.cellSize * 0.75}px Consolas, monospace`;
                this.render(); 
            }
            
            handleCanvasClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;
                
                const gridX = Math.floor(clickX / this.cellSize);
                const gridY = Math.floor(clickY / this.cellSize);
                const posKey = arrayToKey([gridX, gridY]);
                
                // 1. Check for direct agent click
                let agent = this.world.agents.find(a => a.x === gridX && a.y === gridY);
                
                // 2. FEATURE IMPLEMENTATION: Check for Home Owner click
                if (!agent && this.world.homes[posKey]) {
                    const homeData = this.world.homes[posKey];
                    if (homeData.owner_id !== null) {
                        agent = this.world.getAgentById(homeData.owner_id);
                    }
                }
                
                if (agent) {
                    this.selectedAgentId = agent.id;
                    updateAgentDetailPanel(agent);
                } else {
                    this.selectedAgentId = null;
                    document.getElementById('agentDetailPanel').classList.add('hidden');
                }
                this.render();
            }

            drawCell(x, y, char, colorKey, isDim) {
                const ctx = this.ctx;
                const size = this.cellSize;
                const px = x * size + size / 2;
                const py = y * size + size / 2;

                ctx.fillStyle = COLORS[colorKey];
                if (isDim) {
                    ctx.globalAlpha = 0.5;
                } else {
                    ctx.globalAlpha = 1.0;
                }

                ctx.fillText(char, px, py);
            }
            
            drawDimBackgroundChar(x, y) {
                const ctx = this.ctx;
                const size = this.cellSize;
                const px = x * size + size / 2;
                const py = y * size + size / 2;
                
                let colorKey = 'WHITE_NORMAL';
                
                ctx.fillStyle = COLORS[colorKey];
                ctx.globalAlpha = 0.5;
                ctx.fillText('.', px, py);
            }
            
            drawHeatmap() {
                const ctx = this.ctx;
                const health = this.world.environmentalHealth;
                const maxHealth = simSettings.ENV_HEALTH_MAX;
                const factor = health / maxHealth; 
                
                if (factor > 0.5) {
                    return;
                }

                const intensity = (0.5 - factor) * 2; 
                const alpha = 0.3 * intensity; 

                ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`; 
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            drawThoughtBubble(x, y, agent) {
                if (!simSettings.DISPLAY_EMOJI_MODE) return;
                
                const ctx = this.ctx;
                const size = this.cellSize;
                const px = x * size + size * 0.9;
                const py = y * size + size * 0.15;
                
                let emoji = EMOJI_MAP[agent.state] || '‚ùì';
                
                if (agent.sickness_timer > 0) emoji = EMOJI_MAP['SICK'];
                else if (agent.apathy_timer > 0) emoji = EMOJI_MAP['APATHY'];
                
                ctx.font = `${this.cellSize * 0.45}px sans-serif`; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = 1.0;
                
                ctx.fillText(emoji, px, py);
            }

            render() {
                const ctx = this.ctx;
                const size = this.cellSize;

                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawHeatmap(); 
                
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = this.font;

                const agentPositions = {};
                this.world.agents.forEach(agent => {
                    const posKey = arrayToKey([agent.x, agent.y]);
                    if (agent.home_location !== posKey) { 
                        agentPositions[posKey] = agent;
                    }
                });

                for(let y = 0; y < this.world.height; y++) {
                    for(let x = 0; x < this.world.width; x++) {
                        const posKey = arrayToKey([x, y]);
                        if (!agentPositions[posKey]) { 
                            this.drawDimBackgroundChar(x, y); 
                        }
                    }
                }

                const resources = [
                    { map: this.world.growingPlants, char: 'P', color: 'GREEN_NORMAL', dim: false },
                    { map: this.world.growingTrees, char: 'T', color: 'GREEN_DIM', dim: false },
                    { map: this.world.growingFruitBushes, char: 'b', color: 'MAGENTA_DIM', dim: true },
                    { map: this.world.food, char: 'F', color: 'GREEN_BRIGHT', dim: false },
                    { map: this.world.wood, char: 'W', color: 'YELLOW_BRIGHT', dim: false },
                    { map: this.world.campfires, char: 'C', color: 'RED_BRIGHT', dim: false },
                ];
                
                for(const posKey in this.world.fruits) {
                    const fruitType = this.world.fruitTypes[posKey];
                    let char = '?';
                    let colorKey = 'WHITE_BRIGHT';
                    if (fruitType === 'energy') { char = 'R'; colorKey = 'RED_NORMAL'; }
                    else if (fruitType === 'social') { char = 'P'; colorKey = 'MAGENTA_BRIGHT'; }
                    else if (fruitType === 'speed') { char = 'B'; colorKey = 'BLUE_NORMAL'; }
                    
                    if (!agentPositions[posKey]) {
                        const [x, y] = keyToArray(posKey);
                        this.drawCell(x, y, char, colorKey, false);
                    }
                }

                resources.forEach(res => {
                    for (const posKey in res.map) {
                        if (!agentPositions[posKey]) { 
                            const [x, y] = keyToArray(posKey);
                            this.drawCell(x, y, res.char, res.color, res.dim);
                        }
                    }
                });

                for (const posKey in this.world.homes) {
                    const [x, y] = keyToArray(posKey);
                    const durability = this.world.homes[posKey].durability;
                    const char = durability < 2 ? 'h' : 'H';
                    const colorKey = durability < 2 ? 'BLUE_NORMAL' : 'BLUE_BRIGHT'; // Determine color
                    
                    this.drawCell(x, y, char, colorKey, false);
                    
                    // FEATURE IMPLEMENTATION: Highlight selected agent's home with HOUSE COLOR
                    if (this.world.homes[posKey].owner_id === this.selectedAgentId) {
                        ctx.strokeStyle = COLORS[colorKey]; // Use the dynamic colorKey determined above
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1.0;
                        ctx.strokeRect(x * size + 1, y * size + 1, size - 2, size - 2);
                    }
                }
                
                const [lx, ly] = this.world.libraryLocation;
                this.drawCell(lx, ly, 'L', 'LIBRARY', false);

                const agentsAtHome = [];
                
                this.world.agents.forEach(agent => {
                    const isAtHome = agent.home_location !== null && agent.home_location === arrayToKey([agent.x, agent.y]);
                    if (isAtHome) {
                        agentsAtHome.push(agent);
                        return; 
                    }
                    
                    let charMapEntry = CHAR_MAP[agent.state] || CHAR_MAP['WANDERING'];
                    let char = charMapEntry.char;
                    let colorKey = charMapEntry.color;
                    let isDim = charMapEntry.dim;

                    if (agent.sickness_timer > 0) { colorKey = 'GREEN_NORMAL'; isDim = false; }
                    if (agent.apathy_timer > 0) { colorKey = 'MAGENTA_DIM'; char = 's'; isDim = true; }
                    if (agent.speed_buff_timer > 0) { colorKey = 'BLUE_BRIGHT'; isDim = false; }
                    
                    this.drawCell(agent.x, agent.y, char, colorKey, isDim);
                    this.drawThoughtBubble(agent.x, agent.y, agent);
                    
                    if (agent.id === this.selectedAgentId) {
                        ctx.strokeStyle = '#fcd34d'; // Keep Yellow for Agent Highlight
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1.0;
                        ctx.strokeRect(agent.x * size + 1, agent.y * size + 1, size - 2, size - 2);
                    }
                });

                agentsAtHome.forEach(agent => {
                    const size = this.cellSize;
                    const px = agent.x * size + size / 2 + size * 0.15;
                    const py = agent.y * size + size / 2 + size * 0.15;
                    
                    let charMapEntry = CHAR_MAP[agent.state] || CHAR_MAP['WANDERING'];
                    let char = charMapEntry.char;
                    let colorKey = charMapEntry.color;
                    let isDim = charMapEntry.dim;

                    if (agent.sickness_timer > 0) { colorKey = 'GREEN_NORMAL'; isDim = false; }
                    if (agent.apathy_timer > 0) { colorKey = 'MAGENTA_DIM'; char = 's'; isDim = true; }
                    if (agent.speed_buff_timer > 0) { colorKey = 'BLUE_BRIGHT'; isDim = false; }

                    ctx.font = `${this.cellSize * 0.4}px Consolas, monospace`; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = COLORS[colorKey];
                    ctx.globalAlpha = isDim ? 0.5 : 1.0;

                    ctx.fillText(char, px, py);
                    
                    if (simSettings.DISPLAY_EMOJI_MODE) {
                        const emoji = EMOJI_MAP[agent.state] || '‚ùì';
                        ctx.font = `${this.cellSize * 0.4}px sans-serif`; 
                        ctx.globalAlpha = 1.0;
                        ctx.fillText(emoji, agent.x * size + size * 0.85, agent.y * size + size * 0.85);
                    }
                    
                    if (agent.id === this.selectedAgentId) {
                        ctx.strokeStyle = '#fcd34d'; 
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 1.0;
                        ctx.strokeRect(agent.x * size + 1, agent.y * size + 1, size - 2, size - 2);
                    }
                    
                    ctx.font = this.font;
                });

                ctx.globalAlpha = 1.0;
            }
        }

        // --- STATS RENDERING (MODIFIED: Uses new stats) ---
        function updateAgentDetailPanel(agent) {
            const panel = document.getElementById('agentDetailPanel');
            if (agent) {
                document.getElementById('detailAgentId').textContent = agent.id;
                document.getElementById('detailAge').textContent = agent.age;
                document.getElementById('detailState').textContent = agent.state;
                document.getElementById('detailEnergy').textContent = agent.energy.toFixed(1);
                document.getElementById('detailSocial').textContent = agent.social.toFixed(1);
                document.getElementById('detailLove').textContent = agent.love.toFixed(1);
                
                const statusDiv = document.getElementById('detailStatus');
                let statusHTML = `
                    <p>Children: ${agent.children_ids.size} | Seeds: ${agent.seeds_carried} | Wood: ${agent.wood_carried}</p>
                    <p>Home: ${agent.home_location ? 'Set' : 'None'} | Fire: ${agent.campfire_location ? 'Set' : 'None'}</p>
                    <p>Status: ${agent.getStatusIcons()}</p>
                `;
                statusDiv.innerHTML = statusHTML;

                const geneDiv = document.getElementById('detailGenes');
                let geneHTML = '';
                for (const gene of GENE_LIST) {
                    geneHTML += `<p><span class="text-cyan-300">${gene}</span>: ${agent.genes[gene].toFixed(2)}</p>`;
                }
                geneDiv.innerHTML = geneHTML;

                const skillDiv = document.getElementById('detailSkills');
                let skillHTML = '';
                for (const skill of SKILL_LIST) {
                    skillHTML += `<p><span class="text-green-300">${skill}</span>: ${agent.skills[skill].toFixed(2)}</p>`;
                }
                skillDiv.innerHTML = skillHTML;


                panel.classList.remove('hidden');
            } else {
                panel.classList.add('hidden');
            }
        }
        
function updateStatsDisplay(world) {
            document.getElementById('turnCounter').textContent = world.turn;
            document.getElementById('generationCounter').textContent = world.generationCount;
            document.getElementById('statPopulation').textContent = world.stats.population || 0;
            document.getElementById('statHomes').textContent = world.stats.homes_built || 0;
            document.getElementById('statFires').textContent = world.stats.active_campfires || 0;

            // Environment Health (Preserving your previous "No Green" text preference)
            const envHealth = world.environmentalHealth;
            let envColor = 'text-white'; 
            if (envHealth <= 70) envColor = 'text-yellow-400';
            if (envHealth <= 30) envColor = 'text-red-400';
            
            document.getElementById('statEnvHealth').innerHTML = `<span class="${envColor}">${envHealth.toFixed(1)}%</span>`;

            const geneStatsDiv = document.getElementById('geneStats');
            geneStatsDiv.innerHTML = '';
            
            // UPDATED: Loop without background highlights
            for (const gene of GENE_LIST) {
                const avg = world.stats[`avg_${gene}`] || 0;
                let color = 'text-cyan-400';
                if (gene === 'aggression') color = 'text-red-400';
                if (gene === 'metabolism') color = 'text-red-400'; 
                if (gene === 'builder') color = 'text-blue-400';
                if (gene === 'mating_drive') color = 'text-pink-400';
                if (gene === 'sociability') color = 'text-white';
                if (gene === 'farming') color = 'text-green-400';
                if (gene === 'personality') color = 'text-purple-400'; 
                if (gene === 'navigation') color = 'text-cyan-400'; 
                
                // Logic for 'highlight' variable removed here

                const displayValue = gene === 'mating_drive' ? avg.toFixed(0) : avg.toFixed(2);
                
                // Class attribute removed from <p> tag
                geneStatsDiv.innerHTML += `<p><span class="${color}">${gene.padEnd(12, ' ')}</span>: ${displayValue}</p>`;
            }

            const skillStatsDiv = document.getElementById('skillStats');
            skillStatsDiv.innerHTML = '';
            for (const skill of SKILL_LIST) {
                const avg = world.stats[`avg_${skill}_skill`] || 0;
                let color = 'text-green-400';
                if (skill === 'social') color = 'text-white';
                if (skill === 'building') color = 'text-blue-400';
                if (skill === 'navigation') color = 'text-cyan-400';
                if (skill === 'combat') color = 'text-red-400';
                
                skillStatsDiv.innerHTML += `<p><span class="${color}">${skill.padEnd(12, ' ')}</span>: ${avg.toFixed(2)}</p>`;
            }

            const knowledgeStatsDiv = document.getElementById('knowledgeStats');
            knowledgeStatsDiv.innerHTML = '';
            for (const skill in world.globalSkillKnowledge) {
                const val = world.globalSkillKnowledge[skill];
                knowledgeStatsDiv.innerHTML += `<p><span class="text-yellow-400">${skill.padEnd(12, ' ')}</span>: ${val.toFixed(2)}</p>`;
            }

            const deathStatsDiv = document.getElementById('deathStats');
            deathStatsDiv.innerHTML = '';
            const totalDeaths = world.deathCauses.TOTAL_DEATHS || 0;
            if (totalDeaths > 0) {
                const filteredDeaths = Object.entries(world.deathCauses).filter(([reason, count]) => 
                    reason !== 'UNKNOWN' && reason !== 'TOTAL_DEATHS' && count > 0
                );
                
                filteredDeaths.sort((a, b) => b[1] - a[1]);

                for (const [reason, count] of filteredDeaths) {
                    const percent = (count / totalDeaths) * 100;
                    deathStatsDiv.innerHTML += `<p><span class="text-red-500">${reason.padEnd(20, ' ')}</span>: ${count} (${percent.toFixed(1)}%)</p>`;
                }
            } else {
                deathStatsDiv.innerHTML = '<p>No deaths recorded yet.</p>';
            }
            
            const deathLogDiv = document.getElementById('deathLogDisplay');
            deathLogDiv.innerHTML = world.deathLog.map(log => `<p>${log}</p>`).join('');
            
            if (renderer.selectedAgentId) {
                const selectedAgent = world.getAgentById(renderer.selectedAgentId);
                if (selectedAgent) {
                     updateAgentDetailPanel(selectedAgent);
                } else {
                     renderer.selectedAgentId = null;
                     document.getElementById('agentDetailPanel').classList.add('hidden');
                }
            }
        }

// --- LEGEND (UPDATED: Removed Map Entry) ---
        function populateLegend() {
            const legendDiv = document.getElementById('legend');
            
            const getDisplayColor = (colorKey) => {
                return COLORS[colorKey] || BASE_COLORS[colorKey];
            };

            const groups = [
                {
                    title: 'Status & Interaction',
                    items: [
                        { char: 'A', color: 'CYAN_BRIGHT', desc: 'Wander (Default)' },
                        { char: 'f', color: 'CYAN_NORMAL', desc: 'Forage/Eat (Food/Fruit)' }, 
                        { char: 's', color: 'MAGENTA_DIM', desc: 'Sad/Crisis/Apathy' },
                        { char: 'o', color: 'MAGENTA_BRIGHT', desc: 'Happy/Linger' },
                        { char: 'T', color: 'WHITE_BRIGHT', desc: 'Communicate/Share Knowledge' },
                        { char: 'm/M', color: 'MAGENTA_BRIGHT', desc: 'Mate/Seek Mate' },
                        { char: 'X/r/V', color: 'RED_BRIGHT', desc: 'Attack/Retaliate/Avenge' },
                        { char: 'g/B', color: 'WHITE_BRIGHT', desc: 'Share Resources/Wander to Build' },
                        { char: 'Any', color: 'GREEN_NORMAL', desc: 'Agent is Sick (ü§¢)' },
                        { char: 'Any', color: 'BLUE_BRIGHT', desc: 'Agent has Speed Buff (üí®)' },
                        { char: 'Any', color: 'MAGENTA_DIM', desc: 'Agent is Apathetic (üò¥)' },
                    ]
                },
                {
                    title: 'Building & Farming',
                    items: [
                        { char: 'w/E', color: 'YELLOW_NORMAL', desc: 'Get Wood/Repair Home' },
                        { char: 'b/k', color: 'YELLOW_BRIGHT', desc: 'Build/Claim Home' },
                        { char: 'c/R', color: 'RED_NORMAL', desc: 'Build/Refuel Campfire' },
                        { char: 'p/G', color: 'GREEN_NORMAL', desc: 'Plant Seed/Go Home to Plant' }, 
                        { char: 'F/P', color: 'GREEN_BRIGHT', desc: 'Food/Growing Food' },
                        { char: 'W/T', color: 'YELLOW_BRIGHT', desc: 'Wood/Growing Tree' },
                    ]
                },
                {
                    title: 'Resources & Structures',
                    items: [
                        { char: 'R/P/B', color: 'RED_NORMAL', desc: 'Energy/Social/Speed Fruit' }, 
                        { char: 'b', color: 'MAGENTA_DIM', desc: 'Growing Fruit Bush' }, 
                        { char: 'H/h', color: 'BLUE_BRIGHT', desc: 'Home (Healthy/Damaged)' },
                        { char: 'C', color: 'RED_BRIGHT', desc: 'Active Campfire' },
                        { char: 'L', color: 'LIBRARY', desc: 'Library Location (Knowledge)' },
                    ]
                }
            ];
            
            let html = '';

            groups.forEach(group => {
                html += `<div class="w-full mt-2 mb-1 border-t border-gray-700 pt-2"><h3 class="font-semibold text-sm text-cyan-300">${group.title}</h3></div>`;
                group.items.forEach(item => {
                    html += `<p class="flex items-center min-w-[200px] lg:min-w-[250px]"><span style="color: ${getDisplayColor(item.color)}; font-weight: bold; width: 40px;">${item.char}</span> ${item.desc}</p>`;
                });
            });

            legendDiv.innerHTML = html;
        }

        // --- Settings Management Functions ---

function loadSettings() {
            try {
                const storedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);
                if (storedSettings) {
                    const parsedSettings = JSON.parse(storedSettings);
                    
                    // DATA SANITIZATION FIX:
                    // Loop through the loaded settings. If the *default* setting is a number,
                    // force the loaded setting to be a Number(). This fixes the "10010" bug
                    // if you have "bad" string data currently saved in your browser.
                    for (const key in parsedSettings) {
                        if (defaultSimSettings.hasOwnProperty(key)) {
                            const defaultType = typeof defaultSimSettings[key];
                            
                            if (defaultType === 'number') {
                                parsedSettings[key] = Number(parsedSettings[key]);
                            } else if (defaultType === 'boolean') {
                                // Ensure string "true"/"false" becomes actual boolean
                                if (typeof parsedSettings[key] === 'string') {
                                    parsedSettings[key] = parsedSettings[key] === 'true';
                                }
                            }
                        }
                    }

                    // Merge, prioritizing stored over defaults
                    return { ...defaultSimSettings, ...parsedSettings };
                }
            } catch (e) {
                console.error("Failed to load settings from localStorage", e);
            }
            return { ...defaultSimSettings };
        }

        function getSettingsFromForm() {
            const newSettings = {};
            
            // ITERATE OVER DEFAULTS INSTEAD OF DOM ELEMENTS
            // This ensures we strictly respect the data type (Number vs String vs Boolean)
            // of the original setting, regardless of what the HTML input thinks it is.
            for (const key in defaultSimSettings) {
                const input = document.getElementById(key);
                
                // If the input exists in the HTML form
                if (input) {
                    const defaultVal = defaultSimSettings[key];
                    const defaultType = typeof defaultVal;

                    if (defaultType === 'boolean') {
                        newSettings[key] = input.checked;
                    } else if (defaultType === 'number') {
                        // Force conversion to Float
                        const val = parseFloat(input.value);
                        // Safety check: if user cleared box (NaN), use default
                        newSettings[key] = isNaN(val) ? defaultVal : val;
                    } else {
                        // It's a string (like the dropdown menus)
                        newSettings[key] = input.value;
                    }
                } else {
                    // If setting exists in defaults but has no HTML input, keep default
                    newSettings[key] = defaultSimSettings[key];
                }
            }
            return newSettings;
        }

        function saveSettings(settings) {
            try {
                // Only save the non-default settings to keep storage clean, OR all settings
                localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
            } catch (e) {
                console.error("Failed to save settings to localStorage", e);
            }
        }
        
        function clearSettings() {
            try {
                localStorage.removeItem(SETTINGS_STORAGE_KEY);
            } catch (e) {
                console.error("Failed to clear settings from localStorage", e);
            }
        }

        function populateSettingsForm(settings) {
            for (const key in settings) {
                const input = document.getElementById(key);
                if (input) {
                    if (input.type === 'checkbox') {
                         input.checked = settings[key] === true || settings[key] === 1; // Handle 0/1 from form submission
                    } else {
                         input.value = settings[key];
                    }
                }
            }
            // Ensure all number fields have a value (even if it's the hardcoded default)
            for (const key in defaultSimSettings) {
                 const input = document.getElementById(key);
                 if (input && input.type === 'number' && input.value === "") { 
                     input.value = defaultSimSettings[key];
                 }
            }
            
            // Apply Developer Mode visibility instantly upon populating
            const developerSettings = document.getElementById('developerSettings');
            if (settings.DEVELOPER_MODE_TOGGLE) {
                developerSettings.classList.remove('hidden');
                document.getElementById('DEVELOPER_MODE_TOGGLE').checked = true;
            } else {
                developerSettings.classList.add('hidden');
                document.getElementById('DEVELOPER_MODE_TOGGLE').checked = false;
            }
        }
        
function getSettingsFromForm() {
    const newSettings = {};
    
    // Loop through every setting in your defaults
    for (const key in defaultSimSettings) {
        const input = document.getElementById(key);
        
        // If the input doesn't exist in the HTML, skip it
        if (!input) continue;
        
        const defaultValue = defaultSimSettings[key];
        const defaultType = typeof defaultValue;

        // 1. Handle Checkboxes (Boolean)
        if (input.type === 'checkbox') {
            newSettings[key] = input.checked;
        } 
        // 2. Handle Numbers (Integers & Decimals)
        // We look at the default value to know if this SHOULD be a number
        else if (defaultType === 'number') {
            const val = parseFloat(input.value);
            // If user typed nonsense, use the default. Otherwise use the number.
            newSettings[key] = isNaN(val) ? defaultValue : val;
        } 
        // 3. Handle Strings (Dropdowns/Selects)
        else {
            newSettings[key] = input.value;
        }
    }
    
    return { ...defaultSimSettings, ...newSettings };
}
        
        function setupModalControls() {
            const modal = document.getElementById('settingsModal');
            const openBtn = document.getElementById('openSettingsBtn');
            const closeBtn = document.getElementById('closeSettingsBtn');
            const saveBtn = document.getElementById('saveSettingsBtn');
            const resetBtn = document.getElementById('resetSettingsBtn');
            const devToggle = document.getElementById('DEVELOPER_MODE_TOGGLE');
            const developerSettings = document.getElementById('developerSettings');
            
            // Toggle visibility of developer fields
            devToggle.onchange = (e) => {
                if (e.target.checked) {
                    developerSettings.classList.remove('hidden');
                } else {
                    developerSettings.classList.add('hidden');
                }
            };

            openBtn.onclick = () => {
                populateSettingsForm(simSettings);
                modal.classList.remove('hidden');
            }
            closeBtn.onclick = () => modal.classList.add('hidden');
            
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                }
            };
            
// Inside setupModalControls function...

resetBtn.onclick = () => {
    if (window.confirm('Are you sure you want to reset all settings to their defaults?')) {
        // 1. Delete the saved data
        clearSettings();
        
        // 2. Force the HTML inputs to clear
        document.getElementById('settingsForm').reset();
        
        // 3. Hide modal and reload to apply defaults
        modal.classList.add('hidden');
        location.reload();
    }
};
            
            saveBtn.onclick = () => {
                simSettings = getSettingsFromForm();
                saveSettings(simSettings);
                modal.classList.add('hidden');
                location.reload(); 
            };
            
            document.getElementById('closeDetailBtn').onclick = () => {
                 renderer.selectedAgentId = null;
                 document.getElementById('agentDetailPanel').classList.add('hidden');
                 renderer.render();
            }
        }
        
        function initializeSkillMaxes() {
            SKILL_MAXES = {
                'foraging': simSettings.SKILL_FORAGE_MAX,
                'social': simSettings.SKILL_SOCIAL_MAX,
                'building': simSettings.SKILL_BUILD_MAX,
                'navigation': simSettings.SKILL_NAV_MAX,
                'combat': simSettings.SKILL_COMBAT_MAX,
                'farming': simSettings.SKILL_FARM_MAX,
            };
            
            for (const skill in SKILL_MAXES) {
                if (!world.globalSkillKnowledge.hasOwnProperty(skill)) {
                     world.globalSkillKnowledge[skill] = 0.0;
                }
            }
        }
        
        // --- NEW: Display Settings Handler ---
        function applyDisplaySettings(settings) {
            const body = document.body;
            const isLightMode = settings.DISPLAY_WORLD_LIGHT_MODE;
            
            if (isLightMode) {
                body.classList.add('world-light-mode');
                COLORS = INVERTED_COLORS;
            } else {
                body.classList.remove('world-light-mode');
                COLORS = BASE_COLORS;
            }
            
            // Re-render legend to show correct colors
            populateLegend();
            
            // Re-render canvas if the renderer exists
            if (renderer) {
                renderer.render();
            }
        }
        // --- END NEW: Display Settings Handler ---

        // --- NEW: Game Loop and Speed Controls ---
        let isPaused = false;
        let currentSpeed = 150;

        function setSpeed(ms) {
            currentSpeed = ms;
            if (interval) clearInterval(interval);
            interval = setInterval(gameLoop, currentSpeed);
            document.getElementById('currentSpeedDisplay').textContent = `Speed: ${currentSpeed}ms`;
        }

        function setupGameControls() {
            const pauseBtn = document.getElementById('pauseBtn');
            const speedNormalBtn = document.getElementById('speedNormalBtn');
            const speedFastBtn = document.getElementById('speedFastBtn');
            const dropFoodBtn = document.getElementById('interventionDropFood');
            const crisisBtn = document.getElementById('interventionCrisis');
            
            pauseBtn.onclick = () => {
                isPaused = !isPaused;
                if (isPaused) {
                    clearInterval(interval);
                    pauseBtn.textContent = '‚ñ∂Ô∏è Resume';
                    pauseBtn.classList.replace('bg-yellow-500', 'bg-green-500');
                    pauseBtn.classList.replace('hover:bg-yellow-600', 'hover:bg-green-600');
                } else {
                    interval = setInterval(gameLoop, currentSpeed);
                    pauseBtn.textContent = '‚è∏Ô∏è Pause';
                    pauseBtn.classList.replace('bg-green-500', 'bg-yellow-500');
                    pauseBtn.classList.replace('hover:bg-green-600', 'hover:bg-yellow-600');
                }
            };

            speedNormalBtn.onclick = () => setSpeed(simSettings.SIM_SPEED);
            speedFastBtn.onclick = () => setSpeed(simSettings.SIM_SPEED / 5);
            
            dropFoodBtn.onclick = () => {
                for (let i = 0; i < 50; i++) {
                    const tile = world.getRandomEmptyTile();
                    if (tile) {
                        const posKey = arrayToKey(tile);
                        world.food[posKey] = true;
                        world.foodFreshness[posKey] = simSettings.FOOD_FRESHNESS;
                    }
                }
            };
            
            crisisBtn.onclick = () => {
                world.environmentalHealth = simSettings.ENV_HEALTH_MAX * 0.1;
                alert('Environmental crisis triggered! Health is now 10%.');
            };
            
            setSpeed(simSettings.SIM_SPEED); // Initialize speed display
        }
        // --- END Game Loop and Speed Controls ---


        // --- MAIN INITIALIZATION ---
        let world, renderer, interval;

        function initializeSimulation() {
            if (interval) clearInterval(interval);
            
            // Load and apply settings before initializing world/renderer
            simSettings = loadSettings();
            applyDisplaySettings(simSettings); // Apply theme on load

            world = new World(simSettings.WORLD_WIDTH, simSettings.WORLD_HEIGHT);
            
            initializeSkillMaxes();
            
            for (let i = 0; i < simSettings.STARTING_AGENTS; i++) {
                const newAgent = world.addAgent(); 
                world.logDeath(0, 'BIRTH', newAgent.id, null, null); // Log initial agents
            }
            for (let i = 0; i < simSettings.STARTING_FOOD; i++) {
                const tile = world.getRandomEmptyTile();
                if (tile) {
                    const posKey = arrayToKey(tile);
                    world.food[posKey] = true;
                    world.foodFreshness[posKey] = simSettings.FOOD_FRESHNESS;
                }
            }
            for (let i = 0; i < simSettings.STARTING_WOOD; i++) {
                const tile = world.getRandomEmptyTile();
                if (tile) {
                    world.wood[arrayToKey(tile)] = true;
                }
            }
            for (let i = 0; i < simSettings.STARTING_FRUIT_BUSHES; i++) {
                const tile = world.getRandomEmptyTile();
                if (tile) {
                    world.addFruit(tile, ['energy', 'social', 'speed'][Math.floor(Math.random() * 3)]);
                }
            }
            
            renderer = new Renderer(world, 'worldCanvas');
            
            world.calculateStats();
            updateStatsDisplay(world);
            setupGameControls(); // Set up controls and interval after initialization

            console.log("Simulation initialized. Starting loop.");
        }

        function gameLoop() {
            if (isPaused) return;
            try {
                world.update();
                renderer.render();
                updateStatsDisplay(world);


                // SYNCHRONIZED: Use the Python overpopulation check
                if (world.agents.length > (simSettings.WORLD_WIDTH * simSettings.WORLD_HEIGHT * 0.5)) {
                    console.log("--- SIMULATION END: Overpopulation! ---");
                    clearInterval(interval);
                }
            } catch (e) {
                console.error("Error in game loop:", e);
                clearInterval(interval);
            }
        }

        window.onload = () => {
            // Load settings and apply display settings before doing anything else
            simSettings = loadSettings(); 
            applyDisplaySettings(simSettings);
            
            populateSettingsForm(simSettings);
            setupModalControls();
            
            // The legend must be populated AFTER COLORS are set by applyDisplaySettings
            // and before initializeSimulation calls renderer.render()
            // populateLegend(); // Called inside applyDisplaySettings
            
            initializeSimulation();
        };

    </script>
</body>
</html>